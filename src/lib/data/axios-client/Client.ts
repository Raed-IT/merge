//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
 import * as Types from '../axios-client' ;
 
 
import type { AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import { throwException, isAxiosError } from '../axios-client';
import { getAxios, getBaseUrl } from './helpers';

/**
 * @return OK
 */
export function actionsAll(config?: AxiosRequestConfig | undefined): Promise<Types.SectionDto[]> {
    let url_ = getBaseUrl() + "/api/layout/Actions";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigActionsAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigActionsAll?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processActionsAll(_response);
    });
}

function processActionsAll(response: AxiosResponse): Promise<Types.ActionDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.ActionDto.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.ActionDto[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ActionDto[]>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function actionsPOST(body?: Types.ActionDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.ActionDto> {
    let url_ = getBaseUrl() + "/api/layout/Actions";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigActionsPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigActionsPOST?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processActionsPOST(_response);
    });
}

function processActionsPOST(response: AxiosResponse): Promise<Types.ActionDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ActionDto.fromJS(resultData200);
        return Promise.resolve<Types.ActionDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ActionDto>(null as any);
}

/**
 * @return OK
 */
export function actionsGET(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.ActionDto> {
    let url_ = getBaseUrl() + "/api/layout/Actions/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigActionsGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigActionsGET?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processActionsGET(_response);
    });
}

function processActionsGET(response: AxiosResponse): Promise<Types.ActionDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ActionDto.fromJS(resultData200);
        return Promise.resolve<Types.ActionDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ActionDto>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function actionsPUT(id: string, body?: Types.ActionDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.ActionDto> {
    let url_ = getBaseUrl() + "/api/layout/Actions/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigActionsPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            ..._requestConfigActionsPUT?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processActionsPUT(_response);
    });
}

function processActionsPUT(response: AxiosResponse): Promise<Types.ActionDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ActionDto.fromJS(resultData200);
        return Promise.resolve<Types.ActionDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ActionDto>(null as any);
}

/**
 * @return OK
 */
export function actionsDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<boolean> {
    let url_ = getBaseUrl() + "/api/layout/Actions/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigActionsDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
            ..._requestConfigActionsDELETE?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processActionsDELETE(_response);
    });
}

function processActionsDELETE(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<boolean>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}

/**
 * @return OK
 */
export function apiKeysAll(config?: AxiosRequestConfig | undefined): Promise<Types.ApiKeyDto[]> {
    let url_ = getBaseUrl() + "/api/ApiKeys";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigApiKeysAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigApiKeysAll?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processApiKeysAll(_response);
    });
}

function processApiKeysAll(response: AxiosResponse): Promise<Types.ApiKeyDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.ApiKeyDto.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.ApiKeyDto[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ApiKeyDto[]>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function apiKeysPOST(body?: Types.ApiKeyDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.ApiKeyDto> {
    let url_ = getBaseUrl() + "/api/ApiKeys";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigApiKeysPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigApiKeysPOST?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processApiKeysPOST(_response);
    });
}

function processApiKeysPOST(response: AxiosResponse): Promise<Types.ApiKeyDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ApiKeyDto.fromJS(resultData200);
        return Promise.resolve<Types.ApiKeyDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ApiKeyDto>(null as any);
}

/**
 * @return OK
 */
export function apiKeysGET(apiKey: string, config?: AxiosRequestConfig | undefined): Promise<Types.ApiKeyDto> {
    let url_ = getBaseUrl() + "/api/ApiKeys/{apiKey}";
    if (apiKey === undefined || apiKey === null)
      throw new Error("The parameter 'apiKey' must be defined.");
    url_ = url_.replace("{apiKey}", encodeURIComponent("" + apiKey));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigApiKeysGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigApiKeysGET?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processApiKeysGET(_response);
    });
}

function processApiKeysGET(response: AxiosResponse): Promise<Types.ApiKeyDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ApiKeyDto.fromJS(resultData200);
        return Promise.resolve<Types.ApiKeyDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ApiKeyDto>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function apiKeysPUT(apiKey: string, body?: Types.ApiKeyDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.ApiKeyDto> {
    let url_ = getBaseUrl() + "/api/ApiKeys/{apiKey}";
    if (apiKey === undefined || apiKey === null)
      throw new Error("The parameter 'apiKey' must be defined.");
    url_ = url_.replace("{apiKey}", encodeURIComponent("" + apiKey));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigApiKeysPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            ..._requestConfigApiKeysPUT?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processApiKeysPUT(_response);
    });
}

function processApiKeysPUT(response: AxiosResponse): Promise<Types.ApiKeyDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ApiKeyDto.fromJS(resultData200);
        return Promise.resolve<Types.ApiKeyDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ApiKeyDto>(null as any);
}

/**
 * @return OK
 */
export function apiKeysDELETE(apiKey: string, config?: AxiosRequestConfig | undefined): Promise<boolean> {
    let url_ = getBaseUrl() + "/api/ApiKeys/{apiKey}";
    if (apiKey === undefined || apiKey === null)
      throw new Error("The parameter 'apiKey' must be defined.");
    url_ = url_.replace("{apiKey}", encodeURIComponent("" + apiKey));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigApiKeysDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
            ..._requestConfigApiKeysDELETE?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processApiKeysDELETE(_response);
    });
}

function processApiKeysDELETE(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<boolean>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}

/**
 * @return OK
 */
export function appsAll(config?: AxiosRequestConfig | undefined): Promise<Types.AppDto[]> {
    let url_ = getBaseUrl() + "/api/layout/Apps";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigAppsAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigAppsAll?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processAppsAll(_response);
    });
}

function processAppsAll(response: AxiosResponse): Promise<Types.AppDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.AppDto.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.AppDto[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.AppDto[]>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function appsPOST(body?: Types.AppDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.AppDto> {
    let url_ = getBaseUrl() + "/api/layout/Apps";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigAppsPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigAppsPOST?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processAppsPOST(_response);
    });
}

function processAppsPOST(response: AxiosResponse): Promise<Types.AppDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.AppDto.fromJS(resultData200);
        return Promise.resolve<Types.AppDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.AppDto>(null as any);
}

/**
 * @return OK
 */
export function appsGET(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.AppDto> {
    let url_ = getBaseUrl() + "/api/layout/Apps/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigAppsGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigAppsGET?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processAppsGET(_response);
    });
}

function processAppsGET(response: AxiosResponse): Promise<Types.AppDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.AppDto.fromJS(resultData200);
        return Promise.resolve<Types.AppDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.AppDto>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function appsPUT(id: string, body?: Types.AppDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.AppDto> {
    let url_ = getBaseUrl() + "/api/layout/Apps/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigAppsPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            ..._requestConfigAppsPUT?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processAppsPUT(_response);
    });
}

function processAppsPUT(response: AxiosResponse): Promise<Types.AppDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.AppDto.fromJS(resultData200);
        return Promise.resolve<Types.AppDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.AppDto>(null as any);
}

/**
 * @return OK
 */
export function appsDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<boolean> {
    let url_ = getBaseUrl() + "/api/layout/Apps/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigAppsDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
            ..._requestConfigAppsDELETE?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processAppsDELETE(_response);
    });
}

function processAppsDELETE(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<boolean>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}

/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function assets(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.AssetDtoQueryResponse> {
    let url_ = getBaseUrl() + "/api/Assets?";
    if (pageNumber === null)
        throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
        url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize === null)
        throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
        url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (totalCount === null)
        throw new Error("The parameter 'totalCount' cannot be null.");
    else if (totalCount !== undefined)
        url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&";
    if (sort_SortBy === null)
        throw new Error("The parameter 'sort_SortBy' cannot be null.");
    else if (sort_SortBy !== undefined)
        url_ += "Sort.SortBy=" + encodeURIComponent("" + sort_SortBy) + "&";
    if (sort_Ascending === null)
        throw new Error("The parameter 'sort_Ascending' cannot be null.");
    else if (sort_Ascending !== undefined)
        url_ += "Sort.Ascending=" + encodeURIComponent("" + sort_Ascending) + "&";
    if (filter_Logic === null)
        throw new Error("The parameter 'filter_Logic' cannot be null.");
    else if (filter_Logic !== undefined)
        url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&";
    if (filter_Conditions === null)
        throw new Error("The parameter 'filter_Conditions' cannot be null.");
    else if (filter_Conditions !== undefined)
        filter_Conditions && filter_Conditions.forEach((item, index) => {
            for (let attr in item)
    			if (item.hasOwnProperty(attr)) {
    				url_ += "Filter.Conditions[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
    			}
        });
    if (filter_Groups === null)
        throw new Error("The parameter 'filter_Groups' cannot be null.");
    else if (filter_Groups !== undefined)
        filter_Groups && filter_Groups.forEach((item, index) => {
            for (let attr in item)
    			if (item.hasOwnProperty(attr)) {
    				url_ += "Filter.Groups[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
    			}
        });
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigAssets,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigAssets?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processAssets(_response);
    });
}

function processAssets(response: AxiosResponse): Promise<Types.AssetDtoQueryResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.AssetDtoQueryResponse.fromJS(resultData200);
        return Promise.resolve<Types.AssetDtoQueryResponse>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.AssetDtoQueryResponse>(null as any);
}

/**
 * @return OK
 */
export function assets2(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.AssetDto> {
    let url_ = getBaseUrl() + "/api/Assets/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigAssets2,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigAssets2?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processAssets2(_response);
    });
}

function processAssets2(response: AxiosResponse): Promise<Types.AssetDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.AssetDto.fromJS(resultData200);
        return Promise.resolve<Types.AssetDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.AssetDto>(null as any);
}

/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function authorizationProfilesGET(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.AuthorizationProfileDtoQueryResponse> {
    let url_ = getBaseUrl() + "/api/AuthorizationProfiles?";
    if (pageNumber === null)
        throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
        url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize === null)
        throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
        url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (totalCount === null)
        throw new Error("The parameter 'totalCount' cannot be null.");
    else if (totalCount !== undefined)
        url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&";
    if (sort_SortBy === null)
        throw new Error("The parameter 'sort_SortBy' cannot be null.");
    else if (sort_SortBy !== undefined)
        url_ += "Sort.SortBy=" + encodeURIComponent("" + sort_SortBy) + "&";
    if (sort_Ascending === null)
        throw new Error("The parameter 'sort_Ascending' cannot be null.");
    else if (sort_Ascending !== undefined)
        url_ += "Sort.Ascending=" + encodeURIComponent("" + sort_Ascending) + "&";
    if (filter_Logic === null)
        throw new Error("The parameter 'filter_Logic' cannot be null.");
    else if (filter_Logic !== undefined)
        url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&";
    if (filter_Conditions === null)
        throw new Error("The parameter 'filter_Conditions' cannot be null.");
    else if (filter_Conditions !== undefined)
        filter_Conditions && filter_Conditions.forEach((item, index) => {
            for (let attr in item)
    			if (item.hasOwnProperty(attr)) {
    				url_ += "Filter.Conditions[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
    			}
        });
    if (filter_Groups === null)
        throw new Error("The parameter 'filter_Groups' cannot be null.");
    else if (filter_Groups !== undefined)
        filter_Groups && filter_Groups.forEach((item, index) => {
            for (let attr in item)
    			if (item.hasOwnProperty(attr)) {
    				url_ += "Filter.Groups[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
    			}
        });
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigAuthorizationProfilesGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigAuthorizationProfilesGET?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processAuthorizationProfilesGET(_response);
    });
}

function processAuthorizationProfilesGET(response: AxiosResponse): Promise<Types.AuthorizationProfileDtoQueryResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.AuthorizationProfileDtoQueryResponse.fromJS(resultData200);
        return Promise.resolve<Types.AuthorizationProfileDtoQueryResponse>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.AuthorizationProfileDtoQueryResponse>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function authorizationProfilesPOST(body?: Types.AuthorizationProfileDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.AuthorizationProfileDto> {
    let url_ = getBaseUrl() + "/api/AuthorizationProfiles";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigAuthorizationProfilesPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigAuthorizationProfilesPOST?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processAuthorizationProfilesPOST(_response);
    });
}

function processAuthorizationProfilesPOST(response: AxiosResponse): Promise<Types.AuthorizationProfileDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.AuthorizationProfileDto.fromJS(resultData200);
        return Promise.resolve<Types.AuthorizationProfileDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.AuthorizationProfileDto>(null as any);
}

/**
 * @return OK
 */
export function authorizationProfilesGET2(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.AuthorizationProfileDto> {
    let url_ = getBaseUrl() + "/api/AuthorizationProfiles/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigAuthorizationProfilesGET2,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigAuthorizationProfilesGET2?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processAuthorizationProfilesGET2(_response);
    });
}

function processAuthorizationProfilesGET2(response: AxiosResponse): Promise<Types.AuthorizationProfileDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.AuthorizationProfileDto.fromJS(resultData200);
        return Promise.resolve<Types.AuthorizationProfileDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.AuthorizationProfileDto>(null as any);
}

/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function companiesGET(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.CompanyDtoQueryResponse> {
    let url_ = getBaseUrl() + "/api/Companies?";
    if (pageNumber === null)
        throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
        url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize === null)
        throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
        url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (totalCount === null)
        throw new Error("The parameter 'totalCount' cannot be null.");
    else if (totalCount !== undefined)
        url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&";
    if (sort_SortBy === null)
        throw new Error("The parameter 'sort_SortBy' cannot be null.");
    else if (sort_SortBy !== undefined)
        url_ += "Sort.SortBy=" + encodeURIComponent("" + sort_SortBy) + "&";
    if (sort_Ascending === null)
        throw new Error("The parameter 'sort_Ascending' cannot be null.");
    else if (sort_Ascending !== undefined)
        url_ += "Sort.Ascending=" + encodeURIComponent("" + sort_Ascending) + "&";
    if (filter_Logic === null)
        throw new Error("The parameter 'filter_Logic' cannot be null.");
    else if (filter_Logic !== undefined)
        url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&";
    if (filter_Conditions === null)
        throw new Error("The parameter 'filter_Conditions' cannot be null.");
    else if (filter_Conditions !== undefined)
        filter_Conditions && filter_Conditions.forEach((item, index) => {
            for (let attr in item)
    			if (item.hasOwnProperty(attr)) {
    				url_ += "Filter.Conditions[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
    			}
        });
    if (filter_Groups === null)
        throw new Error("The parameter 'filter_Groups' cannot be null.");
    else if (filter_Groups !== undefined)
        filter_Groups && filter_Groups.forEach((item, index) => {
            for (let attr in item)
    			if (item.hasOwnProperty(attr)) {
    				url_ += "Filter.Groups[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
    			}
        });
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigCompaniesGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigCompaniesGET?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processCompaniesGET(_response);
    });
}

function processCompaniesGET(response: AxiosResponse): Promise<Types.CompanyDtoQueryResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.CompanyDtoQueryResponse.fromJS(resultData200);
        return Promise.resolve<Types.CompanyDtoQueryResponse>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.CompanyDtoQueryResponse>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function companiesPOST(body?: Types.CompanyDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.CompanyDto> {
    let url_ = getBaseUrl() + "/api/Companies";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigCompaniesPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigCompaniesPOST?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processCompaniesPOST(_response);
    });
}

function processCompaniesPOST(response: AxiosResponse): Promise<Types.CompanyDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.CompanyDto.fromJS(resultData200);
        return Promise.resolve<Types.CompanyDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.CompanyDto>(null as any);
}

/**
 * @return OK
 */
export function companiesGET2(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.CompanyDto> {
    let url_ = getBaseUrl() + "/api/Companies/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigCompaniesGET2,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigCompaniesGET2?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processCompaniesGET2(_response);
    });
}

function processCompaniesGET2(response: AxiosResponse): Promise<Types.CompanyDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.CompanyDto.fromJS(resultData200);
        return Promise.resolve<Types.CompanyDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.CompanyDto>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function companiesPUT(id: string, body?: Types.CompanyDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.CompanyDto> {
    let url_ = getBaseUrl() + "/api/Companies/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigCompaniesPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            ..._requestConfigCompaniesPUT?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processCompaniesPUT(_response);
    });
}

function processCompaniesPUT(response: AxiosResponse): Promise<Types.CompanyDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.CompanyDto.fromJS(resultData200);
        return Promise.resolve<Types.CompanyDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.CompanyDto>(null as any);
}

/**
 * @return OK
 */
export function companiesDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<boolean> {
    let url_ = getBaseUrl() + "/api/Companies/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigCompaniesDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
            ..._requestConfigCompaniesDELETE?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processCompaniesDELETE(_response);
    });
}

function processCompaniesDELETE(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<boolean>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function createContact(id: string, body?: Types.ContactDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.ContactDto> {
    let url_ = getBaseUrl() + "/api/Companies/{id}/create-contact";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigCreateContact,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigCreateContact?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processCreateContact(_response);
    });
}

function processCreateContact(response: AxiosResponse): Promise<Types.ContactDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ContactDto.fromJS(resultData200);
        return Promise.resolve<Types.ContactDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ContactDto>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function inviteUser(companyId: string, contactId: string, body?: Types.InviteContactDto | undefined, config?: AxiosRequestConfig | undefined): Promise<boolean> {
    let url_ = getBaseUrl() + "/api/Companies/{companyId}/invite-user/{contactId}";
    if (companyId === undefined || companyId === null)
      throw new Error("The parameter 'companyId' must be defined.");
    url_ = url_.replace("{companyId}", encodeURIComponent("" + companyId));
    if (contactId === undefined || contactId === null)
      throw new Error("The parameter 'contactId' must be defined.");
    url_ = url_.replace("{contactId}", encodeURIComponent("" + contactId));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigInviteUser,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigInviteUser?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processInviteUser(_response);
    });
}

function processInviteUser(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<boolean>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function configurationGET(body?: Types.QueryPayload | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.ConfigurationDtoQueryResponse> {
    let url_ = getBaseUrl() + "/api/Configuration";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigConfigurationGET,
        ...config,
        data: content_,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigConfigurationGET?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processConfigurationGET(_response);
    });
}

function processConfigurationGET(response: AxiosResponse): Promise<Types.ConfigurationDtoQueryResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ConfigurationDtoQueryResponse.fromJS(resultData200);
        return Promise.resolve<Types.ConfigurationDtoQueryResponse>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ConfigurationDtoQueryResponse>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function configurationPOST(body?: Types.ConfigurationDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.ConfigurationDto> {
    let url_ = getBaseUrl() + "/api/Configuration";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigConfigurationPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigConfigurationPOST?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processConfigurationPOST(_response);
    });
}

function processConfigurationPOST(response: AxiosResponse): Promise<Types.ConfigurationDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ConfigurationDto.fromJS(resultData200);
        return Promise.resolve<Types.ConfigurationDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ConfigurationDto>(null as any);
}

/**
 * @return OK
 */
export function configurationGET2(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.ConfigurationDto> {
    let url_ = getBaseUrl() + "/api/Configuration/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigConfigurationGET2,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigConfigurationGET2?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processConfigurationGET2(_response);
    });
}

function processConfigurationGET2(response: AxiosResponse): Promise<Types.ConfigurationDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ConfigurationDto.fromJS(resultData200);
        return Promise.resolve<Types.ConfigurationDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ConfigurationDto>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function configurationPATCH(id: string, body?: Types.ConfigurationDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.ConfigurationDto> {
    let url_ = getBaseUrl() + "/api/Configuration/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigConfigurationPATCH,
        ...config,
        data: content_,
        method: "PATCH",
        url: url_,
        headers: {
            ..._requestConfigConfigurationPATCH?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processConfigurationPATCH(_response);
    });
}

function processConfigurationPATCH(response: AxiosResponse): Promise<Types.ConfigurationDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ConfigurationDto.fromJS(resultData200);
        return Promise.resolve<Types.ConfigurationDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ConfigurationDto>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function configurationPUT(id: string, body?: Types.ConfigurationDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.ConfigurationDto> {
    let url_ = getBaseUrl() + "/api/Configuration/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigConfigurationPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            ..._requestConfigConfigurationPUT?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processConfigurationPUT(_response);
    });
}

function processConfigurationPUT(response: AxiosResponse): Promise<Types.ConfigurationDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ConfigurationDto.fromJS(resultData200);
        return Promise.resolve<Types.ConfigurationDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ConfigurationDto>(null as any);
}

/**
 * @return OK
 */
export function configurationDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<boolean> {
    let url_ = getBaseUrl() + "/api/Configuration/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigConfigurationDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
            ..._requestConfigConfigurationDELETE?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processConfigurationDELETE(_response);
    });
}

function processConfigurationDELETE(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<boolean>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}

/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function consignmentsGET(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.ConsignmentDtoQueryResponse> {
    let url_ = getBaseUrl() + "/api/Consignments?";
    if (pageNumber === null)
        throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
        url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize === null)
        throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
        url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (totalCount === null)
        throw new Error("The parameter 'totalCount' cannot be null.");
    else if (totalCount !== undefined)
        url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&";
    if (sort_SortBy === null)
        throw new Error("The parameter 'sort_SortBy' cannot be null.");
    else if (sort_SortBy !== undefined)
        url_ += "Sort.SortBy=" + encodeURIComponent("" + sort_SortBy) + "&";
    if (sort_Ascending === null)
        throw new Error("The parameter 'sort_Ascending' cannot be null.");
    else if (sort_Ascending !== undefined)
        url_ += "Sort.Ascending=" + encodeURIComponent("" + sort_Ascending) + "&";
    if (filter_Logic === null)
        throw new Error("The parameter 'filter_Logic' cannot be null.");
    else if (filter_Logic !== undefined)
        url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&";
    if (filter_Conditions === null)
        throw new Error("The parameter 'filter_Conditions' cannot be null.");
    else if (filter_Conditions !== undefined)
        filter_Conditions && filter_Conditions.forEach((item, index) => {
            for (let attr in item)
    			if (item.hasOwnProperty(attr)) {
    				url_ += "Filter.Conditions[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
    			}
        });
    if (filter_Groups === null)
        throw new Error("The parameter 'filter_Groups' cannot be null.");
    else if (filter_Groups !== undefined)
        filter_Groups && filter_Groups.forEach((item, index) => {
            for (let attr in item)
    			if (item.hasOwnProperty(attr)) {
    				url_ += "Filter.Groups[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
    			}
        });
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigConsignmentsGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigConsignmentsGET?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processConsignmentsGET(_response);
    });
}

function processConsignmentsGET(response: AxiosResponse): Promise<Types.ConsignmentDtoQueryResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ConsignmentDtoQueryResponse.fromJS(resultData200);
        return Promise.resolve<Types.ConsignmentDtoQueryResponse>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ConsignmentDtoQueryResponse>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function consignmentsPOST(body?: Types.ConsignmentDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.ConsignmentDto> {
    let url_ = getBaseUrl() + "/api/Consignments";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigConsignmentsPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigConsignmentsPOST?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processConsignmentsPOST(_response);
    });
}

function processConsignmentsPOST(response: AxiosResponse): Promise<Types.ConsignmentDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ConsignmentDto.fromJS(resultData200);
        return Promise.resolve<Types.ConsignmentDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ConsignmentDto>(null as any);
}

/**
 * @return OK
 */
export function consignmentsGET2(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.ConsignmentDto> {
    let url_ = getBaseUrl() + "/api/Consignments/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigConsignmentsGET2,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigConsignmentsGET2?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processConsignmentsGET2(_response);
    });
}

function processConsignmentsGET2(response: AxiosResponse): Promise<Types.ConsignmentDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ConsignmentDto.fromJS(resultData200);
        return Promise.resolve<Types.ConsignmentDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ConsignmentDto>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function consignmentsPUT(id: string, body?: Types.ConsignmentDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.ConsignmentDto> {
    let url_ = getBaseUrl() + "/api/Consignments/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigConsignmentsPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            ..._requestConfigConsignmentsPUT?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processConsignmentsPUT(_response);
    });
}

function processConsignmentsPUT(response: AxiosResponse): Promise<Types.ConsignmentDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ConsignmentDto.fromJS(resultData200);
        return Promise.resolve<Types.ConsignmentDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ConsignmentDto>(null as any);
}

/**
 * @return OK
 */
export function consignmentsDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<boolean> {
    let url_ = getBaseUrl() + "/api/Consignments/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigConsignmentsDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
            ..._requestConfigConsignmentsDELETE?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processConsignmentsDELETE(_response);
    });
}

function processConsignmentsDELETE(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<boolean>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}

/**
 * @param address (optional) 
 * @return OK
 */
export function validateAddress(address?: string | undefined, config?: AxiosRequestConfig | undefined): Promise<boolean> {
    let url_ = getBaseUrl() + "/api/Consignments/validate-address?";
    if (address === null)
        throw new Error("The parameter 'address' cannot be null.");
    else if (address !== undefined)
        url_ += "address=" + encodeURIComponent("" + address) + "&";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigValidateAddress,
        ...config,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigValidateAddress?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processValidateAddress(_response);
    });
}

function processValidateAddress(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<boolean>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function updateStatus(id: string, body?: Types.ConsignmentStatusUpdateDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.ConsignmentDto> {
    let url_ = getBaseUrl() + "/api/Consignments/update-status/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigUpdateStatus,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigUpdateStatus?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processUpdateStatus(_response);
    });
}

function processUpdateStatus(response: AxiosResponse): Promise<Types.ConsignmentDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ConsignmentDto.fromJS(resultData200);
        return Promise.resolve<Types.ConsignmentDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ConsignmentDto>(null as any);
}

/**
 * @param file (optional) 
 * @return OK
 */
export function uploadPod(id: string, file?: Types.FileParameter | undefined, config?: AxiosRequestConfig | undefined): Promise<boolean> {
    let url_ = getBaseUrl() + "/api/Consignments/upload-pod/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (file === null || file === undefined)
        throw new Error("The parameter 'file' cannot be null.");
    else
        content_.append("file", file.data, file.fileName ? file.fileName : "file");

    let options_: AxiosRequestConfig = {
        ..._requestConfigUploadPod,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigUploadPod?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processUploadPod(_response);
    });
}

function processUploadPod(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<boolean>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}

/**
 * @return OK
 */
export function downloadPod(id: string, assetId: string, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Consignments/download-pod/{id}/{assetId}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (assetId === undefined || assetId === null)
      throw new Error("The parameter 'assetId' must be defined.");
    url_ = url_.replace("{assetId}", encodeURIComponent("" + assetId));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigDownloadPod,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigDownloadPod?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processDownloadPod(_response);
    });
}

function processDownloadPod(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @return OK
 */
export function deletePod(id: string, assetId: string, config?: AxiosRequestConfig | undefined): Promise<boolean> {
    let url_ = getBaseUrl() + "/api/Consignments/delete-pod/{id}/{assetId}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (assetId === undefined || assetId === null)
      throw new Error("The parameter 'assetId' must be defined.");
    url_ = url_.replace("{assetId}", encodeURIComponent("" + assetId));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigDeletePod,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
            ..._requestConfigDeletePod?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processDeletePod(_response);
    });
}

function processDeletePod(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<boolean>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}

/**
 * @return OK
 */
export function dashboardsAll(config?: AxiosRequestConfig | undefined): Promise<Types.DashboardDto[]> {
    let url_ = getBaseUrl() + "/api/layout/Dashboards";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigDashboardsAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigDashboardsAll?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processDashboardsAll(_response);
    });
}

function processDashboardsAll(response: AxiosResponse): Promise<Types.DashboardDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.DashboardDto.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.DashboardDto[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.DashboardDto[]>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function dashboardsPOST(body?: Types.DashboardDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.DashboardDto> {
    let url_ = getBaseUrl() + "/api/layout/Dashboards";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigDashboardsPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigDashboardsPOST?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processDashboardsPOST(_response);
    });
}

function processDashboardsPOST(response: AxiosResponse): Promise<Types.DashboardDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.DashboardDto.fromJS(resultData200);
        return Promise.resolve<Types.DashboardDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.DashboardDto>(null as any);
}

/**
 * @return OK
 */
export function dashboardsGET(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.DashboardDto> {
    let url_ = getBaseUrl() + "/api/layout/Dashboards/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigDashboardsGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigDashboardsGET?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processDashboardsGET(_response);
    });
}

function processDashboardsGET(response: AxiosResponse): Promise<Types.DashboardDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.DashboardDto.fromJS(resultData200);
        return Promise.resolve<Types.DashboardDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.DashboardDto>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function dashboardsPUT(id: string, body?: Types.DashboardDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.DashboardDto> {
    let url_ = getBaseUrl() + "/api/layout/Dashboards/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigDashboardsPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            ..._requestConfigDashboardsPUT?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processDashboardsPUT(_response);
    });
}

function processDashboardsPUT(response: AxiosResponse): Promise<Types.DashboardDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.DashboardDto.fromJS(resultData200);
        return Promise.resolve<Types.DashboardDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.DashboardDto>(null as any);
}

/**
 * @return OK
 */
export function dashboardsDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<boolean> {
    let url_ = getBaseUrl() + "/api/layout/Dashboards/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigDashboardsDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
            ..._requestConfigDashboardsDELETE?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processDashboardsDELETE(_response);
    });
}

function processDashboardsDELETE(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<boolean>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}

/**
 * @return OK
 */
export function dataSourcesAll(config?: AxiosRequestConfig | undefined): Promise<Types.DataSourceDto[]> {
    let url_ = getBaseUrl() + "/api/layout/DataSources";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigDataSourcesAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigDataSourcesAll?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processDataSourcesAll(_response);
    });
}

function processDataSourcesAll(response: AxiosResponse): Promise<Types.DataSourceDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.DataSourceDto.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.DataSourceDto[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.DataSourceDto[]>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function dataSourcesPOST(body?: Types.DataSourceDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.DataSourceDto> {
    let url_ = getBaseUrl() + "/api/layout/DataSources";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigDataSourcesPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigDataSourcesPOST?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processDataSourcesPOST(_response);
    });
}

function processDataSourcesPOST(response: AxiosResponse): Promise<Types.DataSourceDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.DataSourceDto.fromJS(resultData200);
        return Promise.resolve<Types.DataSourceDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.DataSourceDto>(null as any);
}

/**
 * @return OK
 */
export function dataSourcesGET(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.DataSourceDto> {
    let url_ = getBaseUrl() + "/api/layout/DataSources/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigDataSourcesGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigDataSourcesGET?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processDataSourcesGET(_response);
    });
}

function processDataSourcesGET(response: AxiosResponse): Promise<Types.DataSourceDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.DataSourceDto.fromJS(resultData200);
        return Promise.resolve<Types.DataSourceDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.DataSourceDto>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function dataSourcesPUT(id: string, body?: Types.DataSourceDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.DataSourceDto> {
    let url_ = getBaseUrl() + "/api/layout/DataSources/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigDataSourcesPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            ..._requestConfigDataSourcesPUT?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processDataSourcesPUT(_response);
    });
}

function processDataSourcesPUT(response: AxiosResponse): Promise<Types.DataSourceDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.DataSourceDto.fromJS(resultData200);
        return Promise.resolve<Types.DataSourceDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.DataSourceDto>(null as any);
}

/**
 * @return OK
 */
export function dataSourcesDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<boolean> {
    let url_ = getBaseUrl() + "/api/layout/DataSources/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigDataSourcesDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
            ..._requestConfigDataSourcesDELETE?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processDataSourcesDELETE(_response);
    });
}

function processDataSourcesDELETE(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<boolean>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}

/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function drivers(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.EmployeeDtoQueryResponse> {
    let url_ = getBaseUrl() + "/api/Drivers?";
    if (pageNumber === null)
        throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
        url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize === null)
        throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
        url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (totalCount === null)
        throw new Error("The parameter 'totalCount' cannot be null.");
    else if (totalCount !== undefined)
        url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&";
    if (sort_SortBy === null)
        throw new Error("The parameter 'sort_SortBy' cannot be null.");
    else if (sort_SortBy !== undefined)
        url_ += "Sort.SortBy=" + encodeURIComponent("" + sort_SortBy) + "&";
    if (sort_Ascending === null)
        throw new Error("The parameter 'sort_Ascending' cannot be null.");
    else if (sort_Ascending !== undefined)
        url_ += "Sort.Ascending=" + encodeURIComponent("" + sort_Ascending) + "&";
    if (filter_Logic === null)
        throw new Error("The parameter 'filter_Logic' cannot be null.");
    else if (filter_Logic !== undefined)
        url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&";
    if (filter_Conditions === null)
        throw new Error("The parameter 'filter_Conditions' cannot be null.");
    else if (filter_Conditions !== undefined)
        filter_Conditions && filter_Conditions.forEach((item, index) => {
            for (let attr in item)
    			if (item.hasOwnProperty(attr)) {
    				url_ += "Filter.Conditions[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
    			}
        });
    if (filter_Groups === null)
        throw new Error("The parameter 'filter_Groups' cannot be null.");
    else if (filter_Groups !== undefined)
        filter_Groups && filter_Groups.forEach((item, index) => {
            for (let attr in item)
    			if (item.hasOwnProperty(attr)) {
    				url_ += "Filter.Groups[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
    			}
        });
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigDrivers,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigDrivers?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processDrivers(_response);
    });
}

function processDrivers(response: AxiosResponse): Promise<Types.EmployeeDtoQueryResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.EmployeeDtoQueryResponse.fromJS(resultData200);
        return Promise.resolve<Types.EmployeeDtoQueryResponse>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.EmployeeDtoQueryResponse>(null as any);
}

/**
 * @return OK
 */
export function drivers2(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.EmployeeDto> {
    let url_ = getBaseUrl() + "/api/Drivers/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigDrivers2,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigDrivers2?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processDrivers2(_response);
    });
}

function processDrivers2(response: AxiosResponse): Promise<Types.EmployeeDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.EmployeeDto.fromJS(resultData200);
        return Promise.resolve<Types.EmployeeDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.EmployeeDto>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function recordHistory(body?: Types.DriverHistoryDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.EmployeeDto> {
    let url_ = getBaseUrl() + "/api/Drivers/record-history";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigRecordHistory,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigRecordHistory?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processRecordHistory(_response);
    });
}

function processRecordHistory(response: AxiosResponse): Promise<Types.EmployeeDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.EmployeeDto.fromJS(resultData200);
        return Promise.resolve<Types.EmployeeDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.EmployeeDto>(null as any);
}

/**
 * @return OK
 */
export function getHistory(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.DriverHistoryDto[]> {
    let url_ = getBaseUrl() + "/api/Drivers/get-history/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigGetHistory,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigGetHistory?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processGetHistory(_response);
    });
}

function processGetHistory(response: AxiosResponse): Promise<Types.DriverHistoryDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.DriverHistoryDto.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.DriverHistoryDto[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.DriverHistoryDto[]>(null as any);
}

/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function employeesGET(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.EmployeeDtoQueryResponse> {
    let url_ = getBaseUrl() + "/api/Employees?";
    if (pageNumber === null)
        throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
        url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize === null)
        throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
        url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (totalCount === null)
        throw new Error("The parameter 'totalCount' cannot be null.");
    else if (totalCount !== undefined)
        url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&";
    if (sort_SortBy === null)
        throw new Error("The parameter 'sort_SortBy' cannot be null.");
    else if (sort_SortBy !== undefined)
        url_ += "Sort.SortBy=" + encodeURIComponent("" + sort_SortBy) + "&";
    if (sort_Ascending === null)
        throw new Error("The parameter 'sort_Ascending' cannot be null.");
    else if (sort_Ascending !== undefined)
        url_ += "Sort.Ascending=" + encodeURIComponent("" + sort_Ascending) + "&";
    if (filter_Logic === null)
        throw new Error("The parameter 'filter_Logic' cannot be null.");
    else if (filter_Logic !== undefined)
        url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&";
    if (filter_Conditions === null)
        throw new Error("The parameter 'filter_Conditions' cannot be null.");
    else if (filter_Conditions !== undefined)
        filter_Conditions && filter_Conditions.forEach((item, index) => {
            for (let attr in item)
    			if (item.hasOwnProperty(attr)) {
    				url_ += "Filter.Conditions[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
    			}
        });
    if (filter_Groups === null)
        throw new Error("The parameter 'filter_Groups' cannot be null.");
    else if (filter_Groups !== undefined)
        filter_Groups && filter_Groups.forEach((item, index) => {
            for (let attr in item)
    			if (item.hasOwnProperty(attr)) {
    				url_ += "Filter.Groups[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
    			}
        });
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigEmployeesGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigEmployeesGET?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processEmployeesGET(_response);
    });
}

function processEmployeesGET(response: AxiosResponse): Promise<Types.EmployeeDtoQueryResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.EmployeeDtoQueryResponse.fromJS(resultData200);
        return Promise.resolve<Types.EmployeeDtoQueryResponse>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.EmployeeDtoQueryResponse>(null as any);
}

/**
 * @return OK
 */
export function employeesGET2(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.CompanyDto> {
    let url_ = getBaseUrl() + "/api/Employees/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigEmployeesGET2,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigEmployeesGET2?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processEmployeesGET2(_response);
    });
}

function processEmployeesGET2(response: AxiosResponse): Promise<Types.CompanyDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.CompanyDto.fromJS(resultData200);
        return Promise.resolve<Types.CompanyDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.CompanyDto>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function employeesPUT(id: string, body?: Types.EmployeeDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.EmployeeDto> {
    let url_ = getBaseUrl() + "/api/Employees/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigEmployeesPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            ..._requestConfigEmployeesPUT?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processEmployeesPUT(_response);
    });
}

function processEmployeesPUT(response: AxiosResponse): Promise<Types.EmployeeDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.EmployeeDto.fromJS(resultData200);
        return Promise.resolve<Types.EmployeeDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.EmployeeDto>(null as any);
}

/**
 * @return OK
 */
export function deactivateEmployee(id: string, config?: AxiosRequestConfig | undefined): Promise<boolean> {
    let url_ = getBaseUrl() + "/api/Employees/{id}/deactivate-employee";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigDeactivateEmployee,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
            ..._requestConfigDeactivateEmployee?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processDeactivateEmployee(_response);
    });
}

function processDeactivateEmployee(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<boolean>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}

/**
 * @return OK
 */
export function reactivateEmployee(id: string, config?: AxiosRequestConfig | undefined): Promise<boolean> {
    let url_ = getBaseUrl() + "/api/Employees/{id}/reactivate-employee";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigReactivateEmployee,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigReactivateEmployee?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processReactivateEmployee(_response);
    });
}

function processReactivateEmployee(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<boolean>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}

/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function deletedEmployees(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.EmployeeDtoQueryResponse> {
    let url_ = getBaseUrl() + "/api/Employees/deleted-employees?";
    if (pageNumber === null)
        throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
        url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize === null)
        throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
        url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (totalCount === null)
        throw new Error("The parameter 'totalCount' cannot be null.");
    else if (totalCount !== undefined)
        url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&";
    if (sort_SortBy === null)
        throw new Error("The parameter 'sort_SortBy' cannot be null.");
    else if (sort_SortBy !== undefined)
        url_ += "Sort.SortBy=" + encodeURIComponent("" + sort_SortBy) + "&";
    if (sort_Ascending === null)
        throw new Error("The parameter 'sort_Ascending' cannot be null.");
    else if (sort_Ascending !== undefined)
        url_ += "Sort.Ascending=" + encodeURIComponent("" + sort_Ascending) + "&";
    if (filter_Logic === null)
        throw new Error("The parameter 'filter_Logic' cannot be null.");
    else if (filter_Logic !== undefined)
        url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&";
    if (filter_Conditions === null)
        throw new Error("The parameter 'filter_Conditions' cannot be null.");
    else if (filter_Conditions !== undefined)
        filter_Conditions && filter_Conditions.forEach((item, index) => {
            for (let attr in item)
    			if (item.hasOwnProperty(attr)) {
    				url_ += "Filter.Conditions[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
    			}
        });
    if (filter_Groups === null)
        throw new Error("The parameter 'filter_Groups' cannot be null.");
    else if (filter_Groups !== undefined)
        filter_Groups && filter_Groups.forEach((item, index) => {
            for (let attr in item)
    			if (item.hasOwnProperty(attr)) {
    				url_ += "Filter.Groups[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
    			}
        });
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigDeletedEmployees,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigDeletedEmployees?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processDeletedEmployees(_response);
    });
}

function processDeletedEmployees(response: AxiosResponse): Promise<Types.EmployeeDtoQueryResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.EmployeeDtoQueryResponse.fromJS(resultData200);
        return Promise.resolve<Types.EmployeeDtoQueryResponse>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.EmployeeDtoQueryResponse>(null as any);
}

/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function failureReasonsGET(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.FailureReasonDtoQueryResponse> {
    let url_ = getBaseUrl() + "/api/FailureReasons?";
    if (pageNumber === null)
        throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
        url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize === null)
        throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
        url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (totalCount === null)
        throw new Error("The parameter 'totalCount' cannot be null.");
    else if (totalCount !== undefined)
        url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&";
    if (sort_SortBy === null)
        throw new Error("The parameter 'sort_SortBy' cannot be null.");
    else if (sort_SortBy !== undefined)
        url_ += "Sort.SortBy=" + encodeURIComponent("" + sort_SortBy) + "&";
    if (sort_Ascending === null)
        throw new Error("The parameter 'sort_Ascending' cannot be null.");
    else if (sort_Ascending !== undefined)
        url_ += "Sort.Ascending=" + encodeURIComponent("" + sort_Ascending) + "&";
    if (filter_Logic === null)
        throw new Error("The parameter 'filter_Logic' cannot be null.");
    else if (filter_Logic !== undefined)
        url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&";
    if (filter_Conditions === null)
        throw new Error("The parameter 'filter_Conditions' cannot be null.");
    else if (filter_Conditions !== undefined)
        filter_Conditions && filter_Conditions.forEach((item, index) => {
            for (let attr in item)
    			if (item.hasOwnProperty(attr)) {
    				url_ += "Filter.Conditions[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
    			}
        });
    if (filter_Groups === null)
        throw new Error("The parameter 'filter_Groups' cannot be null.");
    else if (filter_Groups !== undefined)
        filter_Groups && filter_Groups.forEach((item, index) => {
            for (let attr in item)
    			if (item.hasOwnProperty(attr)) {
    				url_ += "Filter.Groups[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
    			}
        });
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigFailureReasonsGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigFailureReasonsGET?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processFailureReasonsGET(_response);
    });
}

function processFailureReasonsGET(response: AxiosResponse): Promise<Types.FailureReasonDtoQueryResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.FailureReasonDtoQueryResponse.fromJS(resultData200);
        return Promise.resolve<Types.FailureReasonDtoQueryResponse>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.FailureReasonDtoQueryResponse>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function failureReasonsPOST(body?: Types.FailureReasonDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.FailureReasonDto> {
    let url_ = getBaseUrl() + "/api/FailureReasons";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigFailureReasonsPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigFailureReasonsPOST?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processFailureReasonsPOST(_response);
    });
}

function processFailureReasonsPOST(response: AxiosResponse): Promise<Types.FailureReasonDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.FailureReasonDto.fromJS(resultData200);
        return Promise.resolve<Types.FailureReasonDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.FailureReasonDto>(null as any);
}

/**
 * @return OK
 */
export function failureReasonsGET2(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.FailureReasonDto> {
    let url_ = getBaseUrl() + "/api/FailureReasons/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigFailureReasonsGET2,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigFailureReasonsGET2?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processFailureReasonsGET2(_response);
    });
}

function processFailureReasonsGET2(response: AxiosResponse): Promise<Types.FailureReasonDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.FailureReasonDto.fromJS(resultData200);
        return Promise.resolve<Types.FailureReasonDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.FailureReasonDto>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function failureReasonsPUT(id: string, body?: Types.FailureReasonDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.FailureReasonDto> {
    let url_ = getBaseUrl() + "/api/FailureReasons/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigFailureReasonsPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            ..._requestConfigFailureReasonsPUT?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processFailureReasonsPUT(_response);
    });
}

function processFailureReasonsPUT(response: AxiosResponse): Promise<Types.FailureReasonDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.FailureReasonDto.fromJS(resultData200);
        return Promise.resolve<Types.FailureReasonDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.FailureReasonDto>(null as any);
}

/**
 * @return OK
 */
export function failureReasonsDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<boolean> {
    let url_ = getBaseUrl() + "/api/FailureReasons/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigFailureReasonsDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
            ..._requestConfigFailureReasonsDELETE?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processFailureReasonsDELETE(_response);
    });
}

function processFailureReasonsDELETE(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<boolean>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}

/**
 * @return OK
 */
export function fieldsAll(config?: AxiosRequestConfig | undefined): Promise<Types.FieldDto[]> {
    let url_ = getBaseUrl() + "/api/layout/Fields";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigFieldsAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigFieldsAll?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processFieldsAll(_response);
    });
}

function processFieldsAll(response: AxiosResponse): Promise<Types.FieldDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.FieldDto.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.FieldDto[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.FieldDto[]>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function fieldsPOST(body?: Types.FieldDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.FieldDto> {
    let url_ = getBaseUrl() + "/api/layout/Fields";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigFieldsPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigFieldsPOST?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processFieldsPOST(_response);
    });
}

function processFieldsPOST(response: AxiosResponse): Promise<Types.FieldDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.FieldDto.fromJS(resultData200);
        return Promise.resolve<Types.FieldDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.FieldDto>(null as any);
}

/**
 * @return OK
 */
export function fieldsGET(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.FieldDto> {
    let url_ = getBaseUrl() + "/api/layout/Fields/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigFieldsGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigFieldsGET?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processFieldsGET(_response);
    });
}

function processFieldsGET(response: AxiosResponse): Promise<Types.FieldDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.FieldDto.fromJS(resultData200);
        return Promise.resolve<Types.FieldDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.FieldDto>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function fieldsPUT(id: string, body?: Types.FieldDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.FieldDto> {
    let url_ = getBaseUrl() + "/api/layout/Fields/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigFieldsPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            ..._requestConfigFieldsPUT?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processFieldsPUT(_response);
    });
}

function processFieldsPUT(response: AxiosResponse): Promise<Types.FieldDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.FieldDto.fromJS(resultData200);
        return Promise.resolve<Types.FieldDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.FieldDto>(null as any);
}

/**
 * @return OK
 */
export function fieldsDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<boolean> {
    let url_ = getBaseUrl() + "/api/layout/Fields/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigFieldsDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
            ..._requestConfigFieldsDELETE?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processFieldsDELETE(_response);
    });
}

function processFieldsDELETE(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<boolean>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function fullRegistration(body?: Types.FullRegistrationDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.FullRegistrationResponse> {
    let url_ = getBaseUrl() + "/api/Identity/full-registration";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigFullRegistration,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigFullRegistration?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processFullRegistration(_response);
    });
}

function processFullRegistration(response: AxiosResponse): Promise<Types.FullRegistrationResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.FullRegistrationResponse.fromJS(resultData200);
        return Promise.resolve<Types.FullRegistrationResponse>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.FullRegistrationResponse>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function registerOrg(body?: Types.RegisterNewOrganizationDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.OrgRegistrationResponse> {
    let url_ = getBaseUrl() + "/api/Identity/register-org";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigRegisterOrg,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigRegisterOrg?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processRegisterOrg(_response);
    });
}

function processRegisterOrg(response: AxiosResponse): Promise<Types.OrgRegistrationResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.OrgRegistrationResponse.fromJS(resultData200);
        return Promise.resolve<Types.OrgRegistrationResponse>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.OrgRegistrationResponse>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function inviteEmployee(body?: Types.EmployeeInvitationRequestDto | undefined, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Identity/invite-employee";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigInviteEmployee,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigInviteEmployee?.headers,
            "Content-Type": "application/json",
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processInviteEmployee(_response);
    });
}

function processInviteEmployee(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function registerUser(body?: Types.RegisterUserDto | undefined, config?: AxiosRequestConfig | undefined): Promise<string> {
    let url_ = getBaseUrl() + "/api/Identity/register-user";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigRegisterUser,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigRegisterUser?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processRegisterUser(_response);
    });
}

function processRegisterUser(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<string>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function login(body?: Types.LoginRequest | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.LoginResponse> {
    let url_ = getBaseUrl() + "/api/Identity/login";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigLogin,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigLogin?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processLogin(_response);
    });
}

function processLogin(response: AxiosResponse): Promise<Types.LoginResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.LoginResponse.fromJS(resultData200);
        return Promise.resolve<Types.LoginResponse>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.LoginResponse>(null as any);
}

/**
 * @return OK
 */
export function userOrganizations(config?: AxiosRequestConfig | undefined): Promise<Types.OrganizationDetailsDto[]> {
    let url_ = getBaseUrl() + "/api/Identity/user-organizations";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigUserOrganizations,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigUserOrganizations?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processUserOrganizations(_response);
    });
}

function processUserOrganizations(response: AxiosResponse): Promise<Types.OrganizationDetailsDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.OrganizationDetailsDto.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.OrganizationDetailsDto[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.OrganizationDetailsDto[]>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function orgLogin(body?: Types.OrgLoginRequest | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.OrgLoginResponse> {
    let url_ = getBaseUrl() + "/api/Identity/org-login";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigOrgLogin,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigOrgLogin?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processOrgLogin(_response);
    });
}

function processOrgLogin(response: AxiosResponse): Promise<Types.OrgLoginResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.OrgLoginResponse.fromJS(resultData200);
        return Promise.resolve<Types.OrgLoginResponse>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.OrgLoginResponse>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function refreshToken(body?: Types.RefreshTokenPayload | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.OrgLoginResponse> {
    let url_ = getBaseUrl() + "/api/Identity/refresh-token";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigRefreshToken,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigRefreshToken?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processRefreshToken(_response);
    });
}

function processRefreshToken(response: AxiosResponse): Promise<Types.OrgLoginResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.OrgLoginResponse.fromJS(resultData200);
        return Promise.resolve<Types.OrgLoginResponse>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.OrgLoginResponse>(null as any);
}

/**
 * @return OK
 */
export function associateCompanies(config?: AxiosRequestConfig | undefined): Promise<Types.CompanyDto[]> {
    let url_ = getBaseUrl() + "/api/Identity/associate-companies";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigAssociateCompanies,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigAssociateCompanies?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processAssociateCompanies(_response);
    });
}

function processAssociateCompanies(response: AxiosResponse): Promise<Types.CompanyDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.CompanyDto.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.CompanyDto[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.CompanyDto[]>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function associateLogin(body?: Types.AssociateLoginDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.OrgLoginResponse> {
    let url_ = getBaseUrl() + "/api/Identity/associate-login";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigAssociateLogin,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigAssociateLogin?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processAssociateLogin(_response);
    });
}

function processAssociateLogin(response: AxiosResponse): Promise<Types.OrgLoginResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.OrgLoginResponse.fromJS(resultData200);
        return Promise.resolve<Types.OrgLoginResponse>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.OrgLoginResponse>(null as any);
}

/**
 * @return OK
 */
export function currentUser(config?: AxiosRequestConfig | undefined): Promise<Types.UserWithOrgDetailsDto> {
    let url_ = getBaseUrl() + "/api/Identity/current-user";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigCurrentUser,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigCurrentUser?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processCurrentUser(_response);
    });
}

function processCurrentUser(response: AxiosResponse): Promise<Types.UserWithOrgDetailsDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.UserWithOrgDetailsDto.fromJS(resultData200);
        return Promise.resolve<Types.UserWithOrgDetailsDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.UserWithOrgDetailsDto>(null as any);
}

/**
 * @return OK
 */
export function organizationUsers(config?: AxiosRequestConfig | undefined): Promise<Types.UserListDto[]> {
    let url_ = getBaseUrl() + "/api/Identity/organization-users";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigOrganizationUsers,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigOrganizationUsers?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processOrganizationUsers(_response);
    });
}

function processOrganizationUsers(response: AxiosResponse): Promise<Types.UserListDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.UserListDto.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.UserListDto[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.UserListDto[]>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function logout(body?: Types.LogoutRequest | undefined, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Identity/logout";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigLogout,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigLogout?.headers,
            "Content-Type": "application/json",
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processLogout(_response);
    });
}

function processLogout(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function resetPasswordRequest(body?: Types.ResetPasswordRequest | undefined, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Identity/reset-password-request";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigResetPasswordRequest,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigResetPasswordRequest?.headers,
            "Content-Type": "application/json",
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processResetPasswordRequest(_response);
    });
}

function processResetPasswordRequest(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function confirmResetPassword(body?: Types.ResetPasswordConfirmation | undefined, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Identity/confirm-reset-password";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigConfirmResetPassword,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigConfirmResetPassword?.headers,
            "Content-Type": "application/json",
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processConfirmResetPassword(_response);
    });
}

function processConfirmResetPassword(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function resetPassword(body?: Types.ResetPassword | undefined, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Identity/reset-password";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigResetPassword,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigResetPassword?.headers,
            "Content-Type": "application/json",
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processResetPassword(_response);
    });
}

function processResetPassword(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function updateUser(body?: Types.UpdateUserDto | undefined, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Identity/update-user";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigUpdateUser,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            ..._requestConfigUpdateUser?.headers,
            "Content-Type": "application/json",
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processUpdateUser(_response);
    });
}

function processUpdateUser(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @return OK
 */
export function deactivateAccount(config?: AxiosRequestConfig | undefined): Promise<boolean> {
    let url_ = getBaseUrl() + "/api/Identity/deactivate-account";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigDeactivateAccount,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
            ..._requestConfigDeactivateAccount?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processDeactivateAccount(_response);
    });
}

function processDeactivateAccount(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<boolean>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}

/**
 * @return OK
 */
export function supportedCountries(config?: AxiosRequestConfig | undefined): Promise<Types.CountryDto[]> {
    let url_ = getBaseUrl() + "/api/Identity/supported-countries";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigSupportedCountries,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigSupportedCountries?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processSupportedCountries(_response);
    });
}

function processSupportedCountries(response: AxiosResponse): Promise<Types.CountryDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.CountryDto.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.CountryDto[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.CountryDto[]>(null as any);
}

/**
 * @return OK
 */
export function roles(config?: AxiosRequestConfig | undefined): Promise<Types.RoleDto[]> {
    let url_ = getBaseUrl() + "/api/Identity/roles";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigRoles,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigRoles?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processRoles(_response);
    });
}

function processRoles(response: AxiosResponse): Promise<Types.RoleDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.RoleDto.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.RoleDto[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.RoleDto[]>(null as any);
}

/**
 * @return OK
 */
export function layoutDefinitionsAll(config?: AxiosRequestConfig | undefined): Promise<Types.LayoutDefinitionDto[]> {
    let url_ = getBaseUrl() + "/api/layout/LayoutDefinitions";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigLayoutDefinitionsAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigLayoutDefinitionsAll?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processLayoutDefinitionsAll(_response);
    });
}

function processLayoutDefinitionsAll(response: AxiosResponse): Promise<Types.LayoutDefinitionDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.LayoutDefinitionDto.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.LayoutDefinitionDto[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.LayoutDefinitionDto[]>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function layoutDefinitionsPOST(body?: Types.LayoutDefinitionDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.LayoutDefinitionDto> {
    let url_ = getBaseUrl() + "/api/layout/LayoutDefinitions";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigLayoutDefinitionsPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigLayoutDefinitionsPOST?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processLayoutDefinitionsPOST(_response);
    });
}

function processLayoutDefinitionsPOST(response: AxiosResponse): Promise<Types.LayoutDefinitionDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.LayoutDefinitionDto.fromJS(resultData200);
        return Promise.resolve<Types.LayoutDefinitionDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.LayoutDefinitionDto>(null as any);
}

/**
 * @return OK
 */
export function layoutDefinitionsGET(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.LayoutDefinitionDto> {
    let url_ = getBaseUrl() + "/api/layout/LayoutDefinitions/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigLayoutDefinitionsGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigLayoutDefinitionsGET?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processLayoutDefinitionsGET(_response);
    });
}

function processLayoutDefinitionsGET(response: AxiosResponse): Promise<Types.LayoutDefinitionDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.LayoutDefinitionDto.fromJS(resultData200);
        return Promise.resolve<Types.LayoutDefinitionDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.LayoutDefinitionDto>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function layoutDefinitionsPUT(id: string, body?: Types.LayoutDefinitionDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.LayoutDefinitionDto> {
    let url_ = getBaseUrl() + "/api/layout/LayoutDefinitions/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigLayoutDefinitionsPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            ..._requestConfigLayoutDefinitionsPUT?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processLayoutDefinitionsPUT(_response);
    });
}

function processLayoutDefinitionsPUT(response: AxiosResponse): Promise<Types.LayoutDefinitionDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.LayoutDefinitionDto.fromJS(resultData200);
        return Promise.resolve<Types.LayoutDefinitionDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.LayoutDefinitionDto>(null as any);
}

/**
 * @return OK
 */
export function layoutDefinitionsDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<boolean> {
    let url_ = getBaseUrl() + "/api/layout/LayoutDefinitions/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigLayoutDefinitionsDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
            ..._requestConfigLayoutDefinitionsDELETE?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processLayoutDefinitionsDELETE(_response);
    });
}

function processLayoutDefinitionsDELETE(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<boolean>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}

/**
 * @return OK
 */
export function layoutParametersAll(config?: AxiosRequestConfig | undefined): Promise<Types.LayoutParameterDto[]> {
    let url_ = getBaseUrl() + "/api/layout/LayoutParameters";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigLayoutParametersAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigLayoutParametersAll?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processLayoutParametersAll(_response);
    });
}

function processLayoutParametersAll(response: AxiosResponse): Promise<Types.LayoutParameterDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.LayoutParameterDto.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.LayoutParameterDto[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.LayoutParameterDto[]>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function layoutParametersPOST(body?: Types.LayoutParameterDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.LayoutParameterDto> {
    let url_ = getBaseUrl() + "/api/layout/LayoutParameters";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigLayoutParametersPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigLayoutParametersPOST?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processLayoutParametersPOST(_response);
    });
}

function processLayoutParametersPOST(response: AxiosResponse): Promise<Types.LayoutParameterDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.LayoutParameterDto.fromJS(resultData200);
        return Promise.resolve<Types.LayoutParameterDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.LayoutParameterDto>(null as any);
}

/**
 * @return OK
 */
export function layoutParametersGET(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.LayoutParameterDto> {
    let url_ = getBaseUrl() + "/api/layout/LayoutParameters/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigLayoutParametersGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigLayoutParametersGET?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processLayoutParametersGET(_response);
    });
}

function processLayoutParametersGET(response: AxiosResponse): Promise<Types.LayoutParameterDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.LayoutParameterDto.fromJS(resultData200);
        return Promise.resolve<Types.LayoutParameterDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.LayoutParameterDto>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function layoutParametersPUT(id: string, body?: Types.LayoutParameterDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.LayoutParameterDto> {
    let url_ = getBaseUrl() + "/api/layout/LayoutParameters/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigLayoutParametersPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            ..._requestConfigLayoutParametersPUT?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processLayoutParametersPUT(_response);
    });
}

function processLayoutParametersPUT(response: AxiosResponse): Promise<Types.LayoutParameterDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.LayoutParameterDto.fromJS(resultData200);
        return Promise.resolve<Types.LayoutParameterDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.LayoutParameterDto>(null as any);
}

/**
 * @return OK
 */
export function layoutParametersDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<boolean> {
    let url_ = getBaseUrl() + "/api/layout/LayoutParameters/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigLayoutParametersDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
            ..._requestConfigLayoutParametersDELETE?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processLayoutParametersDELETE(_response);
    });
}

function processLayoutParametersDELETE(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<boolean>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}

/**
 * @return OK
 */
export function menusAll(config?: AxiosRequestConfig | undefined): Promise<Types.MenuDto[]> {
    let url_ = getBaseUrl() + "/api/layout/Menus";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigMenusAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigMenusAll?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processMenusAll(_response);
    });
}

function processMenusAll(response: AxiosResponse): Promise<Types.MenuDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.MenuDto.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.MenuDto[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.MenuDto[]>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function menusPOST(body?: Types.MenuDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.MenuDto> {
    let url_ = getBaseUrl() + "/api/layout/Menus";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigMenusPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigMenusPOST?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processMenusPOST(_response);
    });
}

function processMenusPOST(response: AxiosResponse): Promise<Types.MenuDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.MenuDto.fromJS(resultData200);
        return Promise.resolve<Types.MenuDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.MenuDto>(null as any);
}

/**
 * @return OK
 */
export function menusGET(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.MenuDto> {
    let url_ = getBaseUrl() + "/api/layout/Menus/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigMenusGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigMenusGET?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processMenusGET(_response);
    });
}

function processMenusGET(response: AxiosResponse): Promise<Types.MenuDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.MenuDto.fromJS(resultData200);
        return Promise.resolve<Types.MenuDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.MenuDto>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function menusPUT(id: string, body?: Types.MenuDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.MenuDto> {
    let url_ = getBaseUrl() + "/api/layout/Menus/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigMenusPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            ..._requestConfigMenusPUT?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processMenusPUT(_response);
    });
}

function processMenusPUT(response: AxiosResponse): Promise<Types.MenuDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.MenuDto.fromJS(resultData200);
        return Promise.resolve<Types.MenuDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.MenuDto>(null as any);
}

/**
 * @return OK
 */
export function menusDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<boolean> {
    let url_ = getBaseUrl() + "/api/layout/Menus/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigMenusDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
            ..._requestConfigMenusDELETE?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processMenusDELETE(_response);
    });
}

function processMenusDELETE(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<boolean>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}

/**
 * @return OK
 */
export function moduleButtonsAll(config?: AxiosRequestConfig | undefined): Promise<Types.ModuleButtonsDto[]> {
    let url_ = getBaseUrl() + "/api/layout/ModuleButtons";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigModuleButtonsAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigModuleButtonsAll?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processModuleButtonsAll(_response);
    });
}

function processModuleButtonsAll(response: AxiosResponse): Promise<Types.ModuleButtonsDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.ModuleButtonsDto.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.ModuleButtonsDto[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ModuleButtonsDto[]>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function moduleButtonsPOST(body?: Types.ModuleButtonsDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.ModuleButtonsDto> {
    let url_ = getBaseUrl() + "/api/layout/ModuleButtons";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigModuleButtonsPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigModuleButtonsPOST?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processModuleButtonsPOST(_response);
    });
}

function processModuleButtonsPOST(response: AxiosResponse): Promise<Types.ModuleButtonsDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ModuleButtonsDto.fromJS(resultData200);
        return Promise.resolve<Types.ModuleButtonsDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ModuleButtonsDto>(null as any);
}

/**
 * @return OK
 */
export function moduleButtonsGET(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.ModuleButtonsDto> {
    let url_ = getBaseUrl() + "/api/layout/ModuleButtons/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigModuleButtonsGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigModuleButtonsGET?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processModuleButtonsGET(_response);
    });
}

function processModuleButtonsGET(response: AxiosResponse): Promise<Types.ModuleButtonsDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ModuleButtonsDto.fromJS(resultData200);
        return Promise.resolve<Types.ModuleButtonsDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ModuleButtonsDto>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function moduleButtonsPUT(id: string, body?: Types.ModuleButtonsDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.ModuleButtonsDto> {
    let url_ = getBaseUrl() + "/api/layout/ModuleButtons/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigModuleButtonsPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            ..._requestConfigModuleButtonsPUT?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processModuleButtonsPUT(_response);
    });
}

function processModuleButtonsPUT(response: AxiosResponse): Promise<Types.ModuleButtonsDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ModuleButtonsDto.fromJS(resultData200);
        return Promise.resolve<Types.ModuleButtonsDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ModuleButtonsDto>(null as any);
}

/**
 * @return OK
 */
export function moduleButtonsDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<boolean> {
    let url_ = getBaseUrl() + "/api/layout/ModuleButtons/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigModuleButtonsDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
            ..._requestConfigModuleButtonsDELETE?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processModuleButtonsDELETE(_response);
    });
}

function processModuleButtonsDELETE(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<boolean>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}

/**
 * @return OK
 */
export function modulesAll(config?: AxiosRequestConfig | undefined): Promise<Types.ModuleDto[]> {
    let url_ = getBaseUrl() + "/api/layout/Modules";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigModulesAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigModulesAll?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processModulesAll(_response);
    });
}

function processModulesAll(response: AxiosResponse): Promise<Types.ModuleDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.ModuleDto.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.ModuleDto[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ModuleDto[]>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function modulesPOST(body?: Types.ModuleDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.ModuleDto> {
    let url_ = getBaseUrl() + "/api/layout/Modules";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigModulesPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigModulesPOST?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processModulesPOST(_response);
    });
}

function processModulesPOST(response: AxiosResponse): Promise<Types.ModuleDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ModuleDto.fromJS(resultData200);
        return Promise.resolve<Types.ModuleDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ModuleDto>(null as any);
}

/**
 * @return OK
 */
export function modulesGET(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.ModuleDto> {
    let url_ = getBaseUrl() + "/api/layout/Modules/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigModulesGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigModulesGET?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processModulesGET(_response);
    });
}

function processModulesGET(response: AxiosResponse): Promise<Types.ModuleDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ModuleDto.fromJS(resultData200);
        return Promise.resolve<Types.ModuleDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ModuleDto>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function modulesPUT(id: string, body?: Types.ModuleDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.ModuleDto> {
    let url_ = getBaseUrl() + "/api/layout/Modules/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigModulesPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            ..._requestConfigModulesPUT?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processModulesPUT(_response);
    });
}

function processModulesPUT(response: AxiosResponse): Promise<Types.ModuleDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ModuleDto.fromJS(resultData200);
        return Promise.resolve<Types.ModuleDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ModuleDto>(null as any);
}

/**
 * @return OK
 */
export function modulesDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.BooleanActionResult> {
    let url_ = getBaseUrl() + "/api/layout/Modules/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigModulesDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
            ..._requestConfigModulesDELETE?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processModulesDELETE(_response);
    });
}

function processModulesDELETE(response: AxiosResponse): Promise<Types.BooleanActionResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.BooleanActionResult.fromJS(resultData200);
        return Promise.resolve<Types.BooleanActionResult>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.BooleanActionResult>(null as any);
}

/**
 * @return OK
 */
export function overridesAll(config?: AxiosRequestConfig | undefined): Promise<Types.OverrideDto[]> {
    let url_ = getBaseUrl() + "/api/layout/Overrides";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigOverridesAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigOverridesAll?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processOverridesAll(_response);
    });
}

function processOverridesAll(response: AxiosResponse): Promise<Types.OverrideDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.OverrideDto.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.OverrideDto[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.OverrideDto[]>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function overridesPOST(body?: Types.OverrideDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.OverrideDtoActionResult> {
    let url_ = getBaseUrl() + "/api/layout/Overrides";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigOverridesPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigOverridesPOST?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processOverridesPOST(_response);
    });
}

function processOverridesPOST(response: AxiosResponse): Promise<Types.OverrideDtoActionResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.OverrideDtoActionResult.fromJS(resultData200);
        return Promise.resolve<Types.OverrideDtoActionResult>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.OverrideDtoActionResult>(null as any);
}

/**
 * @return OK
 */
export function overridesGET(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.OverrideDto> {
    let url_ = getBaseUrl() + "/api/layout/Overrides/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigOverridesGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigOverridesGET?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processOverridesGET(_response);
    });
}

function processOverridesGET(response: AxiosResponse): Promise<Types.OverrideDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.OverrideDto.fromJS(resultData200);
        return Promise.resolve<Types.OverrideDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.OverrideDto>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function overridesPUT(id: string, body?: Types.OverrideDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.OverrideDto> {
    let url_ = getBaseUrl() + "/api/layout/Overrides/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigOverridesPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            ..._requestConfigOverridesPUT?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processOverridesPUT(_response);
    });
}

function processOverridesPUT(response: AxiosResponse): Promise<Types.OverrideDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.OverrideDto.fromJS(resultData200);
        return Promise.resolve<Types.OverrideDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.OverrideDto>(null as any);
}

/**
 * @return OK
 */
export function overridesDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<boolean> {
    let url_ = getBaseUrl() + "/api/layout/Overrides/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigOverridesDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
            ..._requestConfigOverridesDELETE?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processOverridesDELETE(_response);
    });
}

function processOverridesDELETE(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<boolean>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function paymentGateway(body?: Types.PaymentGatewayDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.PaymentGatewayDto> {
    let url_ = getBaseUrl() + "/api/PaymentGateway";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigPaymentGateway,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigPaymentGateway?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processPaymentGateway(_response);
    });
}

function processPaymentGateway(response: AxiosResponse): Promise<Types.PaymentGatewayDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.PaymentGatewayDto.fromJS(resultData200);
        return Promise.resolve<Types.PaymentGatewayDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.PaymentGatewayDto>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function generateLink(paymentGatewayId: string, body?: Types.PaymentRequestsDto | undefined, config?: AxiosRequestConfig | undefined): Promise<string> {
    let url_ = getBaseUrl() + "/api/PaymentGateway/{paymentGatewayId}/generate-link";
    if (paymentGatewayId === undefined || paymentGatewayId === null)
      throw new Error("The parameter 'paymentGatewayId' must be defined.");
    url_ = url_.replace("{paymentGatewayId}", encodeURIComponent("" + paymentGatewayId));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigGenerateLink,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigGenerateLink?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processGenerateLink(_response);
    });
}

function processGenerateLink(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<string>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function paymentCheckout(paymentGatewayId: string, body?: Types.PaymentRequestsDto | undefined, config?: AxiosRequestConfig | undefined): Promise<string> {
    let url_ = getBaseUrl() + "/api/PaymentGateway/{paymentGatewayId}/payment-checkout";
    if (paymentGatewayId === undefined || paymentGatewayId === null)
      throw new Error("The parameter 'paymentGatewayId' must be defined.");
    url_ = url_.replace("{paymentGatewayId}", encodeURIComponent("" + paymentGatewayId));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigPaymentCheckout,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigPaymentCheckout?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processPaymentCheckout(_response);
    });
}

function processPaymentCheckout(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<string>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string>(null as any);
}



/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function routesGET(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.RouteDtoQueryResponse> {
    let url_ = getBaseUrl() + "/api/Routes?";
    if (pageNumber === null)
        throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
        url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize === null)
        throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
        url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (totalCount === null)
        throw new Error("The parameter 'totalCount' cannot be null.");
    else if (totalCount !== undefined)
        url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&";
    if (sort_SortBy === null)
        throw new Error("The parameter 'sort_SortBy' cannot be null.");
    else if (sort_SortBy !== undefined)
        url_ += "Sort.SortBy=" + encodeURIComponent("" + sort_SortBy) + "&";
    if (sort_Ascending === null)
        throw new Error("The parameter 'sort_Ascending' cannot be null.");
    else if (sort_Ascending !== undefined)
        url_ += "Sort.Ascending=" + encodeURIComponent("" + sort_Ascending) + "&";
    if (filter_Logic === null)
        throw new Error("The parameter 'filter_Logic' cannot be null.");
    else if (filter_Logic !== undefined)
        url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&";
    if (filter_Conditions === null)
        throw new Error("The parameter 'filter_Conditions' cannot be null.");
    else if (filter_Conditions !== undefined)
        filter_Conditions && filter_Conditions.forEach((item, index) => {
            for (let attr in item)
    			if (item.hasOwnProperty(attr)) {
    				url_ += "Filter.Conditions[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
    			}
        });
    if (filter_Groups === null)
        throw new Error("The parameter 'filter_Groups' cannot be null.");
    else if (filter_Groups !== undefined)
        filter_Groups && filter_Groups.forEach((item, index) => {
            for (let attr in item)
    			if (item.hasOwnProperty(attr)) {
    				url_ += "Filter.Groups[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
    			}
        });
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigRoutesGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigRoutesGET?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processRoutesGET(_response);
    });
}

function processRoutesGET(response: AxiosResponse): Promise<Types.RouteDtoQueryResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.RouteDtoQueryResponse.fromJS(resultData200);
        return Promise.resolve<Types.RouteDtoQueryResponse>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.RouteDtoQueryResponse>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function routesPOST(body?: Types.RouteDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.RouteDto> {
    let url_ = getBaseUrl() + "/api/Routes";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigRoutesPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigRoutesPOST?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processRoutesPOST(_response);
    });
}

function processRoutesPOST(response: AxiosResponse): Promise<Types.RouteDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.RouteDto.fromJS(resultData200);
        return Promise.resolve<Types.RouteDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.RouteDto>(null as any);
}

/**
 * @return OK
 */
export function routesGET2(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.RouteDto> {
    let url_ = getBaseUrl() + "/api/Routes/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigRoutesGET2,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigRoutesGET2?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processRoutesGET2(_response);
    });
}

function processRoutesGET2(response: AxiosResponse): Promise<Types.RouteDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.RouteDto.fromJS(resultData200);
        return Promise.resolve<Types.RouteDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.RouteDto>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function routesPUT(id: string, body?: Types.RouteDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.RouteDto> {
    let url_ = getBaseUrl() + "/api/Routes/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigRoutesPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            ..._requestConfigRoutesPUT?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processRoutesPUT(_response);
    });
}

function processRoutesPUT(response: AxiosResponse): Promise<Types.RouteDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.RouteDto.fromJS(resultData200);
        return Promise.resolve<Types.RouteDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.RouteDto>(null as any);
}

/**
 * @return OK
 */
export function routesDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<boolean> {
    let url_ = getBaseUrl() + "/api/Routes/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigRoutesDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
            ..._requestConfigRoutesDELETE?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processRoutesDELETE(_response);
    });
}

function processRoutesDELETE(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<boolean>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}

/**
 * @return OK
 */
export function startRoute(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.RouteDto> {
    let url_ = getBaseUrl() + "/api/Routes/start-route/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigStartRoute,
        ...config,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigStartRoute?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processStartRoute(_response);
    });
}

function processStartRoute(response: AxiosResponse): Promise<Types.RouteDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.RouteDto.fromJS(resultData200);
        return Promise.resolve<Types.RouteDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.RouteDto>(null as any);
}

/**
 * @return OK
 */
export function finishRoute(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.RouteDto> {
    let url_ = getBaseUrl() + "/api/Routes/finish-route/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigFinishRoute,
        ...config,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigFinishRoute?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processFinishRoute(_response);
    });
}

function processFinishRoute(response: AxiosResponse): Promise<Types.RouteDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.RouteDto.fromJS(resultData200);
        return Promise.resolve<Types.RouteDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.RouteDto>(null as any);
}

/**
 * @return OK
 */
export function searchExpsAll(config?: AxiosRequestConfig | undefined): Promise<Types.SearchExpDto[]> {
    let url_ = getBaseUrl() + "/api/layout/SearchExps";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigSearchExpsAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigSearchExpsAll?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processSearchExpsAll(_response);
    });
}

function processSearchExpsAll(response: AxiosResponse): Promise<Types.SearchExpDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.SearchExpDto.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.SearchExpDto[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.SearchExpDto[]>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function searchExpsPOST(body?: Types.SearchExpDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.SearchExpDto> {
    let url_ = getBaseUrl() + "/api/layout/SearchExps";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigSearchExpsPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigSearchExpsPOST?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processSearchExpsPOST(_response);
    });
}

function processSearchExpsPOST(response: AxiosResponse): Promise<Types.SearchExpDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.SearchExpDto.fromJS(resultData200);
        return Promise.resolve<Types.SearchExpDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.SearchExpDto>(null as any);
}

/**
 * @return OK
 */
export function searchExpsGET(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.SearchExpDto> {
    let url_ = getBaseUrl() + "/api/layout/SearchExps/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigSearchExpsGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigSearchExpsGET?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processSearchExpsGET(_response);
    });
}

function processSearchExpsGET(response: AxiosResponse): Promise<Types.SearchExpDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.SearchExpDto.fromJS(resultData200);
        return Promise.resolve<Types.SearchExpDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.SearchExpDto>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function searchExpsPUT(id: string, body?: Types.SearchExpDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.SearchExpDto> {
    let url_ = getBaseUrl() + "/api/layout/SearchExps/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigSearchExpsPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            ..._requestConfigSearchExpsPUT?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processSearchExpsPUT(_response);
    });
}

function processSearchExpsPUT(response: AxiosResponse): Promise<Types.SearchExpDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.SearchExpDto.fromJS(resultData200);
        return Promise.resolve<Types.SearchExpDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.SearchExpDto>(null as any);
}

/**
 * @return OK
 */
export function searchExpsDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<boolean> {
    let url_ = getBaseUrl() + "/api/layout/SearchExps/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigSearchExpsDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
            ..._requestConfigSearchExpsDELETE?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processSearchExpsDELETE(_response);
    });
}

function processSearchExpsDELETE(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<boolean>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}

/**
 * @return OK
 */
export function sectionsAll(config?: AxiosRequestConfig | undefined): Promise<Types.SectionDto[]> {
    let url_ = getBaseUrl() + "/api/layout/Sections";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigSectionsAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigSectionsAll?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processSectionsAll(_response);
    });
}

function processSectionsAll(response: AxiosResponse): Promise<Types.SectionDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.SectionDto.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.SectionDto[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.SectionDto[]>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function sectionsPOST(body?: Types.SectionDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.SectionDto> {
    let url_ = getBaseUrl() + "/api/layout/Sections";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigSectionsPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigSectionsPOST?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processSectionsPOST(_response);
    });
}

function processSectionsPOST(response: AxiosResponse): Promise<Types.SectionDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.SectionDto.fromJS(resultData200);
        return Promise.resolve<Types.SectionDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.SectionDto>(null as any);
}

/**
 * @return OK
 */
export function sectionsGET(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.SectionDto> {
    let url_ = getBaseUrl() + "/api/layout/Sections/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigSectionsGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigSectionsGET?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processSectionsGET(_response);
    });
}

function processSectionsGET(response: AxiosResponse): Promise<Types.SectionDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.SectionDto.fromJS(resultData200);
        return Promise.resolve<Types.SectionDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.SectionDto>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function sectionsPUT(id: string, body?: Types.SectionDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.SectionDto> {
    let url_ = getBaseUrl() + "/api/layout/Sections/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigSectionsPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            ..._requestConfigSectionsPUT?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processSectionsPUT(_response);
    });
}

function processSectionsPUT(response: AxiosResponse): Promise<Types.SectionDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.SectionDto.fromJS(resultData200);
        return Promise.resolve<Types.SectionDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.SectionDto>(null as any);
}

/**
 * @return OK
 */
export function sectionsDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<boolean> {
    let url_ = getBaseUrl() + "/api/layout/Sections/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigSectionsDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
            ..._requestConfigSectionsDELETE?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processSectionsDELETE(_response);
    });
}

function processSectionsDELETE(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<boolean>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}

/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function seriesGET(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.SeriesDtoQueryResponse> {
    let url_ = getBaseUrl() + "/api/Series?";
    if (pageNumber === null)
        throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
        url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize === null)
        throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
        url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (totalCount === null)
        throw new Error("The parameter 'totalCount' cannot be null.");
    else if (totalCount !== undefined)
        url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&";
    if (sort_SortBy === null)
        throw new Error("The parameter 'sort_SortBy' cannot be null.");
    else if (sort_SortBy !== undefined)
        url_ += "Sort.SortBy=" + encodeURIComponent("" + sort_SortBy) + "&";
    if (sort_Ascending === null)
        throw new Error("The parameter 'sort_Ascending' cannot be null.");
    else if (sort_Ascending !== undefined)
        url_ += "Sort.Ascending=" + encodeURIComponent("" + sort_Ascending) + "&";
    if (filter_Logic === null)
        throw new Error("The parameter 'filter_Logic' cannot be null.");
    else if (filter_Logic !== undefined)
        url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&";
    if (filter_Conditions === null)
        throw new Error("The parameter 'filter_Conditions' cannot be null.");
    else if (filter_Conditions !== undefined)
        filter_Conditions && filter_Conditions.forEach((item, index) => {
            for (let attr in item)
    			if (item.hasOwnProperty(attr)) {
    				url_ += "Filter.Conditions[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
    			}
        });
    if (filter_Groups === null)
        throw new Error("The parameter 'filter_Groups' cannot be null.");
    else if (filter_Groups !== undefined)
        filter_Groups && filter_Groups.forEach((item, index) => {
            for (let attr in item)
    			if (item.hasOwnProperty(attr)) {
    				url_ += "Filter.Groups[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
    			}
        });
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigSeriesGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigSeriesGET?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processSeriesGET(_response);
    });
}

function processSeriesGET(response: AxiosResponse): Promise<Types.SeriesDtoQueryResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.SeriesDtoQueryResponse.fromJS(resultData200);
        return Promise.resolve<Types.SeriesDtoQueryResponse>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.SeriesDtoQueryResponse>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function seriesPOST(body?: Types.SeriesDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.SeriesDto> {
    let url_ = getBaseUrl() + "/api/Series";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigSeriesPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigSeriesPOST?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processSeriesPOST(_response);
    });
}

function processSeriesPOST(response: AxiosResponse): Promise<Types.SeriesDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.SeriesDto.fromJS(resultData200);
        return Promise.resolve<Types.SeriesDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.SeriesDto>(null as any);
}

/**
 * @return OK
 */
export function seriesGET2(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.SeriesDto> {
    let url_ = getBaseUrl() + "/api/Series/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigSeriesGET2,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigSeriesGET2?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processSeriesGET2(_response);
    });
}

function processSeriesGET2(response: AxiosResponse): Promise<Types.SeriesDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.SeriesDto.fromJS(resultData200);
        return Promise.resolve<Types.SeriesDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.SeriesDto>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function seriesPATCH(id: string, body?: Types.SeriesDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.SeriesDto> {
    let url_ = getBaseUrl() + "/api/Series/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigSeriesPATCH,
        ...config,
        data: content_,
        method: "PATCH",
        url: url_,
        headers: {
            ..._requestConfigSeriesPATCH?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processSeriesPATCH(_response);
    });
}

function processSeriesPATCH(response: AxiosResponse): Promise<Types.SeriesDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.SeriesDto.fromJS(resultData200);
        return Promise.resolve<Types.SeriesDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.SeriesDto>(null as any);
}

/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function storageSystemGET(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.StorageSystemDtoQueryResponse> {
    let url_ = getBaseUrl() + "/api/StorageSystem?";
    if (pageNumber === null)
        throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
        url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize === null)
        throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
        url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (totalCount === null)
        throw new Error("The parameter 'totalCount' cannot be null.");
    else if (totalCount !== undefined)
        url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&";
    if (sort_SortBy === null)
        throw new Error("The parameter 'sort_SortBy' cannot be null.");
    else if (sort_SortBy !== undefined)
        url_ += "Sort.SortBy=" + encodeURIComponent("" + sort_SortBy) + "&";
    if (sort_Ascending === null)
        throw new Error("The parameter 'sort_Ascending' cannot be null.");
    else if (sort_Ascending !== undefined)
        url_ += "Sort.Ascending=" + encodeURIComponent("" + sort_Ascending) + "&";
    if (filter_Logic === null)
        throw new Error("The parameter 'filter_Logic' cannot be null.");
    else if (filter_Logic !== undefined)
        url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&";
    if (filter_Conditions === null)
        throw new Error("The parameter 'filter_Conditions' cannot be null.");
    else if (filter_Conditions !== undefined)
        filter_Conditions && filter_Conditions.forEach((item, index) => {
            for (let attr in item)
    			if (item.hasOwnProperty(attr)) {
    				url_ += "Filter.Conditions[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
    			}
        });
    if (filter_Groups === null)
        throw new Error("The parameter 'filter_Groups' cannot be null.");
    else if (filter_Groups !== undefined)
        filter_Groups && filter_Groups.forEach((item, index) => {
            for (let attr in item)
    			if (item.hasOwnProperty(attr)) {
    				url_ += "Filter.Groups[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
    			}
        });
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigStorageSystemGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigStorageSystemGET?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processStorageSystemGET(_response);
    });
}

function processStorageSystemGET(response: AxiosResponse): Promise<Types.StorageSystemDtoQueryResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.StorageSystemDtoQueryResponse.fromJS(resultData200);
        return Promise.resolve<Types.StorageSystemDtoQueryResponse>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.StorageSystemDtoQueryResponse>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function storageSystemPOST(body?: Types.StorageSystemDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.StorageSystemDto> {
    let url_ = getBaseUrl() + "/api/StorageSystem";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigStorageSystemPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigStorageSystemPOST?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processStorageSystemPOST(_response);
    });
}

function processStorageSystemPOST(response: AxiosResponse): Promise<Types.StorageSystemDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.StorageSystemDto.fromJS(resultData200);
        return Promise.resolve<Types.StorageSystemDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.StorageSystemDto>(null as any);
}

/**
 * @return OK
 */
export function storageSystemGET2(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.StorageSystemDto> {
    let url_ = getBaseUrl() + "/api/StorageSystem/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigStorageSystemGET2,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigStorageSystemGET2?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processStorageSystemGET2(_response);
    });
}

function processStorageSystemGET2(response: AxiosResponse): Promise<Types.StorageSystemDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.StorageSystemDto.fromJS(resultData200);
        return Promise.resolve<Types.StorageSystemDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.StorageSystemDto>(null as any);
}

/**
 * @return OK
 */
export function storageSystemDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<boolean> {
    let url_ = getBaseUrl() + "/api/StorageSystem/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigStorageSystemDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
            ..._requestConfigStorageSystemDELETE?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processStorageSystemDELETE(_response);
    });
}

function processStorageSystemDELETE(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<boolean>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}

/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function vehiclesGET(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.VehicleDtoQueryResponse> {
    let url_ = getBaseUrl() + "/api/Vehicles?";
    if (pageNumber === null)
        throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
        url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize === null)
        throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
        url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (totalCount === null)
        throw new Error("The parameter 'totalCount' cannot be null.");
    else if (totalCount !== undefined)
        url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&";
    if (sort_SortBy === null)
        throw new Error("The parameter 'sort_SortBy' cannot be null.");
    else if (sort_SortBy !== undefined)
        url_ += "Sort.SortBy=" + encodeURIComponent("" + sort_SortBy) + "&";
    if (sort_Ascending === null)
        throw new Error("The parameter 'sort_Ascending' cannot be null.");
    else if (sort_Ascending !== undefined)
        url_ += "Sort.Ascending=" + encodeURIComponent("" + sort_Ascending) + "&";
    if (filter_Logic === null)
        throw new Error("The parameter 'filter_Logic' cannot be null.");
    else if (filter_Logic !== undefined)
        url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&";
    if (filter_Conditions === null)
        throw new Error("The parameter 'filter_Conditions' cannot be null.");
    else if (filter_Conditions !== undefined)
        filter_Conditions && filter_Conditions.forEach((item, index) => {
            for (let attr in item)
    			if (item.hasOwnProperty(attr)) {
    				url_ += "Filter.Conditions[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
    			}
        });
    if (filter_Groups === null)
        throw new Error("The parameter 'filter_Groups' cannot be null.");
    else if (filter_Groups !== undefined)
        filter_Groups && filter_Groups.forEach((item, index) => {
            for (let attr in item)
    			if (item.hasOwnProperty(attr)) {
    				url_ += "Filter.Groups[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
    			}
        });
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigVehiclesGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigVehiclesGET?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processVehiclesGET(_response);
    });
}

function processVehiclesGET(response: AxiosResponse): Promise<Types.VehicleDtoQueryResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.VehicleDtoQueryResponse.fromJS(resultData200);
        return Promise.resolve<Types.VehicleDtoQueryResponse>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.VehicleDtoQueryResponse>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function vehiclesPOST(body?: Types.VehicleDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.VehicleDto> {
    let url_ = getBaseUrl() + "/api/Vehicles";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigVehiclesPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigVehiclesPOST?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processVehiclesPOST(_response);
    });
}

function processVehiclesPOST(response: AxiosResponse): Promise<Types.VehicleDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.VehicleDto.fromJS(resultData200);
        return Promise.resolve<Types.VehicleDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.VehicleDto>(null as any);
}

/**
 * @return OK
 */
export function vehiclesGET2(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.VehicleDto> {
    let url_ = getBaseUrl() + "/api/Vehicles/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigVehiclesGET2,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigVehiclesGET2?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processVehiclesGET2(_response);
    });
}

function processVehiclesGET2(response: AxiosResponse): Promise<Types.VehicleDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.VehicleDto.fromJS(resultData200);
        return Promise.resolve<Types.VehicleDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.VehicleDto>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function vehiclesPUT(id: string, body?: Types.VehicleDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.VehicleDto> {
    let url_ = getBaseUrl() + "/api/Vehicles/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigVehiclesPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            ..._requestConfigVehiclesPUT?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processVehiclesPUT(_response);
    });
}

function processVehiclesPUT(response: AxiosResponse): Promise<Types.VehicleDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.VehicleDto.fromJS(resultData200);
        return Promise.resolve<Types.VehicleDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.VehicleDto>(null as any);
}

/**
 * @return OK
 */
export function vehiclesDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<boolean> {
    let url_ = getBaseUrl() + "/api/Vehicles/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigVehiclesDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
            ..._requestConfigVehiclesDELETE?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processVehiclesDELETE(_response);
    });
}

function processVehiclesDELETE(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<boolean>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}

/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function warehousesGET(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.WarehouseDtoQueryResponse> {
    let url_ = getBaseUrl() + "/api/Warehouses?";
    if (pageNumber === null)
        throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
        url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
    if (pageSize === null)
        throw new Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined)
        url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
    if (totalCount === null)
        throw new Error("The parameter 'totalCount' cannot be null.");
    else if (totalCount !== undefined)
        url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&";
    if (sort_SortBy === null)
        throw new Error("The parameter 'sort_SortBy' cannot be null.");
    else if (sort_SortBy !== undefined)
        url_ += "Sort.SortBy=" + encodeURIComponent("" + sort_SortBy) + "&";
    if (sort_Ascending === null)
        throw new Error("The parameter 'sort_Ascending' cannot be null.");
    else if (sort_Ascending !== undefined)
        url_ += "Sort.Ascending=" + encodeURIComponent("" + sort_Ascending) + "&";
    if (filter_Logic === null)
        throw new Error("The parameter 'filter_Logic' cannot be null.");
    else if (filter_Logic !== undefined)
        url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&";
    if (filter_Conditions === null)
        throw new Error("The parameter 'filter_Conditions' cannot be null.");
    else if (filter_Conditions !== undefined)
        filter_Conditions && filter_Conditions.forEach((item, index) => {
            for (let attr in item)
    			if (item.hasOwnProperty(attr)) {
    				url_ += "Filter.Conditions[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
    			}
        });
    if (filter_Groups === null)
        throw new Error("The parameter 'filter_Groups' cannot be null.");
    else if (filter_Groups !== undefined)
        filter_Groups && filter_Groups.forEach((item, index) => {
            for (let attr in item)
    			if (item.hasOwnProperty(attr)) {
    				url_ += "Filter.Groups[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
    			}
        });
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigWarehousesGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigWarehousesGET?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processWarehousesGET(_response);
    });
}

function processWarehousesGET(response: AxiosResponse): Promise<Types.WarehouseDtoQueryResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.WarehouseDtoQueryResponse.fromJS(resultData200);
        return Promise.resolve<Types.WarehouseDtoQueryResponse>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.WarehouseDtoQueryResponse>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function warehousesPOST(body?: Types.WarehouseDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.WarehouseDto> {
    let url_ = getBaseUrl() + "/api/Warehouses";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigWarehousesPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigWarehousesPOST?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processWarehousesPOST(_response);
    });
}

function processWarehousesPOST(response: AxiosResponse): Promise<Types.WarehouseDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.WarehouseDto.fromJS(resultData200);
        return Promise.resolve<Types.WarehouseDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.WarehouseDto>(null as any);
}

/**
 * @return OK
 */
export function warehousesGET2(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.WarehouseDto> {
    let url_ = getBaseUrl() + "/api/Warehouses/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigWarehousesGET2,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigWarehousesGET2?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processWarehousesGET2(_response);
    });
}

function processWarehousesGET2(response: AxiosResponse): Promise<Types.WarehouseDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.WarehouseDto.fromJS(resultData200);
        return Promise.resolve<Types.WarehouseDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.WarehouseDto>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function warehousesPATCH(id: string, body?: Types.WarehouseDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.WarehouseDto> {
    let url_ = getBaseUrl() + "/api/Warehouses/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigWarehousesPATCH,
        ...config,
        data: content_,
        method: "PATCH",
        url: url_,
        headers: {
            ..._requestConfigWarehousesPATCH?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processWarehousesPATCH(_response);
    });
}

function processWarehousesPATCH(response: AxiosResponse): Promise<Types.WarehouseDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.WarehouseDto.fromJS(resultData200);
        return Promise.resolve<Types.WarehouseDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.WarehouseDto>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function warehousesPUT(id: string, body?: Types.WarehouseDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.WarehouseDto> {
    let url_ = getBaseUrl() + "/api/Warehouses/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigWarehousesPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            ..._requestConfigWarehousesPUT?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processWarehousesPUT(_response);
    });
}

function processWarehousesPUT(response: AxiosResponse): Promise<Types.WarehouseDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.WarehouseDto.fromJS(resultData200);
        return Promise.resolve<Types.WarehouseDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.WarehouseDto>(null as any);
}

/**
 * @return OK
 */
export function warehousesDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<boolean> {
    let url_ = getBaseUrl() + "/api/Warehouses/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigWarehousesDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
            ..._requestConfigWarehousesDELETE?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processWarehousesDELETE(_response);
    });
}

function processWarehousesDELETE(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<boolean>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}

/**
 * @return OK
 */
export function widgetsAll(config?: AxiosRequestConfig | undefined): Promise<Types.WidgetDto[]> {
    let url_ = getBaseUrl() + "/api/layout/Widgets";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigWidgetsAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigWidgetsAll?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processWidgetsAll(_response);
    });
}

function processWidgetsAll(response: AxiosResponse): Promise<Types.WidgetDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.WidgetDto.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.WidgetDto[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.WidgetDto[]>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function widgetsPOST(body?: Types.WidgetDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.WidgetDto> {
    let url_ = getBaseUrl() + "/api/layout/Widgets";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigWidgetsPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigWidgetsPOST?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processWidgetsPOST(_response);
    });
}

function processWidgetsPOST(response: AxiosResponse): Promise<Types.WidgetDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.WidgetDto.fromJS(resultData200);
        return Promise.resolve<Types.WidgetDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.WidgetDto>(null as any);
}

/**
 * @return OK
 */
export function widgetsGET(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.WidgetDto> {
    let url_ = getBaseUrl() + "/api/layout/Widgets/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigWidgetsGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigWidgetsGET?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processWidgetsGET(_response);
    });
}

function processWidgetsGET(response: AxiosResponse): Promise<Types.WidgetDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.WidgetDto.fromJS(resultData200);
        return Promise.resolve<Types.WidgetDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.WidgetDto>(null as any);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function widgetsPUT(id: string, body?: Types.WidgetDto | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.WidgetDto> {
    let url_ = getBaseUrl() + "/api/layout/Widgets/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigWidgetsPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            ..._requestConfigWidgetsPUT?.headers,
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processWidgetsPUT(_response);
    });
}

function processWidgetsPUT(response: AxiosResponse): Promise<Types.WidgetDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.WidgetDto.fromJS(resultData200);
        return Promise.resolve<Types.WidgetDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.WidgetDto>(null as any);
}

/**
 * @return OK
 */
export function widgetsDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<boolean> {
    let url_ = getBaseUrl() + "/api/layout/Widgets/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigWidgetsDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
            ..._requestConfigWidgetsDELETE?.headers,
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processWidgetsDELETE(_response);
    });
}

function processWidgetsDELETE(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<boolean>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}
let _requestConfigActionsAll: Partial<AxiosRequestConfig> | null;
export function getActionsAllRequestConfig() {
  return _requestConfigActionsAll;
}
export function setActionsAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigActionsAll = value;
}
export function patchActionsAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigActionsAll = patch(_requestConfigActionsAll ?? {});
}

let _requestConfigActionsPOST: Partial<AxiosRequestConfig> | null;
export function getActionsPOSTRequestConfig() {
  return _requestConfigActionsPOST;
}
export function setActionsPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigActionsPOST = value;
}
export function patchActionsPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigActionsPOST = patch(_requestConfigActionsPOST ?? {});
}

let _requestConfigActionsGET: Partial<AxiosRequestConfig> | null;
export function getActionsGETRequestConfig() {
  return _requestConfigActionsGET;
}
export function setActionsGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigActionsGET = value;
}
export function patchActionsGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigActionsGET = patch(_requestConfigActionsGET ?? {});
}

let _requestConfigActionsPUT: Partial<AxiosRequestConfig> | null;
export function getActionsPUTRequestConfig() {
  return _requestConfigActionsPUT;
}
export function setActionsPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigActionsPUT = value;
}
export function patchActionsPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigActionsPUT = patch(_requestConfigActionsPUT ?? {});
}

let _requestConfigActionsDELETE: Partial<AxiosRequestConfig> | null;
export function getActionsDELETERequestConfig() {
  return _requestConfigActionsDELETE;
}
export function setActionsDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigActionsDELETE = value;
}
export function patchActionsDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigActionsDELETE = patch(_requestConfigActionsDELETE ?? {});
}

let _requestConfigApiKeysAll: Partial<AxiosRequestConfig> | null;
export function getApiKeysAllRequestConfig() {
  return _requestConfigApiKeysAll;
}
export function setApiKeysAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigApiKeysAll = value;
}
export function patchApiKeysAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigApiKeysAll = patch(_requestConfigApiKeysAll ?? {});
}

let _requestConfigApiKeysPOST: Partial<AxiosRequestConfig> | null;
export function getApiKeysPOSTRequestConfig() {
  return _requestConfigApiKeysPOST;
}
export function setApiKeysPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigApiKeysPOST = value;
}
export function patchApiKeysPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigApiKeysPOST = patch(_requestConfigApiKeysPOST ?? {});
}

let _requestConfigApiKeysGET: Partial<AxiosRequestConfig> | null;
export function getApiKeysGETRequestConfig() {
  return _requestConfigApiKeysGET;
}
export function setApiKeysGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigApiKeysGET = value;
}
export function patchApiKeysGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigApiKeysGET = patch(_requestConfigApiKeysGET ?? {});
}

let _requestConfigApiKeysPUT: Partial<AxiosRequestConfig> | null;
export function getApiKeysPUTRequestConfig() {
  return _requestConfigApiKeysPUT;
}
export function setApiKeysPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigApiKeysPUT = value;
}
export function patchApiKeysPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigApiKeysPUT = patch(_requestConfigApiKeysPUT ?? {});
}

let _requestConfigApiKeysDELETE: Partial<AxiosRequestConfig> | null;
export function getApiKeysDELETERequestConfig() {
  return _requestConfigApiKeysDELETE;
}
export function setApiKeysDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigApiKeysDELETE = value;
}
export function patchApiKeysDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigApiKeysDELETE = patch(_requestConfigApiKeysDELETE ?? {});
}

let _requestConfigAppsAll: Partial<AxiosRequestConfig> | null;
export function getAppsAllRequestConfig() {
  return _requestConfigAppsAll;
}
export function setAppsAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigAppsAll = value;
}
export function patchAppsAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigAppsAll = patch(_requestConfigAppsAll ?? {});
}

let _requestConfigAppsPOST: Partial<AxiosRequestConfig> | null;
export function getAppsPOSTRequestConfig() {
  return _requestConfigAppsPOST;
}
export function setAppsPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigAppsPOST = value;
}
export function patchAppsPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigAppsPOST = patch(_requestConfigAppsPOST ?? {});
}

let _requestConfigAppsGET: Partial<AxiosRequestConfig> | null;
export function getAppsGETRequestConfig() {
  return _requestConfigAppsGET;
}
export function setAppsGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigAppsGET = value;
}
export function patchAppsGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigAppsGET = patch(_requestConfigAppsGET ?? {});
}

let _requestConfigAppsPUT: Partial<AxiosRequestConfig> | null;
export function getAppsPUTRequestConfig() {
  return _requestConfigAppsPUT;
}
export function setAppsPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigAppsPUT = value;
}
export function patchAppsPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigAppsPUT = patch(_requestConfigAppsPUT ?? {});
}

let _requestConfigAppsDELETE: Partial<AxiosRequestConfig> | null;
export function getAppsDELETERequestConfig() {
  return _requestConfigAppsDELETE;
}
export function setAppsDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigAppsDELETE = value;
}
export function patchAppsDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigAppsDELETE = patch(_requestConfigAppsDELETE ?? {});
}

let _requestConfigAssets: Partial<AxiosRequestConfig> | null;
export function getAssetsRequestConfig() {
  return _requestConfigAssets;
}
export function setAssetsRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigAssets = value;
}
export function patchAssetsRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigAssets = patch(_requestConfigAssets ?? {});
}

let _requestConfigAssets2: Partial<AxiosRequestConfig> | null;
export function getAssets2RequestConfig() {
  return _requestConfigAssets2;
}
export function setAssets2RequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigAssets2 = value;
}
export function patchAssets2RequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigAssets2 = patch(_requestConfigAssets2 ?? {});
}

let _requestConfigAuthorizationProfilesGET: Partial<AxiosRequestConfig> | null;
export function getAuthorizationProfilesGETRequestConfig() {
  return _requestConfigAuthorizationProfilesGET;
}
export function setAuthorizationProfilesGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigAuthorizationProfilesGET = value;
}
export function patchAuthorizationProfilesGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigAuthorizationProfilesGET = patch(_requestConfigAuthorizationProfilesGET ?? {});
}

let _requestConfigAuthorizationProfilesPOST: Partial<AxiosRequestConfig> | null;
export function getAuthorizationProfilesPOSTRequestConfig() {
  return _requestConfigAuthorizationProfilesPOST;
}
export function setAuthorizationProfilesPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigAuthorizationProfilesPOST = value;
}
export function patchAuthorizationProfilesPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigAuthorizationProfilesPOST = patch(_requestConfigAuthorizationProfilesPOST ?? {});
}

let _requestConfigAuthorizationProfilesGET2: Partial<AxiosRequestConfig> | null;
export function getAuthorizationProfilesGET2RequestConfig() {
  return _requestConfigAuthorizationProfilesGET2;
}
export function setAuthorizationProfilesGET2RequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigAuthorizationProfilesGET2 = value;
}
export function patchAuthorizationProfilesGET2RequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigAuthorizationProfilesGET2 = patch(_requestConfigAuthorizationProfilesGET2 ?? {});
}

let _requestConfigCompaniesGET: Partial<AxiosRequestConfig> | null;
export function getCompaniesGETRequestConfig() {
  return _requestConfigCompaniesGET;
}
export function setCompaniesGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigCompaniesGET = value;
}
export function patchCompaniesGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigCompaniesGET = patch(_requestConfigCompaniesGET ?? {});
}

let _requestConfigCompaniesPOST: Partial<AxiosRequestConfig> | null;
export function getCompaniesPOSTRequestConfig() {
  return _requestConfigCompaniesPOST;
}
export function setCompaniesPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigCompaniesPOST = value;
}
export function patchCompaniesPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigCompaniesPOST = patch(_requestConfigCompaniesPOST ?? {});
}

let _requestConfigCompaniesGET2: Partial<AxiosRequestConfig> | null;
export function getCompaniesGET2RequestConfig() {
  return _requestConfigCompaniesGET2;
}
export function setCompaniesGET2RequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigCompaniesGET2 = value;
}
export function patchCompaniesGET2RequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigCompaniesGET2 = patch(_requestConfigCompaniesGET2 ?? {});
}

let _requestConfigCompaniesPUT: Partial<AxiosRequestConfig> | null;
export function getCompaniesPUTRequestConfig() {
  return _requestConfigCompaniesPUT;
}
export function setCompaniesPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigCompaniesPUT = value;
}
export function patchCompaniesPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigCompaniesPUT = patch(_requestConfigCompaniesPUT ?? {});
}

let _requestConfigCompaniesDELETE: Partial<AxiosRequestConfig> | null;
export function getCompaniesDELETERequestConfig() {
  return _requestConfigCompaniesDELETE;
}
export function setCompaniesDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigCompaniesDELETE = value;
}
export function patchCompaniesDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigCompaniesDELETE = patch(_requestConfigCompaniesDELETE ?? {});
}

let _requestConfigCreateContact: Partial<AxiosRequestConfig> | null;
export function getCreateContactRequestConfig() {
  return _requestConfigCreateContact;
}
export function setCreateContactRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigCreateContact = value;
}
export function patchCreateContactRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigCreateContact = patch(_requestConfigCreateContact ?? {});
}

let _requestConfigInviteUser: Partial<AxiosRequestConfig> | null;
export function getInviteUserRequestConfig() {
  return _requestConfigInviteUser;
}
export function setInviteUserRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigInviteUser = value;
}
export function patchInviteUserRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigInviteUser = patch(_requestConfigInviteUser ?? {});
}

let _requestConfigConfigurationGET: Partial<AxiosRequestConfig> | null;
export function getConfigurationGETRequestConfig() {
  return _requestConfigConfigurationGET;
}
export function setConfigurationGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigConfigurationGET = value;
}
export function patchConfigurationGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigConfigurationGET = patch(_requestConfigConfigurationGET ?? {});
}

let _requestConfigConfigurationPOST: Partial<AxiosRequestConfig> | null;
export function getConfigurationPOSTRequestConfig() {
  return _requestConfigConfigurationPOST;
}
export function setConfigurationPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigConfigurationPOST = value;
}
export function patchConfigurationPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigConfigurationPOST = patch(_requestConfigConfigurationPOST ?? {});
}

let _requestConfigConfigurationGET2: Partial<AxiosRequestConfig> | null;
export function getConfigurationGET2RequestConfig() {
  return _requestConfigConfigurationGET2;
}
export function setConfigurationGET2RequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigConfigurationGET2 = value;
}
export function patchConfigurationGET2RequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigConfigurationGET2 = patch(_requestConfigConfigurationGET2 ?? {});
}

let _requestConfigConfigurationPATCH: Partial<AxiosRequestConfig> | null;
export function getConfigurationPATCHRequestConfig() {
  return _requestConfigConfigurationPATCH;
}
export function setConfigurationPATCHRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigConfigurationPATCH = value;
}
export function patchConfigurationPATCHRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigConfigurationPATCH = patch(_requestConfigConfigurationPATCH ?? {});
}

let _requestConfigConfigurationPUT: Partial<AxiosRequestConfig> | null;
export function getConfigurationPUTRequestConfig() {
  return _requestConfigConfigurationPUT;
}
export function setConfigurationPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigConfigurationPUT = value;
}
export function patchConfigurationPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigConfigurationPUT = patch(_requestConfigConfigurationPUT ?? {});
}

let _requestConfigConfigurationDELETE: Partial<AxiosRequestConfig> | null;
export function getConfigurationDELETERequestConfig() {
  return _requestConfigConfigurationDELETE;
}
export function setConfigurationDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigConfigurationDELETE = value;
}
export function patchConfigurationDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigConfigurationDELETE = patch(_requestConfigConfigurationDELETE ?? {});
}

let _requestConfigConsignmentsGET: Partial<AxiosRequestConfig> | null;
export function getConsignmentsGETRequestConfig() {
  return _requestConfigConsignmentsGET;
}
export function setConsignmentsGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigConsignmentsGET = value;
}
export function patchConsignmentsGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigConsignmentsGET = patch(_requestConfigConsignmentsGET ?? {});
}

let _requestConfigConsignmentsPOST: Partial<AxiosRequestConfig> | null;
export function getConsignmentsPOSTRequestConfig() {
  return _requestConfigConsignmentsPOST;
}
export function setConsignmentsPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigConsignmentsPOST = value;
}
export function patchConsignmentsPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigConsignmentsPOST = patch(_requestConfigConsignmentsPOST ?? {});
}

let _requestConfigConsignmentsGET2: Partial<AxiosRequestConfig> | null;
export function getConsignmentsGET2RequestConfig() {
  return _requestConfigConsignmentsGET2;
}
export function setConsignmentsGET2RequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigConsignmentsGET2 = value;
}
export function patchConsignmentsGET2RequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigConsignmentsGET2 = patch(_requestConfigConsignmentsGET2 ?? {});
}

let _requestConfigConsignmentsPUT: Partial<AxiosRequestConfig> | null;
export function getConsignmentsPUTRequestConfig() {
  return _requestConfigConsignmentsPUT;
}
export function setConsignmentsPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigConsignmentsPUT = value;
}
export function patchConsignmentsPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigConsignmentsPUT = patch(_requestConfigConsignmentsPUT ?? {});
}

let _requestConfigConsignmentsDELETE: Partial<AxiosRequestConfig> | null;
export function getConsignmentsDELETERequestConfig() {
  return _requestConfigConsignmentsDELETE;
}
export function setConsignmentsDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigConsignmentsDELETE = value;
}
export function patchConsignmentsDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigConsignmentsDELETE = patch(_requestConfigConsignmentsDELETE ?? {});
}

let _requestConfigValidateAddress: Partial<AxiosRequestConfig> | null;
export function getValidateAddressRequestConfig() {
  return _requestConfigValidateAddress;
}
export function setValidateAddressRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigValidateAddress = value;
}
export function patchValidateAddressRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigValidateAddress = patch(_requestConfigValidateAddress ?? {});
}

let _requestConfigUpdateStatus: Partial<AxiosRequestConfig> | null;
export function getUpdateStatusRequestConfig() {
  return _requestConfigUpdateStatus;
}
export function setUpdateStatusRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigUpdateStatus = value;
}
export function patchUpdateStatusRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigUpdateStatus = patch(_requestConfigUpdateStatus ?? {});
}

let _requestConfigUploadPod: Partial<AxiosRequestConfig> | null;
export function getUploadPodRequestConfig() {
  return _requestConfigUploadPod;
}
export function setUploadPodRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigUploadPod = value;
}
export function patchUploadPodRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigUploadPod = patch(_requestConfigUploadPod ?? {});
}

let _requestConfigDownloadPod: Partial<AxiosRequestConfig> | null;
export function getDownloadPodRequestConfig() {
  return _requestConfigDownloadPod;
}
export function setDownloadPodRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigDownloadPod = value;
}
export function patchDownloadPodRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigDownloadPod = patch(_requestConfigDownloadPod ?? {});
}

let _requestConfigDeletePod: Partial<AxiosRequestConfig> | null;
export function getDeletePodRequestConfig() {
  return _requestConfigDeletePod;
}
export function setDeletePodRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigDeletePod = value;
}
export function patchDeletePodRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigDeletePod = patch(_requestConfigDeletePod ?? {});
}

let _requestConfigDashboardsAll: Partial<AxiosRequestConfig> | null;
export function getDashboardsAllRequestConfig() {
  return _requestConfigDashboardsAll;
}
export function setDashboardsAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigDashboardsAll = value;
}
export function patchDashboardsAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigDashboardsAll = patch(_requestConfigDashboardsAll ?? {});
}

let _requestConfigDashboardsPOST: Partial<AxiosRequestConfig> | null;
export function getDashboardsPOSTRequestConfig() {
  return _requestConfigDashboardsPOST;
}
export function setDashboardsPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigDashboardsPOST = value;
}
export function patchDashboardsPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigDashboardsPOST = patch(_requestConfigDashboardsPOST ?? {});
}

let _requestConfigDashboardsGET: Partial<AxiosRequestConfig> | null;
export function getDashboardsGETRequestConfig() {
  return _requestConfigDashboardsGET;
}
export function setDashboardsGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigDashboardsGET = value;
}
export function patchDashboardsGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigDashboardsGET = patch(_requestConfigDashboardsGET ?? {});
}

let _requestConfigDashboardsPUT: Partial<AxiosRequestConfig> | null;
export function getDashboardsPUTRequestConfig() {
  return _requestConfigDashboardsPUT;
}
export function setDashboardsPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigDashboardsPUT = value;
}
export function patchDashboardsPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigDashboardsPUT = patch(_requestConfigDashboardsPUT ?? {});
}

let _requestConfigDashboardsDELETE: Partial<AxiosRequestConfig> | null;
export function getDashboardsDELETERequestConfig() {
  return _requestConfigDashboardsDELETE;
}
export function setDashboardsDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigDashboardsDELETE = value;
}
export function patchDashboardsDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigDashboardsDELETE = patch(_requestConfigDashboardsDELETE ?? {});
}

let _requestConfigDataSourcesAll: Partial<AxiosRequestConfig> | null;
export function getDataSourcesAllRequestConfig() {
  return _requestConfigDataSourcesAll;
}
export function setDataSourcesAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigDataSourcesAll = value;
}
export function patchDataSourcesAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigDataSourcesAll = patch(_requestConfigDataSourcesAll ?? {});
}

let _requestConfigDataSourcesPOST: Partial<AxiosRequestConfig> | null;
export function getDataSourcesPOSTRequestConfig() {
  return _requestConfigDataSourcesPOST;
}
export function setDataSourcesPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigDataSourcesPOST = value;
}
export function patchDataSourcesPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigDataSourcesPOST = patch(_requestConfigDataSourcesPOST ?? {});
}

let _requestConfigDataSourcesGET: Partial<AxiosRequestConfig> | null;
export function getDataSourcesGETRequestConfig() {
  return _requestConfigDataSourcesGET;
}
export function setDataSourcesGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigDataSourcesGET = value;
}
export function patchDataSourcesGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigDataSourcesGET = patch(_requestConfigDataSourcesGET ?? {});
}

let _requestConfigDataSourcesPUT: Partial<AxiosRequestConfig> | null;
export function getDataSourcesPUTRequestConfig() {
  return _requestConfigDataSourcesPUT;
}
export function setDataSourcesPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigDataSourcesPUT = value;
}
export function patchDataSourcesPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigDataSourcesPUT = patch(_requestConfigDataSourcesPUT ?? {});
}

let _requestConfigDataSourcesDELETE: Partial<AxiosRequestConfig> | null;
export function getDataSourcesDELETERequestConfig() {
  return _requestConfigDataSourcesDELETE;
}
export function setDataSourcesDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigDataSourcesDELETE = value;
}
export function patchDataSourcesDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigDataSourcesDELETE = patch(_requestConfigDataSourcesDELETE ?? {});
}

let _requestConfigDrivers: Partial<AxiosRequestConfig> | null;
export function getDriversRequestConfig() {
  return _requestConfigDrivers;
}
export function setDriversRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigDrivers = value;
}
export function patchDriversRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigDrivers = patch(_requestConfigDrivers ?? {});
}

let _requestConfigDrivers2: Partial<AxiosRequestConfig> | null;
export function getDrivers2RequestConfig() {
  return _requestConfigDrivers2;
}
export function setDrivers2RequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigDrivers2 = value;
}
export function patchDrivers2RequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigDrivers2 = patch(_requestConfigDrivers2 ?? {});
}

let _requestConfigRecordHistory: Partial<AxiosRequestConfig> | null;
export function getRecordHistoryRequestConfig() {
  return _requestConfigRecordHistory;
}
export function setRecordHistoryRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigRecordHistory = value;
}
export function patchRecordHistoryRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigRecordHistory = patch(_requestConfigRecordHistory ?? {});
}

let _requestConfigGetHistory: Partial<AxiosRequestConfig> | null;
export function getGetHistoryRequestConfig() {
  return _requestConfigGetHistory;
}
export function setGetHistoryRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigGetHistory = value;
}
export function patchGetHistoryRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigGetHistory = patch(_requestConfigGetHistory ?? {});
}

let _requestConfigEmployeesGET: Partial<AxiosRequestConfig> | null;
export function getEmployeesGETRequestConfig() {
  return _requestConfigEmployeesGET;
}
export function setEmployeesGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigEmployeesGET = value;
}
export function patchEmployeesGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigEmployeesGET = patch(_requestConfigEmployeesGET ?? {});
}

let _requestConfigEmployeesGET2: Partial<AxiosRequestConfig> | null;
export function getEmployeesGET2RequestConfig() {
  return _requestConfigEmployeesGET2;
}
export function setEmployeesGET2RequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigEmployeesGET2 = value;
}
export function patchEmployeesGET2RequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigEmployeesGET2 = patch(_requestConfigEmployeesGET2 ?? {});
}

let _requestConfigEmployeesPUT: Partial<AxiosRequestConfig> | null;
export function getEmployeesPUTRequestConfig() {
  return _requestConfigEmployeesPUT;
}
export function setEmployeesPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigEmployeesPUT = value;
}
export function patchEmployeesPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigEmployeesPUT = patch(_requestConfigEmployeesPUT ?? {});
}

let _requestConfigDeactivateEmployee: Partial<AxiosRequestConfig> | null;
export function getDeactivateEmployeeRequestConfig() {
  return _requestConfigDeactivateEmployee;
}
export function setDeactivateEmployeeRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigDeactivateEmployee = value;
}
export function patchDeactivateEmployeeRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigDeactivateEmployee = patch(_requestConfigDeactivateEmployee ?? {});
}

let _requestConfigReactivateEmployee: Partial<AxiosRequestConfig> | null;
export function getReactivateEmployeeRequestConfig() {
  return _requestConfigReactivateEmployee;
}
export function setReactivateEmployeeRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigReactivateEmployee = value;
}
export function patchReactivateEmployeeRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigReactivateEmployee = patch(_requestConfigReactivateEmployee ?? {});
}

let _requestConfigDeletedEmployees: Partial<AxiosRequestConfig> | null;
export function getDeletedEmployeesRequestConfig() {
  return _requestConfigDeletedEmployees;
}
export function setDeletedEmployeesRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigDeletedEmployees = value;
}
export function patchDeletedEmployeesRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigDeletedEmployees = patch(_requestConfigDeletedEmployees ?? {});
}

let _requestConfigFailureReasonsGET: Partial<AxiosRequestConfig> | null;
export function getFailureReasonsGETRequestConfig() {
  return _requestConfigFailureReasonsGET;
}
export function setFailureReasonsGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigFailureReasonsGET = value;
}
export function patchFailureReasonsGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigFailureReasonsGET = patch(_requestConfigFailureReasonsGET ?? {});
}

let _requestConfigFailureReasonsPOST: Partial<AxiosRequestConfig> | null;
export function getFailureReasonsPOSTRequestConfig() {
  return _requestConfigFailureReasonsPOST;
}
export function setFailureReasonsPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigFailureReasonsPOST = value;
}
export function patchFailureReasonsPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigFailureReasonsPOST = patch(_requestConfigFailureReasonsPOST ?? {});
}

let _requestConfigFailureReasonsGET2: Partial<AxiosRequestConfig> | null;
export function getFailureReasonsGET2RequestConfig() {
  return _requestConfigFailureReasonsGET2;
}
export function setFailureReasonsGET2RequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigFailureReasonsGET2 = value;
}
export function patchFailureReasonsGET2RequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigFailureReasonsGET2 = patch(_requestConfigFailureReasonsGET2 ?? {});
}

let _requestConfigFailureReasonsPUT: Partial<AxiosRequestConfig> | null;
export function getFailureReasonsPUTRequestConfig() {
  return _requestConfigFailureReasonsPUT;
}
export function setFailureReasonsPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigFailureReasonsPUT = value;
}
export function patchFailureReasonsPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigFailureReasonsPUT = patch(_requestConfigFailureReasonsPUT ?? {});
}

let _requestConfigFailureReasonsDELETE: Partial<AxiosRequestConfig> | null;
export function getFailureReasonsDELETERequestConfig() {
  return _requestConfigFailureReasonsDELETE;
}
export function setFailureReasonsDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigFailureReasonsDELETE = value;
}
export function patchFailureReasonsDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigFailureReasonsDELETE = patch(_requestConfigFailureReasonsDELETE ?? {});
}

let _requestConfigFieldsAll: Partial<AxiosRequestConfig> | null;
export function getFieldsAllRequestConfig() {
  return _requestConfigFieldsAll;
}
export function setFieldsAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigFieldsAll = value;
}
export function patchFieldsAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigFieldsAll = patch(_requestConfigFieldsAll ?? {});
}

let _requestConfigFieldsPOST: Partial<AxiosRequestConfig> | null;
export function getFieldsPOSTRequestConfig() {
  return _requestConfigFieldsPOST;
}
export function setFieldsPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigFieldsPOST = value;
}
export function patchFieldsPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigFieldsPOST = patch(_requestConfigFieldsPOST ?? {});
}

let _requestConfigFieldsGET: Partial<AxiosRequestConfig> | null;
export function getFieldsGETRequestConfig() {
  return _requestConfigFieldsGET;
}
export function setFieldsGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigFieldsGET = value;
}
export function patchFieldsGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigFieldsGET = patch(_requestConfigFieldsGET ?? {});
}

let _requestConfigFieldsPUT: Partial<AxiosRequestConfig> | null;
export function getFieldsPUTRequestConfig() {
  return _requestConfigFieldsPUT;
}
export function setFieldsPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigFieldsPUT = value;
}
export function patchFieldsPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigFieldsPUT = patch(_requestConfigFieldsPUT ?? {});
}

let _requestConfigFieldsDELETE: Partial<AxiosRequestConfig> | null;
export function getFieldsDELETERequestConfig() {
  return _requestConfigFieldsDELETE;
}
export function setFieldsDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigFieldsDELETE = value;
}
export function patchFieldsDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigFieldsDELETE = patch(_requestConfigFieldsDELETE ?? {});
}

let _requestConfigFullRegistration: Partial<AxiosRequestConfig> | null;
export function getFullRegistrationRequestConfig() {
  return _requestConfigFullRegistration;
}
export function setFullRegistrationRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigFullRegistration = value;
}
export function patchFullRegistrationRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigFullRegistration = patch(_requestConfigFullRegistration ?? {});
}

let _requestConfigRegisterOrg: Partial<AxiosRequestConfig> | null;
export function getRegisterOrgRequestConfig() {
  return _requestConfigRegisterOrg;
}
export function setRegisterOrgRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigRegisterOrg = value;
}
export function patchRegisterOrgRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigRegisterOrg = patch(_requestConfigRegisterOrg ?? {});
}

let _requestConfigInviteEmployee: Partial<AxiosRequestConfig> | null;
export function getInviteEmployeeRequestConfig() {
  return _requestConfigInviteEmployee;
}
export function setInviteEmployeeRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigInviteEmployee = value;
}
export function patchInviteEmployeeRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigInviteEmployee = patch(_requestConfigInviteEmployee ?? {});
}

let _requestConfigRegisterUser: Partial<AxiosRequestConfig> | null;
export function getRegisterUserRequestConfig() {
  return _requestConfigRegisterUser;
}
export function setRegisterUserRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigRegisterUser = value;
}
export function patchRegisterUserRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigRegisterUser = patch(_requestConfigRegisterUser ?? {});
}

let _requestConfigLogin: Partial<AxiosRequestConfig> | null;
export function getLoginRequestConfig() {
  return _requestConfigLogin;
}
export function setLoginRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigLogin = value;
}
export function patchLoginRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigLogin = patch(_requestConfigLogin ?? {});
}

let _requestConfigUserOrganizations: Partial<AxiosRequestConfig> | null;
export function getUserOrganizationsRequestConfig() {
  return _requestConfigUserOrganizations;
}
export function setUserOrganizationsRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigUserOrganizations = value;
}
export function patchUserOrganizationsRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigUserOrganizations = patch(_requestConfigUserOrganizations ?? {});
}

let _requestConfigOrgLogin: Partial<AxiosRequestConfig> | null;
export function getOrgLoginRequestConfig() {
  return _requestConfigOrgLogin;
}
export function setOrgLoginRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigOrgLogin = value;
}
export function patchOrgLoginRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigOrgLogin = patch(_requestConfigOrgLogin ?? {});
}

let _requestConfigRefreshToken: Partial<AxiosRequestConfig> | null;
export function getRefreshTokenRequestConfig() {
  return _requestConfigRefreshToken;
}
export function setRefreshTokenRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigRefreshToken = value;
}
export function patchRefreshTokenRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigRefreshToken = patch(_requestConfigRefreshToken ?? {});
}

let _requestConfigAssociateCompanies: Partial<AxiosRequestConfig> | null;
export function getAssociateCompaniesRequestConfig() {
  return _requestConfigAssociateCompanies;
}
export function setAssociateCompaniesRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigAssociateCompanies = value;
}
export function patchAssociateCompaniesRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigAssociateCompanies = patch(_requestConfigAssociateCompanies ?? {});
}

let _requestConfigAssociateLogin: Partial<AxiosRequestConfig> | null;
export function getAssociateLoginRequestConfig() {
  return _requestConfigAssociateLogin;
}
export function setAssociateLoginRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigAssociateLogin = value;
}
export function patchAssociateLoginRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigAssociateLogin = patch(_requestConfigAssociateLogin ?? {});
}

let _requestConfigCurrentUser: Partial<AxiosRequestConfig> | null;
export function getCurrentUserRequestConfig() {
  return _requestConfigCurrentUser;
}
export function setCurrentUserRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigCurrentUser = value;
}
export function patchCurrentUserRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigCurrentUser = patch(_requestConfigCurrentUser ?? {});
}

let _requestConfigOrganizationUsers: Partial<AxiosRequestConfig> | null;
export function getOrganizationUsersRequestConfig() {
  return _requestConfigOrganizationUsers;
}
export function setOrganizationUsersRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigOrganizationUsers = value;
}
export function patchOrganizationUsersRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigOrganizationUsers = patch(_requestConfigOrganizationUsers ?? {});
}

let _requestConfigLogout: Partial<AxiosRequestConfig> | null;
export function getLogoutRequestConfig() {
  return _requestConfigLogout;
}
export function setLogoutRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigLogout = value;
}
export function patchLogoutRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigLogout = patch(_requestConfigLogout ?? {});
}

let _requestConfigResetPasswordRequest: Partial<AxiosRequestConfig> | null;
export function getResetPasswordRequestRequestConfig() {
  return _requestConfigResetPasswordRequest;
}
export function setResetPasswordRequestRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigResetPasswordRequest = value;
}
export function patchResetPasswordRequestRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigResetPasswordRequest = patch(_requestConfigResetPasswordRequest ?? {});
}

let _requestConfigConfirmResetPassword: Partial<AxiosRequestConfig> | null;
export function getConfirmResetPasswordRequestConfig() {
  return _requestConfigConfirmResetPassword;
}
export function setConfirmResetPasswordRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigConfirmResetPassword = value;
}
export function patchConfirmResetPasswordRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigConfirmResetPassword = patch(_requestConfigConfirmResetPassword ?? {});
}

let _requestConfigResetPassword: Partial<AxiosRequestConfig> | null;
export function getResetPasswordRequestConfig() {
  return _requestConfigResetPassword;
}
export function setResetPasswordRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigResetPassword = value;
}
export function patchResetPasswordRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigResetPassword = patch(_requestConfigResetPassword ?? {});
}

let _requestConfigUpdateUser: Partial<AxiosRequestConfig> | null;
export function getUpdateUserRequestConfig() {
  return _requestConfigUpdateUser;
}
export function setUpdateUserRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigUpdateUser = value;
}
export function patchUpdateUserRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigUpdateUser = patch(_requestConfigUpdateUser ?? {});
}

let _requestConfigDeactivateAccount: Partial<AxiosRequestConfig> | null;
export function getDeactivateAccountRequestConfig() {
  return _requestConfigDeactivateAccount;
}
export function setDeactivateAccountRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigDeactivateAccount = value;
}
export function patchDeactivateAccountRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigDeactivateAccount = patch(_requestConfigDeactivateAccount ?? {});
}

let _requestConfigSupportedCountries: Partial<AxiosRequestConfig> | null;
export function getSupportedCountriesRequestConfig() {
  return _requestConfigSupportedCountries;
}
export function setSupportedCountriesRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigSupportedCountries = value;
}
export function patchSupportedCountriesRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigSupportedCountries = patch(_requestConfigSupportedCountries ?? {});
}

let _requestConfigRoles: Partial<AxiosRequestConfig> | null;
export function getRolesRequestConfig() {
  return _requestConfigRoles;
}
export function setRolesRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigRoles = value;
}
export function patchRolesRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigRoles = patch(_requestConfigRoles ?? {});
}

let _requestConfigLayoutDefinitionsAll: Partial<AxiosRequestConfig> | null;
export function getLayoutDefinitionsAllRequestConfig() {
  return _requestConfigLayoutDefinitionsAll;
}
export function setLayoutDefinitionsAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigLayoutDefinitionsAll = value;
}
export function patchLayoutDefinitionsAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigLayoutDefinitionsAll = patch(_requestConfigLayoutDefinitionsAll ?? {});
}

let _requestConfigLayoutDefinitionsPOST: Partial<AxiosRequestConfig> | null;
export function getLayoutDefinitionsPOSTRequestConfig() {
  return _requestConfigLayoutDefinitionsPOST;
}
export function setLayoutDefinitionsPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigLayoutDefinitionsPOST = value;
}
export function patchLayoutDefinitionsPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigLayoutDefinitionsPOST = patch(_requestConfigLayoutDefinitionsPOST ?? {});
}

let _requestConfigLayoutDefinitionsGET: Partial<AxiosRequestConfig> | null;
export function getLayoutDefinitionsGETRequestConfig() {
  return _requestConfigLayoutDefinitionsGET;
}
export function setLayoutDefinitionsGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigLayoutDefinitionsGET = value;
}
export function patchLayoutDefinitionsGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigLayoutDefinitionsGET = patch(_requestConfigLayoutDefinitionsGET ?? {});
}

let _requestConfigLayoutDefinitionsPUT: Partial<AxiosRequestConfig> | null;
export function getLayoutDefinitionsPUTRequestConfig() {
  return _requestConfigLayoutDefinitionsPUT;
}
export function setLayoutDefinitionsPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigLayoutDefinitionsPUT = value;
}
export function patchLayoutDefinitionsPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigLayoutDefinitionsPUT = patch(_requestConfigLayoutDefinitionsPUT ?? {});
}

let _requestConfigLayoutDefinitionsDELETE: Partial<AxiosRequestConfig> | null;
export function getLayoutDefinitionsDELETERequestConfig() {
  return _requestConfigLayoutDefinitionsDELETE;
}
export function setLayoutDefinitionsDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigLayoutDefinitionsDELETE = value;
}
export function patchLayoutDefinitionsDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigLayoutDefinitionsDELETE = patch(_requestConfigLayoutDefinitionsDELETE ?? {});
}

let _requestConfigLayoutParametersAll: Partial<AxiosRequestConfig> | null;
export function getLayoutParametersAllRequestConfig() {
  return _requestConfigLayoutParametersAll;
}
export function setLayoutParametersAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigLayoutParametersAll = value;
}
export function patchLayoutParametersAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigLayoutParametersAll = patch(_requestConfigLayoutParametersAll ?? {});
}

let _requestConfigLayoutParametersPOST: Partial<AxiosRequestConfig> | null;
export function getLayoutParametersPOSTRequestConfig() {
  return _requestConfigLayoutParametersPOST;
}
export function setLayoutParametersPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigLayoutParametersPOST = value;
}
export function patchLayoutParametersPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigLayoutParametersPOST = patch(_requestConfigLayoutParametersPOST ?? {});
}

let _requestConfigLayoutParametersGET: Partial<AxiosRequestConfig> | null;
export function getLayoutParametersGETRequestConfig() {
  return _requestConfigLayoutParametersGET;
}
export function setLayoutParametersGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigLayoutParametersGET = value;
}
export function patchLayoutParametersGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigLayoutParametersGET = patch(_requestConfigLayoutParametersGET ?? {});
}

let _requestConfigLayoutParametersPUT: Partial<AxiosRequestConfig> | null;
export function getLayoutParametersPUTRequestConfig() {
  return _requestConfigLayoutParametersPUT;
}
export function setLayoutParametersPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigLayoutParametersPUT = value;
}
export function patchLayoutParametersPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigLayoutParametersPUT = patch(_requestConfigLayoutParametersPUT ?? {});
}

let _requestConfigLayoutParametersDELETE: Partial<AxiosRequestConfig> | null;
export function getLayoutParametersDELETERequestConfig() {
  return _requestConfigLayoutParametersDELETE;
}
export function setLayoutParametersDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigLayoutParametersDELETE = value;
}
export function patchLayoutParametersDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigLayoutParametersDELETE = patch(_requestConfigLayoutParametersDELETE ?? {});
}

let _requestConfigMenusAll: Partial<AxiosRequestConfig> | null;
export function getMenusAllRequestConfig() {
  return _requestConfigMenusAll;
}
export function setMenusAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigMenusAll = value;
}
export function patchMenusAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigMenusAll = patch(_requestConfigMenusAll ?? {});
}

let _requestConfigMenusPOST: Partial<AxiosRequestConfig> | null;
export function getMenusPOSTRequestConfig() {
  return _requestConfigMenusPOST;
}
export function setMenusPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigMenusPOST = value;
}
export function patchMenusPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigMenusPOST = patch(_requestConfigMenusPOST ?? {});
}

let _requestConfigMenusGET: Partial<AxiosRequestConfig> | null;
export function getMenusGETRequestConfig() {
  return _requestConfigMenusGET;
}
export function setMenusGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigMenusGET = value;
}
export function patchMenusGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigMenusGET = patch(_requestConfigMenusGET ?? {});
}

let _requestConfigMenusPUT: Partial<AxiosRequestConfig> | null;
export function getMenusPUTRequestConfig() {
  return _requestConfigMenusPUT;
}
export function setMenusPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigMenusPUT = value;
}
export function patchMenusPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigMenusPUT = patch(_requestConfigMenusPUT ?? {});
}

let _requestConfigMenusDELETE: Partial<AxiosRequestConfig> | null;
export function getMenusDELETERequestConfig() {
  return _requestConfigMenusDELETE;
}
export function setMenusDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigMenusDELETE = value;
}
export function patchMenusDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigMenusDELETE = patch(_requestConfigMenusDELETE ?? {});
}

let _requestConfigModuleButtonsAll: Partial<AxiosRequestConfig> | null;
export function getModuleButtonsAllRequestConfig() {
  return _requestConfigModuleButtonsAll;
}
export function setModuleButtonsAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigModuleButtonsAll = value;
}
export function patchModuleButtonsAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigModuleButtonsAll = patch(_requestConfigModuleButtonsAll ?? {});
}

let _requestConfigModuleButtonsPOST: Partial<AxiosRequestConfig> | null;
export function getModuleButtonsPOSTRequestConfig() {
  return _requestConfigModuleButtonsPOST;
}
export function setModuleButtonsPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigModuleButtonsPOST = value;
}
export function patchModuleButtonsPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigModuleButtonsPOST = patch(_requestConfigModuleButtonsPOST ?? {});
}

let _requestConfigModuleButtonsGET: Partial<AxiosRequestConfig> | null;
export function getModuleButtonsGETRequestConfig() {
  return _requestConfigModuleButtonsGET;
}
export function setModuleButtonsGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigModuleButtonsGET = value;
}
export function patchModuleButtonsGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigModuleButtonsGET = patch(_requestConfigModuleButtonsGET ?? {});
}

let _requestConfigModuleButtonsPUT: Partial<AxiosRequestConfig> | null;
export function getModuleButtonsPUTRequestConfig() {
  return _requestConfigModuleButtonsPUT;
}
export function setModuleButtonsPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigModuleButtonsPUT = value;
}
export function patchModuleButtonsPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigModuleButtonsPUT = patch(_requestConfigModuleButtonsPUT ?? {});
}

let _requestConfigModuleButtonsDELETE: Partial<AxiosRequestConfig> | null;
export function getModuleButtonsDELETERequestConfig() {
  return _requestConfigModuleButtonsDELETE;
}
export function setModuleButtonsDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigModuleButtonsDELETE = value;
}
export function patchModuleButtonsDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigModuleButtonsDELETE = patch(_requestConfigModuleButtonsDELETE ?? {});
}

let _requestConfigModulesAll: Partial<AxiosRequestConfig> | null;
export function getModulesAllRequestConfig() {
  return _requestConfigModulesAll;
}
export function setModulesAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigModulesAll = value;
}
export function patchModulesAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigModulesAll = patch(_requestConfigModulesAll ?? {});
}

let _requestConfigModulesPOST: Partial<AxiosRequestConfig> | null;
export function getModulesPOSTRequestConfig() {
  return _requestConfigModulesPOST;
}
export function setModulesPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigModulesPOST = value;
}
export function patchModulesPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigModulesPOST = patch(_requestConfigModulesPOST ?? {});
}

let _requestConfigModulesGET: Partial<AxiosRequestConfig> | null;
export function getModulesGETRequestConfig() {
  return _requestConfigModulesGET;
}
export function setModulesGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigModulesGET = value;
}
export function patchModulesGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigModulesGET = patch(_requestConfigModulesGET ?? {});
}

let _requestConfigModulesPUT: Partial<AxiosRequestConfig> | null;
export function getModulesPUTRequestConfig() {
  return _requestConfigModulesPUT;
}
export function setModulesPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigModulesPUT = value;
}
export function patchModulesPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigModulesPUT = patch(_requestConfigModulesPUT ?? {});
}

let _requestConfigModulesDELETE: Partial<AxiosRequestConfig> | null;
export function getModulesDELETERequestConfig() {
  return _requestConfigModulesDELETE;
}
export function setModulesDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigModulesDELETE = value;
}
export function patchModulesDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigModulesDELETE = patch(_requestConfigModulesDELETE ?? {});
}

let _requestConfigOverridesAll: Partial<AxiosRequestConfig> | null;
export function getOverridesAllRequestConfig() {
  return _requestConfigOverridesAll;
}
export function setOverridesAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigOverridesAll = value;
}
export function patchOverridesAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigOverridesAll = patch(_requestConfigOverridesAll ?? {});
}

let _requestConfigOverridesPOST: Partial<AxiosRequestConfig> | null;
export function getOverridesPOSTRequestConfig() {
  return _requestConfigOverridesPOST;
}
export function setOverridesPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigOverridesPOST = value;
}
export function patchOverridesPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigOverridesPOST = patch(_requestConfigOverridesPOST ?? {});
}

let _requestConfigOverridesGET: Partial<AxiosRequestConfig> | null;
export function getOverridesGETRequestConfig() {
  return _requestConfigOverridesGET;
}
export function setOverridesGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigOverridesGET = value;
}
export function patchOverridesGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigOverridesGET = patch(_requestConfigOverridesGET ?? {});
}

let _requestConfigOverridesPUT: Partial<AxiosRequestConfig> | null;
export function getOverridesPUTRequestConfig() {
  return _requestConfigOverridesPUT;
}
export function setOverridesPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigOverridesPUT = value;
}
export function patchOverridesPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigOverridesPUT = patch(_requestConfigOverridesPUT ?? {});
}

let _requestConfigOverridesDELETE: Partial<AxiosRequestConfig> | null;
export function getOverridesDELETERequestConfig() {
  return _requestConfigOverridesDELETE;
}
export function setOverridesDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigOverridesDELETE = value;
}
export function patchOverridesDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigOverridesDELETE = patch(_requestConfigOverridesDELETE ?? {});
}

let _requestConfigPaymentGateway: Partial<AxiosRequestConfig> | null;
export function getPaymentGatewayRequestConfig() {
  return _requestConfigPaymentGateway;
}
export function setPaymentGatewayRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigPaymentGateway = value;
}
export function patchPaymentGatewayRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigPaymentGateway = patch(_requestConfigPaymentGateway ?? {});
}

let _requestConfigGenerateLink: Partial<AxiosRequestConfig> | null;
export function getGenerateLinkRequestConfig() {
  return _requestConfigGenerateLink;
}
export function setGenerateLinkRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigGenerateLink = value;
}
export function patchGenerateLinkRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigGenerateLink = patch(_requestConfigGenerateLink ?? {});
}

let _requestConfigPaymentCheckout: Partial<AxiosRequestConfig> | null;
export function getPaymentCheckoutRequestConfig() {
  return _requestConfigPaymentCheckout;
}
export function setPaymentCheckoutRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigPaymentCheckout = value;
}
export function patchPaymentCheckoutRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigPaymentCheckout = patch(_requestConfigPaymentCheckout ?? {});
}

 
let _requestConfigPaymentTransactions: Partial<AxiosRequestConfig> | null;
export function getPaymentTransactionsRequestConfig() {
  return _requestConfigPaymentTransactions;
}
export function setPaymentTransactionsRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigPaymentTransactions = value;
}
export function patchPaymentTransactionsRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigPaymentTransactions = patch(_requestConfigPaymentTransactions ?? {});
}

let _requestConfigRoutesGET: Partial<AxiosRequestConfig> | null;
export function getRoutesGETRequestConfig() {
  return _requestConfigRoutesGET;
}
export function setRoutesGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigRoutesGET = value;
}
export function patchRoutesGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigRoutesGET = patch(_requestConfigRoutesGET ?? {});
}

let _requestConfigRoutesPOST: Partial<AxiosRequestConfig> | null;
export function getRoutesPOSTRequestConfig() {
  return _requestConfigRoutesPOST;
}
export function setRoutesPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigRoutesPOST = value;
}
export function patchRoutesPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigRoutesPOST = patch(_requestConfigRoutesPOST ?? {});
}

let _requestConfigRoutesGET2: Partial<AxiosRequestConfig> | null;
export function getRoutesGET2RequestConfig() {
  return _requestConfigRoutesGET2;
}
export function setRoutesGET2RequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigRoutesGET2 = value;
}
export function patchRoutesGET2RequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigRoutesGET2 = patch(_requestConfigRoutesGET2 ?? {});
}

let _requestConfigRoutesPUT: Partial<AxiosRequestConfig> | null;
export function getRoutesPUTRequestConfig() {
  return _requestConfigRoutesPUT;
}
export function setRoutesPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigRoutesPUT = value;
}
export function patchRoutesPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigRoutesPUT = patch(_requestConfigRoutesPUT ?? {});
}

let _requestConfigRoutesDELETE: Partial<AxiosRequestConfig> | null;
export function getRoutesDELETERequestConfig() {
  return _requestConfigRoutesDELETE;
}
export function setRoutesDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigRoutesDELETE = value;
}
export function patchRoutesDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigRoutesDELETE = patch(_requestConfigRoutesDELETE ?? {});
}

let _requestConfigStartRoute: Partial<AxiosRequestConfig> | null;
export function getStartRouteRequestConfig() {
  return _requestConfigStartRoute;
}
export function setStartRouteRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigStartRoute = value;
}
export function patchStartRouteRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigStartRoute = patch(_requestConfigStartRoute ?? {});
}

let _requestConfigFinishRoute: Partial<AxiosRequestConfig> | null;
export function getFinishRouteRequestConfig() {
  return _requestConfigFinishRoute;
}
export function setFinishRouteRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigFinishRoute = value;
}
export function patchFinishRouteRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigFinishRoute = patch(_requestConfigFinishRoute ?? {});
}

let _requestConfigSearchExpsAll: Partial<AxiosRequestConfig> | null;
export function getSearchExpsAllRequestConfig() {
  return _requestConfigSearchExpsAll;
}
export function setSearchExpsAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigSearchExpsAll = value;
}
export function patchSearchExpsAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigSearchExpsAll = patch(_requestConfigSearchExpsAll ?? {});
}

let _requestConfigSearchExpsPOST: Partial<AxiosRequestConfig> | null;
export function getSearchExpsPOSTRequestConfig() {
  return _requestConfigSearchExpsPOST;
}
export function setSearchExpsPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigSearchExpsPOST = value;
}
export function patchSearchExpsPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigSearchExpsPOST = patch(_requestConfigSearchExpsPOST ?? {});
}

let _requestConfigSearchExpsGET: Partial<AxiosRequestConfig> | null;
export function getSearchExpsGETRequestConfig() {
  return _requestConfigSearchExpsGET;
}
export function setSearchExpsGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigSearchExpsGET = value;
}
export function patchSearchExpsGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigSearchExpsGET = patch(_requestConfigSearchExpsGET ?? {});
}

let _requestConfigSearchExpsPUT: Partial<AxiosRequestConfig> | null;
export function getSearchExpsPUTRequestConfig() {
  return _requestConfigSearchExpsPUT;
}
export function setSearchExpsPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigSearchExpsPUT = value;
}
export function patchSearchExpsPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigSearchExpsPUT = patch(_requestConfigSearchExpsPUT ?? {});
}

let _requestConfigSearchExpsDELETE: Partial<AxiosRequestConfig> | null;
export function getSearchExpsDELETERequestConfig() {
  return _requestConfigSearchExpsDELETE;
}
export function setSearchExpsDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigSearchExpsDELETE = value;
}
export function patchSearchExpsDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigSearchExpsDELETE = patch(_requestConfigSearchExpsDELETE ?? {});
}

let _requestConfigSectionsAll: Partial<AxiosRequestConfig> | null;
export function getSectionsAllRequestConfig() {
  return _requestConfigSectionsAll;
}
export function setSectionsAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigSectionsAll = value;
}
export function patchSectionsAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigSectionsAll = patch(_requestConfigSectionsAll ?? {});
}

let _requestConfigSectionsPOST: Partial<AxiosRequestConfig> | null;
export function getSectionsPOSTRequestConfig() {
  return _requestConfigSectionsPOST;
}
export function setSectionsPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigSectionsPOST = value;
}
export function patchSectionsPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigSectionsPOST = patch(_requestConfigSectionsPOST ?? {});
}

let _requestConfigSectionsGET: Partial<AxiosRequestConfig> | null;
export function getSectionsGETRequestConfig() {
  return _requestConfigSectionsGET;
}
export function setSectionsGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigSectionsGET = value;
}
export function patchSectionsGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigSectionsGET = patch(_requestConfigSectionsGET ?? {});
}

let _requestConfigSectionsPUT: Partial<AxiosRequestConfig> | null;
export function getSectionsPUTRequestConfig() {
  return _requestConfigSectionsPUT;
}
export function setSectionsPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigSectionsPUT = value;
}
export function patchSectionsPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigSectionsPUT = patch(_requestConfigSectionsPUT ?? {});
}

let _requestConfigSectionsDELETE: Partial<AxiosRequestConfig> | null;
export function getSectionsDELETERequestConfig() {
  return _requestConfigSectionsDELETE;
}
export function setSectionsDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigSectionsDELETE = value;
}
export function patchSectionsDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigSectionsDELETE = patch(_requestConfigSectionsDELETE ?? {});
}

let _requestConfigSeriesGET: Partial<AxiosRequestConfig> | null;
export function getSeriesGETRequestConfig() {
  return _requestConfigSeriesGET;
}
export function setSeriesGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigSeriesGET = value;
}
export function patchSeriesGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigSeriesGET = patch(_requestConfigSeriesGET ?? {});
}

let _requestConfigSeriesPOST: Partial<AxiosRequestConfig> | null;
export function getSeriesPOSTRequestConfig() {
  return _requestConfigSeriesPOST;
}
export function setSeriesPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigSeriesPOST = value;
}
export function patchSeriesPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigSeriesPOST = patch(_requestConfigSeriesPOST ?? {});
}

let _requestConfigSeriesGET2: Partial<AxiosRequestConfig> | null;
export function getSeriesGET2RequestConfig() {
  return _requestConfigSeriesGET2;
}
export function setSeriesGET2RequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigSeriesGET2 = value;
}
export function patchSeriesGET2RequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigSeriesGET2 = patch(_requestConfigSeriesGET2 ?? {});
}

let _requestConfigSeriesPATCH: Partial<AxiosRequestConfig> | null;
export function getSeriesPATCHRequestConfig() {
  return _requestConfigSeriesPATCH;
}
export function setSeriesPATCHRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigSeriesPATCH = value;
}
export function patchSeriesPATCHRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigSeriesPATCH = patch(_requestConfigSeriesPATCH ?? {});
}

let _requestConfigStorageSystemGET: Partial<AxiosRequestConfig> | null;
export function getStorageSystemGETRequestConfig() {
  return _requestConfigStorageSystemGET;
}
export function setStorageSystemGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigStorageSystemGET = value;
}
export function patchStorageSystemGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigStorageSystemGET = patch(_requestConfigStorageSystemGET ?? {});
}

let _requestConfigStorageSystemPOST: Partial<AxiosRequestConfig> | null;
export function getStorageSystemPOSTRequestConfig() {
  return _requestConfigStorageSystemPOST;
}
export function setStorageSystemPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigStorageSystemPOST = value;
}
export function patchStorageSystemPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigStorageSystemPOST = patch(_requestConfigStorageSystemPOST ?? {});
}

let _requestConfigStorageSystemGET2: Partial<AxiosRequestConfig> | null;
export function getStorageSystemGET2RequestConfig() {
  return _requestConfigStorageSystemGET2;
}
export function setStorageSystemGET2RequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigStorageSystemGET2 = value;
}
export function patchStorageSystemGET2RequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigStorageSystemGET2 = patch(_requestConfigStorageSystemGET2 ?? {});
}

let _requestConfigStorageSystemDELETE: Partial<AxiosRequestConfig> | null;
export function getStorageSystemDELETERequestConfig() {
  return _requestConfigStorageSystemDELETE;
}
export function setStorageSystemDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigStorageSystemDELETE = value;
}
export function patchStorageSystemDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigStorageSystemDELETE = patch(_requestConfigStorageSystemDELETE ?? {});
}

let _requestConfigVehiclesGET: Partial<AxiosRequestConfig> | null;
export function getVehiclesGETRequestConfig() {
  return _requestConfigVehiclesGET;
}
export function setVehiclesGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigVehiclesGET = value;
}
export function patchVehiclesGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigVehiclesGET = patch(_requestConfigVehiclesGET ?? {});
}

let _requestConfigVehiclesPOST: Partial<AxiosRequestConfig> | null;
export function getVehiclesPOSTRequestConfig() {
  return _requestConfigVehiclesPOST;
}
export function setVehiclesPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigVehiclesPOST = value;
}
export function patchVehiclesPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigVehiclesPOST = patch(_requestConfigVehiclesPOST ?? {});
}

let _requestConfigVehiclesGET2: Partial<AxiosRequestConfig> | null;
export function getVehiclesGET2RequestConfig() {
  return _requestConfigVehiclesGET2;
}
export function setVehiclesGET2RequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigVehiclesGET2 = value;
}
export function patchVehiclesGET2RequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigVehiclesGET2 = patch(_requestConfigVehiclesGET2 ?? {});
}

let _requestConfigVehiclesPUT: Partial<AxiosRequestConfig> | null;
export function getVehiclesPUTRequestConfig() {
  return _requestConfigVehiclesPUT;
}
export function setVehiclesPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigVehiclesPUT = value;
}
export function patchVehiclesPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigVehiclesPUT = patch(_requestConfigVehiclesPUT ?? {});
}

let _requestConfigVehiclesDELETE: Partial<AxiosRequestConfig> | null;
export function getVehiclesDELETERequestConfig() {
  return _requestConfigVehiclesDELETE;
}
export function setVehiclesDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigVehiclesDELETE = value;
}
export function patchVehiclesDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigVehiclesDELETE = patch(_requestConfigVehiclesDELETE ?? {});
}

let _requestConfigWarehousesGET: Partial<AxiosRequestConfig> | null;
export function getWarehousesGETRequestConfig() {
  return _requestConfigWarehousesGET;
}
export function setWarehousesGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigWarehousesGET = value;
}
export function patchWarehousesGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigWarehousesGET = patch(_requestConfigWarehousesGET ?? {});
}

let _requestConfigWarehousesPOST: Partial<AxiosRequestConfig> | null;
export function getWarehousesPOSTRequestConfig() {
  return _requestConfigWarehousesPOST;
}
export function setWarehousesPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigWarehousesPOST = value;
}
export function patchWarehousesPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigWarehousesPOST = patch(_requestConfigWarehousesPOST ?? {});
}

let _requestConfigWarehousesGET2: Partial<AxiosRequestConfig> | null;
export function getWarehousesGET2RequestConfig() {
  return _requestConfigWarehousesGET2;
}
export function setWarehousesGET2RequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigWarehousesGET2 = value;
}
export function patchWarehousesGET2RequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigWarehousesGET2 = patch(_requestConfigWarehousesGET2 ?? {});
}

let _requestConfigWarehousesPATCH: Partial<AxiosRequestConfig> | null;
export function getWarehousesPATCHRequestConfig() {
  return _requestConfigWarehousesPATCH;
}
export function setWarehousesPATCHRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigWarehousesPATCH = value;
}
export function patchWarehousesPATCHRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigWarehousesPATCH = patch(_requestConfigWarehousesPATCH ?? {});
}

let _requestConfigWarehousesPUT: Partial<AxiosRequestConfig> | null;
export function getWarehousesPUTRequestConfig() {
  return _requestConfigWarehousesPUT;
}
export function setWarehousesPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigWarehousesPUT = value;
}
export function patchWarehousesPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigWarehousesPUT = patch(_requestConfigWarehousesPUT ?? {});
}

let _requestConfigWarehousesDELETE: Partial<AxiosRequestConfig> | null;
export function getWarehousesDELETERequestConfig() {
  return _requestConfigWarehousesDELETE;
}
export function setWarehousesDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigWarehousesDELETE = value;
}
export function patchWarehousesDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigWarehousesDELETE = patch(_requestConfigWarehousesDELETE ?? {});
}

let _requestConfigWidgetsAll: Partial<AxiosRequestConfig> | null;
export function getWidgetsAllRequestConfig() {
  return _requestConfigWidgetsAll;
}
export function setWidgetsAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigWidgetsAll = value;
}
export function patchWidgetsAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigWidgetsAll = patch(_requestConfigWidgetsAll ?? {});
}

let _requestConfigWidgetsPOST: Partial<AxiosRequestConfig> | null;
export function getWidgetsPOSTRequestConfig() {
  return _requestConfigWidgetsPOST;
}
export function setWidgetsPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigWidgetsPOST = value;
}
export function patchWidgetsPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigWidgetsPOST = patch(_requestConfigWidgetsPOST ?? {});
}

let _requestConfigWidgetsGET: Partial<AxiosRequestConfig> | null;
export function getWidgetsGETRequestConfig() {
  return _requestConfigWidgetsGET;
}
export function setWidgetsGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigWidgetsGET = value;
}
export function patchWidgetsGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigWidgetsGET = patch(_requestConfigWidgetsGET ?? {});
}

let _requestConfigWidgetsPUT: Partial<AxiosRequestConfig> | null;
export function getWidgetsPUTRequestConfig() {
  return _requestConfigWidgetsPUT;
}
export function setWidgetsPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigWidgetsPUT = value;
}
export function patchWidgetsPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigWidgetsPUT = patch(_requestConfigWidgetsPUT ?? {});
}

let _requestConfigWidgetsDELETE: Partial<AxiosRequestConfig> | null;
export function getWidgetsDELETERequestConfig() {
  return _requestConfigWidgetsDELETE;
}
export function setWidgetsDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigWidgetsDELETE = value;
}
export function patchWidgetsDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigWidgetsDELETE = patch(_requestConfigWidgetsDELETE ?? {});
}