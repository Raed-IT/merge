//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../axios-client';
import { useQuery, useMutation } from '@tanstack/react-query';
import type { UseQueryResult, QueryFunctionContext, UseQueryOptions, QueryClient, QueryKey, MutationKey, UseMutationOptions, UseMutationResult, QueryMeta, MutationMeta } from '@tanstack/react-query';
import { trimArrayEnd, isParameterObject, getBaseUrl, addMetaToOptions } from './helpers';
import type { QueryMetaContextValue } from 'react-query-swagger';
import { QueryMetaContext } from 'react-query-swagger';
import { useContext } from 'react';
import * as Client from './Client'
export { Client };
import type { AxiosRequestConfig } from 'axios';


export type ActionsGETQueryParameters = {
  id: string ;
}

export type ActionsPUTQueryParameters = {
  id: string ;
}

export type ActionsDELETEQueryParameters = {
  id: string ;
}

export type ApiKeysGETQueryParameters = {
  apiKey: string ;
}

export type ApiKeysPUTQueryParameters = {
  apiKey: string ;
}

export type ApiKeysDELETEQueryParameters = {
  apiKey: string ;
}

export type AppsGETQueryParameters = {
  id: string ;
}

export type AppsPUTQueryParameters = {
  id: string ;
}

export type AppsDELETEQueryParameters = {
  id: string ;
}

export type AssetsQueryParameters = {
  pageNumber?: number | undefined ;
  pageSize?: number | undefined ;
  totalCount?: number | undefined ;
  sort_SortBy?: string | undefined ;
  sort_Ascending?: boolean | undefined ;
  filter_Logic?: Types.LogicalOperator | undefined ;
  filter_Conditions?: Types.FilterCondition[] | undefined ;
  filter_Groups?: Types.FilterGroup[] | undefined ;
}

export type Assets2QueryParameters = {
  id: string ;
}

export type AuthorizationProfilesGETQueryParameters = {
  pageNumber?: number | undefined ;
  pageSize?: number | undefined ;
  totalCount?: number | undefined ;
  sort_SortBy?: string | undefined ;
  sort_Ascending?: boolean | undefined ;
  filter_Logic?: Types.LogicalOperator | undefined ;
  filter_Conditions?: Types.FilterCondition[] | undefined ;
  filter_Groups?: Types.FilterGroup[] | undefined ;
}

export type AuthorizationProfilesGET2QueryParameters = {
  id: string ;
}

export type CompaniesGETQueryParameters = {
  pageNumber?: number | undefined ;
  pageSize?: number | undefined ;
  totalCount?: number | undefined ;
  sort_SortBy?: string | undefined ;
  sort_Ascending?: boolean | undefined ;
  filter_Logic?: Types.LogicalOperator | undefined ;
  filter_Conditions?: Types.FilterCondition[] | undefined ;
  filter_Groups?: Types.FilterGroup[] | undefined ;
}

export type CompaniesGET2QueryParameters = {
  id: string ;
}

export type CompaniesPUTQueryParameters = {
  id: string ;
}

export type CompaniesDELETEQueryParameters = {
  id: string ;
}

export type CreateContactQueryParameters = {
  id: string ;
}

export type InviteUserQueryParameters = {
  companyId: string ;
  contactId: string ;
}

export type ConfigurationGETQueryParameters = {
  body?: Types.QueryPayload | undefined ;
}

export type ConfigurationGET2QueryParameters = {
  id: string ;
}

export type ConfigurationPATCHQueryParameters = {
  id: string ;
}

export type ConfigurationPUTQueryParameters = {
  id: string ;
}

export type ConfigurationDELETEQueryParameters = {
  id: string ;
}

export type ConsignmentsGETQueryParameters = {
  pageNumber?: number | undefined ;
  pageSize?: number | undefined ;
  totalCount?: number | undefined ;
  sort_SortBy?: string | undefined ;
  sort_Ascending?: boolean | undefined ;
  filter_Logic?: Types.LogicalOperator | undefined ;
  filter_Conditions?: Types.FilterCondition[] | undefined ;
  filter_Groups?: Types.FilterGroup[] | undefined ;
}

export type ConsignmentsGET2QueryParameters = {
  id: string ;
}

export type ConsignmentsPUTQueryParameters = {
  id: string ;
}

export type ConsignmentsDELETEQueryParameters = {
  id: string ;
}

export type ValidateAddressQueryParameters = {
  address?: string | undefined ;
}

export type UpdateStatusQueryParameters = {
  id: string ;
}

export type UploadPodQueryParameters = {
  id: string ;
  file?: Types.FileParameter | undefined ;
}

export type UploadPodMutationParameters = {
  file?: Types.FileParameter | undefined ;
}

export type DownloadPodQueryParameters = {
  id: string ;
  assetId: string ;
}

export type DeletePodQueryParameters = {
  id: string ;
  assetId: string ;
}

export type DashboardsGETQueryParameters = {
  id: string ;
}

export type DashboardsPUTQueryParameters = {
  id: string ;
}

export type DashboardsDELETEQueryParameters = {
  id: string ;
}

export type DataSourcesGETQueryParameters = {
  id: string ;
}

export type DataSourcesPUTQueryParameters = {
  id: string ;
}

export type DataSourcesDELETEQueryParameters = {
  id: string ;
}

export type DriversQueryParameters = {
  pageNumber?: number | undefined ;
  pageSize?: number | undefined ;
  totalCount?: number | undefined ;
  sort_SortBy?: string | undefined ;
  sort_Ascending?: boolean | undefined ;
  filter_Logic?: Types.LogicalOperator | undefined ;
  filter_Conditions?: Types.FilterCondition[] | undefined ;
  filter_Groups?: Types.FilterGroup[] | undefined ;
}

export type Drivers2QueryParameters = {
  id: string ;
}

export type GetHistoryQueryParameters = {
  id: string ;
}

export type EmployeesGETQueryParameters = {
  pageNumber?: number | undefined ;
  pageSize?: number | undefined ;
  totalCount?: number | undefined ;
  sort_SortBy?: string | undefined ;
  sort_Ascending?: boolean | undefined ;
  filter_Logic?: Types.LogicalOperator | undefined ;
  filter_Conditions?: Types.FilterCondition[] | undefined ;
  filter_Groups?: Types.FilterGroup[] | undefined ;
}

export type EmployeesGET2QueryParameters = {
  id: string ;
}

export type EmployeesPUTQueryParameters = {
  id: string ;
}

export type DeactivateEmployeeQueryParameters = {
  id: string ;
}

export type ReactivateEmployeeQueryParameters = {
  id: string ;
}

export type DeletedEmployeesQueryParameters = {
  pageNumber?: number | undefined ;
  pageSize?: number | undefined ;
  totalCount?: number | undefined ;
  sort_SortBy?: string | undefined ;
  sort_Ascending?: boolean | undefined ;
  filter_Logic?: Types.LogicalOperator | undefined ;
  filter_Conditions?: Types.FilterCondition[] | undefined ;
  filter_Groups?: Types.FilterGroup[] | undefined ;
}

export type FailureReasonsGETQueryParameters = {
  pageNumber?: number | undefined ;
  pageSize?: number | undefined ;
  totalCount?: number | undefined ;
  sort_SortBy?: string | undefined ;
  sort_Ascending?: boolean | undefined ;
  filter_Logic?: Types.LogicalOperator | undefined ;
  filter_Conditions?: Types.FilterCondition[] | undefined ;
  filter_Groups?: Types.FilterGroup[] | undefined ;
}

export type FailureReasonsGET2QueryParameters = {
  id: string ;
}

export type FailureReasonsPUTQueryParameters = {
  id: string ;
}

export type FailureReasonsDELETEQueryParameters = {
  id: string ;
}

export type FieldsGETQueryParameters = {
  id: string ;
}

export type FieldsPUTQueryParameters = {
  id: string ;
}

export type FieldsDELETEQueryParameters = {
  id: string ;
}








export type LayoutDefinitionsGETQueryParameters = {
  id: string ;
}

export type LayoutDefinitionsPUTQueryParameters = {
  id: string ;
}

export type LayoutDefinitionsDELETEQueryParameters = {
  id: string ;
}

export type LayoutParametersGETQueryParameters = {
  id: string ;
}

export type LayoutParametersPUTQueryParameters = {
  id: string ;
}

export type LayoutParametersDELETEQueryParameters = {
  id: string ;
}

export type MenusGETQueryParameters = {
  id: string ;
}

export type MenusPUTQueryParameters = {
  id: string ;
}

export type MenusDELETEQueryParameters = {
  id: string ;
}

export type ModuleButtonsGETQueryParameters = {
  id: string ;
}

export type ModuleButtonsPUTQueryParameters = {
  id: string ;
}

export type ModuleButtonsDELETEQueryParameters = {
  id: string ;
}

export type ModulesGETQueryParameters = {
  id: string ;
}

export type ModulesPUTQueryParameters = {
  id: string ;
}

export type ModulesDELETEQueryParameters = {
  id: string ;
}

export type OverridesGETQueryParameters = {
  id: string ;
}

export type OverridesPUTQueryParameters = {
  id: string ;
}

export type OverridesDELETEQueryParameters = {
  id: string ;
}

export type GenerateLinkQueryParameters = {
  paymentGatewayId: string ;
}

export type PaymentCheckoutQueryParameters = {
  paymentGatewayId: string ;
}

 

export type PaymentTransactionsQueryParameters = {
  pageNumber?: number | undefined ;
  pageSize?: number | undefined ;
  totalCount?: number | undefined ;
  sort_SortBy?: string | undefined ;
  sort_Ascending?: boolean | undefined ;
  filter_Logic?: Types.LogicalOperator | undefined ;
  filter_Conditions?: Types.FilterCondition[] | undefined ;
  filter_Groups?: Types.FilterGroup[] | undefined ;
}

export type RoutesGETQueryParameters = {
  pageNumber?: number | undefined ;
  pageSize?: number | undefined ;
  totalCount?: number | undefined ;
  sort_SortBy?: string | undefined ;
  sort_Ascending?: boolean | undefined ;
  filter_Logic?: Types.LogicalOperator | undefined ;
  filter_Conditions?: Types.FilterCondition[] | undefined ;
  filter_Groups?: Types.FilterGroup[] | undefined ;
}

export type RoutesGET2QueryParameters = {
  id: string ;
}

export type RoutesPUTQueryParameters = {
  id: string ;
}

export type RoutesDELETEQueryParameters = {
  id: string ;
}

export type StartRouteQueryParameters = {
  id: string ;
}

export type FinishRouteQueryParameters = {
  id: string ;
}

export type SearchExpsGETQueryParameters = {
  id: string ;
}

export type SearchExpsPUTQueryParameters = {
  id: string ;
}

export type SearchExpsDELETEQueryParameters = {
  id: string ;
}

export type SectionsGETQueryParameters = {
  id: string ;
}

export type SectionsPUTQueryParameters = {
  id: string ;
}

export type SectionsDELETEQueryParameters = {
  id: string ;
}

export type SeriesGETQueryParameters = {
  pageNumber?: number | undefined ;
  pageSize?: number | undefined ;
  totalCount?: number | undefined ;
  sort_SortBy?: string | undefined ;
  sort_Ascending?: boolean | undefined ;
  filter_Logic?: Types.LogicalOperator | undefined ;
  filter_Conditions?: Types.FilterCondition[] | undefined ;
  filter_Groups?: Types.FilterGroup[] | undefined ;
}

export type SeriesGET2QueryParameters = {
  id: string ;
}

export type SeriesPATCHQueryParameters = {
  id: string ;
}

export type StorageSystemGETQueryParameters = {
  pageNumber?: number | undefined ;
  pageSize?: number | undefined ;
  totalCount?: number | undefined ;
  sort_SortBy?: string | undefined ;
  sort_Ascending?: boolean | undefined ;
  filter_Logic?: Types.LogicalOperator | undefined ;
  filter_Conditions?: Types.FilterCondition[] | undefined ;
  filter_Groups?: Types.FilterGroup[] | undefined ;
}

export type StorageSystemGET2QueryParameters = {
  id: string ;
}

export type StorageSystemDELETEQueryParameters = {
  id: string ;
}

export type VehiclesGETQueryParameters = {
  pageNumber?: number | undefined ;
  pageSize?: number | undefined ;
  totalCount?: number | undefined ;
  sort_SortBy?: string | undefined ;
  sort_Ascending?: boolean | undefined ;
  filter_Logic?: Types.LogicalOperator | undefined ;
  filter_Conditions?: Types.FilterCondition[] | undefined ;
  filter_Groups?: Types.FilterGroup[] | undefined ;
}

export type VehiclesGET2QueryParameters = {
  id: string ;
}

export type VehiclesPUTQueryParameters = {
  id: string ;
}

export type VehiclesDELETEQueryParameters = {
  id: string ;
}

export type WarehousesGETQueryParameters = {
  pageNumber?: number | undefined ;
  pageSize?: number | undefined ;
  totalCount?: number | undefined ;
  sort_SortBy?: string | undefined ;
  sort_Ascending?: boolean | undefined ;
  filter_Logic?: Types.LogicalOperator | undefined ;
  filter_Conditions?: Types.FilterCondition[] | undefined ;
  filter_Groups?: Types.FilterGroup[] | undefined ;
}

export type WarehousesGET2QueryParameters = {
  id: string ;
}

export type WarehousesPATCHQueryParameters = {
  id: string ;
}

export type WarehousesPUTQueryParameters = {
  id: string ;
}

export type WarehousesDELETEQueryParameters = {
  id: string ;
}

export type WidgetsGETQueryParameters = {
  id: string ;
}

export type WidgetsPUTQueryParameters = {
  id: string ;
}

export type WidgetsDELETEQueryParameters = {
  id: string ;
}

export function actionsAllUrl(): string {
  let url_ = getBaseUrl() + "/api/layout/Actions";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let actionsAllDefaultOptions: Omit<UseQueryOptions<Types.ActionDto[], unknown, Types.ActionDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ActionDto[], unknown, Types.ActionDto[]>, 'queryFn'>> = {
};
export function getActionsAllDefaultOptions() {
  return actionsAllDefaultOptions;
};
export function setActionsAllDefaultOptions(options: typeof actionsAllDefaultOptions) {
  actionsAllDefaultOptions = options;
}

export function actionsAllQueryKey(): QueryKey;
export function actionsAllQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'actionsAll',
    ]);
}
export function __actionsAll(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.actionsAll(
axiosConfig    );
}

/**
 * @return OK
 */
export function useActionsAllQuery<TSelectData = Types.ActionDto[], TError = unknown>(options?: Omit<UseQueryOptions<Types.ActionDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useActionsAllQuery<TSelectData = Types.ActionDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ActionDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ActionDto[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __actionsAll(context, axiosConfig) : __actionsAll,
    queryKey: actionsAllQueryKey(),
    ...actionsAllDefaultOptions as unknown as Omit<UseQueryOptions<Types.ActionDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setActionsAllData(queryClient: QueryClient, updater: (data: Types.ActionDto[] | undefined) => Types.ActionDto[], ) {
  queryClient.setQueryData(actionsAllQueryKey(),
    updater
  );
}

/**
 * @return OK
 */
export function setActionsAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ActionDto[] | undefined) => Types.ActionDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function actionsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/layout/Actions";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function actionsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'actionsPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useActionsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.ActionDto, unknown, Types.ActionDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ActionDto, unknown, Types.ActionDto, TContext> {
  const key = actionsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ActionDto) => Client.actionsPOST(body),
    mutationKey: key,
  });
}
  
export function actionsGETUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/Actions/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let actionsGETDefaultOptions: Omit<UseQueryOptions<Types.ActionDto, unknown, Types.ActionDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ActionDto, unknown, Types.ActionDto>, 'queryFn'>> = {
};
export function getActionsGETDefaultOptions() {
  return actionsGETDefaultOptions;
};
export function setActionsGETDefaultOptions(options: typeof actionsGETDefaultOptions) {
  actionsGETDefaultOptions = options;
}

export function actionsGETQueryKey(id: string): QueryKey;
export function actionsGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as ActionsGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'actionsGET',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'actionsGET',
        ...params
      ]);
  }
}
export function __actionsGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.actionsGET(
      context.queryKey[2] as string,axiosConfig    );
}

export function useActionsGETQuery<TSelectData = Types.ActionDto, TError = unknown>(dto: ActionsGETQueryParameters, options?: Omit<UseQueryOptions<Types.ActionDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useActionsGETQuery<TSelectData = Types.ActionDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.ActionDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useActionsGETQuery<TSelectData = Types.ActionDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ActionDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as ActionsGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ActionDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __actionsGET(context, axiosConfig) : __actionsGET,
    queryKey: actionsGETQueryKey(id),
    ...actionsGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.ActionDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setActionsGETData(queryClient: QueryClient, updater: (data: Types.ActionDto | undefined) => Types.ActionDto, id: string) {
  queryClient.setQueryData(actionsGETQueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setActionsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ActionDto | undefined) => Types.ActionDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function actionsPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/Actions/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function actionsPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'actionsPUT',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useActionsPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.ActionDto, unknown, Types.ActionDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ActionDto, unknown, Types.ActionDto, TContext> {
  const key = actionsPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ActionDto) => Client.actionsPUT(id, body),
    mutationKey: key,
  });
}
  
type ActionsPUT__MutationParameters = ActionsPUTQueryParameters & {
  body: Types.ActionDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useActionsPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.ActionDto, unknown, ActionsPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: ActionsPUTQueryParameters}): UseMutationResult<Types.ActionDto, unknown, ActionsPUT__MutationParameters, TContext> {
  const key = actionsPUTMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: ActionsPUT__MutationParameters) => Client.actionsPUT(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function actionsDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/Actions/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function actionsDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'actionsDELETE',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useActionsDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<boolean, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<boolean, unknown, void, TContext> {
  const key = actionsDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.actionsDELETE(id),
    mutationKey: key,
  });
}
  
type ActionsDELETE__MutationParameters = ActionsDELETEQueryParameters

/**
 * @return OK
 */
export function useActionsDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<boolean, unknown, ActionsDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: ActionsDELETEQueryParameters}): UseMutationResult<boolean, unknown, ActionsDELETE__MutationParameters, TContext> {
  const key = actionsDELETEMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: ActionsDELETE__MutationParameters) => Client.actionsDELETE(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function apiKeysAllUrl(): string {
  let url_ = getBaseUrl() + "/api/ApiKeys";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let apiKeysAllDefaultOptions: Omit<UseQueryOptions<Types.ApiKeyDto[], unknown, Types.ApiKeyDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ApiKeyDto[], unknown, Types.ApiKeyDto[]>, 'queryFn'>> = {
};
export function getApiKeysAllDefaultOptions() {
  return apiKeysAllDefaultOptions;
};
export function setApiKeysAllDefaultOptions(options: typeof apiKeysAllDefaultOptions) {
  apiKeysAllDefaultOptions = options;
}

export function apiKeysAllQueryKey(): QueryKey;
export function apiKeysAllQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'apiKeysAll',
    ]);
}
export function __apiKeysAll(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.apiKeysAll(
axiosConfig    );
}

/**
 * @return OK
 */
export function useApiKeysAllQuery<TSelectData = Types.ApiKeyDto[], TError = unknown>(options?: Omit<UseQueryOptions<Types.ApiKeyDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useApiKeysAllQuery<TSelectData = Types.ApiKeyDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ApiKeyDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ApiKeyDto[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __apiKeysAll(context, axiosConfig) : __apiKeysAll,
    queryKey: apiKeysAllQueryKey(),
    ...apiKeysAllDefaultOptions as unknown as Omit<UseQueryOptions<Types.ApiKeyDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setApiKeysAllData(queryClient: QueryClient, updater: (data: Types.ApiKeyDto[] | undefined) => Types.ApiKeyDto[], ) {
  queryClient.setQueryData(apiKeysAllQueryKey(),
    updater
  );
}

/**
 * @return OK
 */
export function setApiKeysAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ApiKeyDto[] | undefined) => Types.ApiKeyDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function apiKeysPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/ApiKeys";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function apiKeysPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'apiKeysPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useApiKeysPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.ApiKeyDto, unknown, Types.ApiKeyDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ApiKeyDto, unknown, Types.ApiKeyDto, TContext> {
  const key = apiKeysPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ApiKeyDto) => Client.apiKeysPOST(body),
    mutationKey: key,
  });
}
  
export function apiKeysGETUrl(apiKey: string): string {
  let url_ = getBaseUrl() + "/api/ApiKeys/{apiKey}";
if (apiKey === undefined || apiKey === null)
  throw new Error("The parameter 'apiKey' must be defined.");
url_ = url_.replace("{apiKey}", encodeURIComponent("" + apiKey));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let apiKeysGETDefaultOptions: Omit<UseQueryOptions<Types.ApiKeyDto, unknown, Types.ApiKeyDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ApiKeyDto, unknown, Types.ApiKeyDto>, 'queryFn'>> = {
};
export function getApiKeysGETDefaultOptions() {
  return apiKeysGETDefaultOptions;
};
export function setApiKeysGETDefaultOptions(options: typeof apiKeysGETDefaultOptions) {
  apiKeysGETDefaultOptions = options;
}

export function apiKeysGETQueryKey(apiKey: string): QueryKey;
export function apiKeysGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { apiKey,  } = params[0] as ApiKeysGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'apiKeysGET',
        apiKey as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'apiKeysGET',
        ...params
      ]);
  }
}
export function __apiKeysGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.apiKeysGET(
      context.queryKey[2] as string,axiosConfig    );
}

export function useApiKeysGETQuery<TSelectData = Types.ApiKeyDto, TError = unknown>(dto: ApiKeysGETQueryParameters, options?: Omit<UseQueryOptions<Types.ApiKeyDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useApiKeysGETQuery<TSelectData = Types.ApiKeyDto, TError = unknown>(apiKey: string, options?: Omit<UseQueryOptions<Types.ApiKeyDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useApiKeysGETQuery<TSelectData = Types.ApiKeyDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ApiKeyDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let apiKey: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ apiKey,  } = params[0] as ApiKeysGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [apiKey, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ApiKeyDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __apiKeysGET(context, axiosConfig) : __apiKeysGET,
    queryKey: apiKeysGETQueryKey(apiKey),
    ...apiKeysGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.ApiKeyDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setApiKeysGETData(queryClient: QueryClient, updater: (data: Types.ApiKeyDto | undefined) => Types.ApiKeyDto, apiKey: string) {
  queryClient.setQueryData(apiKeysGETQueryKey(apiKey),
    updater
  );
}

/**
 * @return OK
 */
export function setApiKeysGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ApiKeyDto | undefined) => Types.ApiKeyDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function apiKeysPUTUrl(apiKey: string): string {
  let url_ = getBaseUrl() + "/api/ApiKeys/{apiKey}";
if (apiKey === undefined || apiKey === null)
  throw new Error("The parameter 'apiKey' must be defined.");
url_ = url_.replace("{apiKey}", encodeURIComponent("" + apiKey));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function apiKeysPUTMutationKey(apiKey: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'apiKeysPUT',
      apiKey as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useApiKeysPUTMutation<TContext>(apiKey: string, options?: Omit<UseMutationOptions<Types.ApiKeyDto, unknown, Types.ApiKeyDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ApiKeyDto, unknown, Types.ApiKeyDto, TContext> {
  const key = apiKeysPUTMutationKey(apiKey);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ApiKeyDto) => Client.apiKeysPUT(apiKey, body),
    mutationKey: key,
  });
}
  
type ApiKeysPUT__MutationParameters = ApiKeysPUTQueryParameters & {
  body: Types.ApiKeyDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useApiKeysPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.ApiKeyDto, unknown, ApiKeysPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: ApiKeysPUTQueryParameters}): UseMutationResult<Types.ApiKeyDto, unknown, ApiKeysPUT__MutationParameters, TContext> {
  const key = apiKeysPUTMutationKey(options?.parameters?.apiKey!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: ApiKeysPUT__MutationParameters) => Client.apiKeysPUT(data.apiKey ?? options?.parameters?.apiKey!, data.body),
  mutationKey: key,
});
}
  
export function apiKeysDELETEUrl(apiKey: string): string {
  let url_ = getBaseUrl() + "/api/ApiKeys/{apiKey}";
if (apiKey === undefined || apiKey === null)
  throw new Error("The parameter 'apiKey' must be defined.");
url_ = url_.replace("{apiKey}", encodeURIComponent("" + apiKey));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function apiKeysDELETEMutationKey(apiKey: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'apiKeysDELETE',
      apiKey as any,
    ]);
}

/**
 * @return OK
 */
export function useApiKeysDELETEMutation<TContext>(apiKey: string, options?: Omit<UseMutationOptions<boolean, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<boolean, unknown, void, TContext> {
  const key = apiKeysDELETEMutationKey(apiKey);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.apiKeysDELETE(apiKey),
    mutationKey: key,
  });
}
  
type ApiKeysDELETE__MutationParameters = ApiKeysDELETEQueryParameters

/**
 * @return OK
 */
export function useApiKeysDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<boolean, unknown, ApiKeysDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: ApiKeysDELETEQueryParameters}): UseMutationResult<boolean, unknown, ApiKeysDELETE__MutationParameters, TContext> {
  const key = apiKeysDELETEMutationKey(options?.parameters?.apiKey!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: ApiKeysDELETE__MutationParameters) => Client.apiKeysDELETE(data.apiKey ?? options?.parameters?.apiKey!),
  mutationKey: key,
});
}
  
export function appsAllUrl(): string {
  let url_ = getBaseUrl() + "/api/layout/Apps";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let appsAllDefaultOptions: Omit<UseQueryOptions<Types.AppDto[], unknown, Types.AppDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.AppDto[], unknown, Types.AppDto[]>, 'queryFn'>> = {
};
export function getAppsAllDefaultOptions() {
  return appsAllDefaultOptions;
};
export function setAppsAllDefaultOptions(options: typeof appsAllDefaultOptions) {
  appsAllDefaultOptions = options;
}

export function appsAllQueryKey(): QueryKey;
export function appsAllQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'appsAll',
    ]);
}
export function __appsAll(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.appsAll(
axiosConfig    );
}

/**
 * @return OK
 */
export function useAppsAllQuery<TSelectData = Types.AppDto[], TError = unknown>(options?: Omit<UseQueryOptions<Types.AppDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useAppsAllQuery<TSelectData = Types.AppDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.AppDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.AppDto[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __appsAll(context, axiosConfig) : __appsAll,
    queryKey: appsAllQueryKey(),
    ...appsAllDefaultOptions as unknown as Omit<UseQueryOptions<Types.AppDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setAppsAllData(queryClient: QueryClient, updater: (data: Types.AppDto[] | undefined) => Types.AppDto[], ) {
  queryClient.setQueryData(appsAllQueryKey(),
    updater
  );
}

/**
 * @return OK
 */
export function setAppsAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.AppDto[] | undefined) => Types.AppDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function appsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/layout/Apps";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function appsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'appsPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useAppsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.AppDto, unknown, Types.AppDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AppDto, unknown, Types.AppDto, TContext> {
  const key = appsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.AppDto) => Client.appsPOST(body),
    mutationKey: key,
  });
}
  
export function appsGETUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/Apps/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let appsGETDefaultOptions: Omit<UseQueryOptions<Types.AppDto, unknown, Types.AppDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.AppDto, unknown, Types.AppDto>, 'queryFn'>> = {
};
export function getAppsGETDefaultOptions() {
  return appsGETDefaultOptions;
};
export function setAppsGETDefaultOptions(options: typeof appsGETDefaultOptions) {
  appsGETDefaultOptions = options;
}

export function appsGETQueryKey(id: string): QueryKey;
export function appsGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as AppsGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'appsGET',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'appsGET',
        ...params
      ]);
  }
}
export function __appsGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.appsGET(
      context.queryKey[2] as string,axiosConfig    );
}

export function useAppsGETQuery<TSelectData = Types.AppDto, TError = unknown>(dto: AppsGETQueryParameters, options?: Omit<UseQueryOptions<Types.AppDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useAppsGETQuery<TSelectData = Types.AppDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.AppDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useAppsGETQuery<TSelectData = Types.AppDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.AppDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as AppsGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.AppDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __appsGET(context, axiosConfig) : __appsGET,
    queryKey: appsGETQueryKey(id),
    ...appsGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.AppDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setAppsGETData(queryClient: QueryClient, updater: (data: Types.AppDto | undefined) => Types.AppDto, id: string) {
  queryClient.setQueryData(appsGETQueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setAppsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.AppDto | undefined) => Types.AppDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function appsPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/Apps/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function appsPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'appsPUT',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useAppsPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.AppDto, unknown, Types.AppDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AppDto, unknown, Types.AppDto, TContext> {
  const key = appsPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.AppDto) => Client.appsPUT(id, body),
    mutationKey: key,
  });
}
  
type AppsPUT__MutationParameters = AppsPUTQueryParameters & {
  body: Types.AppDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useAppsPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.AppDto, unknown, AppsPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: AppsPUTQueryParameters}): UseMutationResult<Types.AppDto, unknown, AppsPUT__MutationParameters, TContext> {
  const key = appsPUTMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: AppsPUT__MutationParameters) => Client.appsPUT(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function appsDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/Apps/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function appsDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'appsDELETE',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useAppsDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<boolean, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<boolean, unknown, void, TContext> {
  const key = appsDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.appsDELETE(id),
    mutationKey: key,
  });
}
  
type AppsDELETE__MutationParameters = AppsDELETEQueryParameters

/**
 * @return OK
 */
export function useAppsDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<boolean, unknown, AppsDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: AppsDELETEQueryParameters}): UseMutationResult<boolean, unknown, AppsDELETE__MutationParameters, TContext> {
  const key = appsDELETEMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: AppsDELETE__MutationParameters) => Client.appsDELETE(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function assetsUrl(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined): string {
  let url_ = getBaseUrl() + "/api/Assets?";
if (pageNumber === null)
    throw new Error("The parameter 'pageNumber' cannot be null.");
else if (pageNumber !== undefined)
    url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
if (totalCount === null)
    throw new Error("The parameter 'totalCount' cannot be null.");
else if (totalCount !== undefined)
    url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&";
if (sort_SortBy === null)
    throw new Error("The parameter 'sort_SortBy' cannot be null.");
else if (sort_SortBy !== undefined)
    url_ += "Sort.SortBy=" + encodeURIComponent("" + sort_SortBy) + "&";
if (sort_Ascending === null)
    throw new Error("The parameter 'sort_Ascending' cannot be null.");
else if (sort_Ascending !== undefined)
    url_ += "Sort.Ascending=" + encodeURIComponent("" + sort_Ascending) + "&";
if (filter_Logic === null)
    throw new Error("The parameter 'filter_Logic' cannot be null.");
else if (filter_Logic !== undefined)
    url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&";
if (filter_Conditions === null)
    throw new Error("The parameter 'filter_Conditions' cannot be null.");
else if (filter_Conditions !== undefined)
    filter_Conditions && filter_Conditions.forEach((item, index) => {
        for (let attr in item)
			if (item.hasOwnProperty(attr)) {
				url_ += "Filter.Conditions[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
			}
    });
if (filter_Groups === null)
    throw new Error("The parameter 'filter_Groups' cannot be null.");
else if (filter_Groups !== undefined)
    filter_Groups && filter_Groups.forEach((item, index) => {
        for (let attr in item)
			if (item.hasOwnProperty(attr)) {
				url_ += "Filter.Groups[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
			}
    });
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let assetsDefaultOptions: Omit<UseQueryOptions<Types.AssetDtoQueryResponse, unknown, Types.AssetDtoQueryResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.AssetDtoQueryResponse, unknown, Types.AssetDtoQueryResponse>, 'queryFn'>> = {
};
export function getAssetsDefaultOptions() {
  return assetsDefaultOptions;
};
export function setAssetsDefaultOptions(options: typeof assetsDefaultOptions) {
  assetsDefaultOptions = options;
}

export function assetsQueryKey(dto: AssetsQueryParameters): QueryKey;
export function assetsQueryKey(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined): QueryKey;
export function assetsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups,  } = params[0] as AssetsQueryParameters;

    return trimArrayEnd([
        'Client',
        'assets',
        pageNumber as any,
        pageSize as any,
        totalCount as any,
        sort_SortBy as any,
        sort_Ascending as any,
        filter_Logic as any,
        filter_Conditions as any,
        filter_Groups as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'assets',
        ...params
      ]);
  }
}
export function __assets(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.assets(
      context.queryKey[2] as number | undefined,       context.queryKey[3] as number | undefined,       context.queryKey[4] as number | undefined,       context.queryKey[5] as string | undefined,       context.queryKey[6] as boolean | undefined,       context.queryKey[7] as Types.LogicalOperator | undefined,       context.queryKey[8] as Types.FilterCondition[] | undefined,       context.queryKey[9] as Types.FilterGroup[] | undefined,axiosConfig    );
}

export function useAssetsQuery<TSelectData = Types.AssetDtoQueryResponse, TError = unknown>(dto: AssetsQueryParameters, options?: Omit<UseQueryOptions<Types.AssetDtoQueryResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function useAssetsQuery<TSelectData = Types.AssetDtoQueryResponse, TError = unknown>(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined, options?: Omit<UseQueryOptions<Types.AssetDtoQueryResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useAssetsQuery<TSelectData = Types.AssetDtoQueryResponse, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.AssetDtoQueryResponse, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let pageNumber: any = undefined;
  let pageSize: any = undefined;
  let totalCount: any = undefined;
  let sort_SortBy: any = undefined;
  let sort_Ascending: any = undefined;
  let filter_Logic: any = undefined;
  let filter_Conditions: any = undefined;
  let filter_Groups: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups,  } = params[0] as AssetsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.AssetDtoQueryResponse, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __assets(context, axiosConfig) : __assets,
    queryKey: assetsQueryKey(pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups),
    ...assetsDefaultOptions as unknown as Omit<UseQueryOptions<Types.AssetDtoQueryResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function setAssetsData(queryClient: QueryClient, updater: (data: Types.AssetDtoQueryResponse | undefined) => Types.AssetDtoQueryResponse, pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined) {
  queryClient.setQueryData(assetsQueryKey(pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups),
    updater
  );
}

/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function setAssetsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.AssetDtoQueryResponse | undefined) => Types.AssetDtoQueryResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function assets2Url(id: string): string {
  let url_ = getBaseUrl() + "/api/Assets/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let assets2DefaultOptions: Omit<UseQueryOptions<Types.AssetDto, unknown, Types.AssetDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.AssetDto, unknown, Types.AssetDto>, 'queryFn'>> = {
};
export function getAssets2DefaultOptions() {
  return assets2DefaultOptions;
};
export function setAssets2DefaultOptions(options: typeof assets2DefaultOptions) {
  assets2DefaultOptions = options;
}

export function assets2QueryKey(id: string): QueryKey;
export function assets2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as Assets2QueryParameters;

    return trimArrayEnd([
        'Client',
        'assets2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'assets2',
        ...params
      ]);
  }
}
export function __assets2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.assets2(
      context.queryKey[2] as string,axiosConfig    );
}

export function useAssets2Query<TSelectData = Types.AssetDto, TError = unknown>(dto: Assets2QueryParameters, options?: Omit<UseQueryOptions<Types.AssetDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useAssets2Query<TSelectData = Types.AssetDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.AssetDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useAssets2Query<TSelectData = Types.AssetDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.AssetDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as Assets2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.AssetDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __assets2(context, axiosConfig) : __assets2,
    queryKey: assets2QueryKey(id),
    ...assets2DefaultOptions as unknown as Omit<UseQueryOptions<Types.AssetDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setAssets2Data(queryClient: QueryClient, updater: (data: Types.AssetDto | undefined) => Types.AssetDto, id: string) {
  queryClient.setQueryData(assets2QueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setAssets2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.AssetDto | undefined) => Types.AssetDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function authorizationProfilesGETUrl(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined): string {
  let url_ = getBaseUrl() + "/api/AuthorizationProfiles?";
if (pageNumber === null)
    throw new Error("The parameter 'pageNumber' cannot be null.");
else if (pageNumber !== undefined)
    url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
if (totalCount === null)
    throw new Error("The parameter 'totalCount' cannot be null.");
else if (totalCount !== undefined)
    url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&";
if (sort_SortBy === null)
    throw new Error("The parameter 'sort_SortBy' cannot be null.");
else if (sort_SortBy !== undefined)
    url_ += "Sort.SortBy=" + encodeURIComponent("" + sort_SortBy) + "&";
if (sort_Ascending === null)
    throw new Error("The parameter 'sort_Ascending' cannot be null.");
else if (sort_Ascending !== undefined)
    url_ += "Sort.Ascending=" + encodeURIComponent("" + sort_Ascending) + "&";
if (filter_Logic === null)
    throw new Error("The parameter 'filter_Logic' cannot be null.");
else if (filter_Logic !== undefined)
    url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&";
if (filter_Conditions === null)
    throw new Error("The parameter 'filter_Conditions' cannot be null.");
else if (filter_Conditions !== undefined)
    filter_Conditions && filter_Conditions.forEach((item, index) => {
        for (let attr in item)
			if (item.hasOwnProperty(attr)) {
				url_ += "Filter.Conditions[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
			}
    });
if (filter_Groups === null)
    throw new Error("The parameter 'filter_Groups' cannot be null.");
else if (filter_Groups !== undefined)
    filter_Groups && filter_Groups.forEach((item, index) => {
        for (let attr in item)
			if (item.hasOwnProperty(attr)) {
				url_ += "Filter.Groups[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
			}
    });
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let authorizationProfilesGETDefaultOptions: Omit<UseQueryOptions<Types.AuthorizationProfileDtoQueryResponse, unknown, Types.AuthorizationProfileDtoQueryResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.AuthorizationProfileDtoQueryResponse, unknown, Types.AuthorizationProfileDtoQueryResponse>, 'queryFn'>> = {
};
export function getAuthorizationProfilesGETDefaultOptions() {
  return authorizationProfilesGETDefaultOptions;
};
export function setAuthorizationProfilesGETDefaultOptions(options: typeof authorizationProfilesGETDefaultOptions) {
  authorizationProfilesGETDefaultOptions = options;
}

export function authorizationProfilesGETQueryKey(dto: AuthorizationProfilesGETQueryParameters): QueryKey;
export function authorizationProfilesGETQueryKey(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined): QueryKey;
export function authorizationProfilesGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups,  } = params[0] as AuthorizationProfilesGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'authorizationProfilesGET',
        pageNumber as any,
        pageSize as any,
        totalCount as any,
        sort_SortBy as any,
        sort_Ascending as any,
        filter_Logic as any,
        filter_Conditions as any,
        filter_Groups as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'authorizationProfilesGET',
        ...params
      ]);
  }
}
export function __authorizationProfilesGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.authorizationProfilesGET(
      context.queryKey[2] as number | undefined,       context.queryKey[3] as number | undefined,       context.queryKey[4] as number | undefined,       context.queryKey[5] as string | undefined,       context.queryKey[6] as boolean | undefined,       context.queryKey[7] as Types.LogicalOperator | undefined,       context.queryKey[8] as Types.FilterCondition[] | undefined,       context.queryKey[9] as Types.FilterGroup[] | undefined,axiosConfig    );
}

export function useAuthorizationProfilesGETQuery<TSelectData = Types.AuthorizationProfileDtoQueryResponse, TError = unknown>(dto: AuthorizationProfilesGETQueryParameters, options?: Omit<UseQueryOptions<Types.AuthorizationProfileDtoQueryResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function useAuthorizationProfilesGETQuery<TSelectData = Types.AuthorizationProfileDtoQueryResponse, TError = unknown>(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined, options?: Omit<UseQueryOptions<Types.AuthorizationProfileDtoQueryResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useAuthorizationProfilesGETQuery<TSelectData = Types.AuthorizationProfileDtoQueryResponse, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.AuthorizationProfileDtoQueryResponse, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let pageNumber: any = undefined;
  let pageSize: any = undefined;
  let totalCount: any = undefined;
  let sort_SortBy: any = undefined;
  let sort_Ascending: any = undefined;
  let filter_Logic: any = undefined;
  let filter_Conditions: any = undefined;
  let filter_Groups: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups,  } = params[0] as AuthorizationProfilesGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.AuthorizationProfileDtoQueryResponse, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __authorizationProfilesGET(context, axiosConfig) : __authorizationProfilesGET,
    queryKey: authorizationProfilesGETQueryKey(pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups),
    ...authorizationProfilesGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.AuthorizationProfileDtoQueryResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function setAuthorizationProfilesGETData(queryClient: QueryClient, updater: (data: Types.AuthorizationProfileDtoQueryResponse | undefined) => Types.AuthorizationProfileDtoQueryResponse, pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined) {
  queryClient.setQueryData(authorizationProfilesGETQueryKey(pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups),
    updater
  );
}

/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function setAuthorizationProfilesGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.AuthorizationProfileDtoQueryResponse | undefined) => Types.AuthorizationProfileDtoQueryResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function authorizationProfilesPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/AuthorizationProfiles";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function authorizationProfilesPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'authorizationProfilesPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useAuthorizationProfilesPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.AuthorizationProfileDto, unknown, Types.AuthorizationProfileDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.AuthorizationProfileDto, unknown, Types.AuthorizationProfileDto, TContext> {
  const key = authorizationProfilesPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.AuthorizationProfileDto) => Client.authorizationProfilesPOST(body),
    mutationKey: key,
  });
}
  
export function authorizationProfilesGET2Url(id: string): string {
  let url_ = getBaseUrl() + "/api/AuthorizationProfiles/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let authorizationProfilesGET2DefaultOptions: Omit<UseQueryOptions<Types.AuthorizationProfileDto, unknown, Types.AuthorizationProfileDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.AuthorizationProfileDto, unknown, Types.AuthorizationProfileDto>, 'queryFn'>> = {
};
export function getAuthorizationProfilesGET2DefaultOptions() {
  return authorizationProfilesGET2DefaultOptions;
};
export function setAuthorizationProfilesGET2DefaultOptions(options: typeof authorizationProfilesGET2DefaultOptions) {
  authorizationProfilesGET2DefaultOptions = options;
}

export function authorizationProfilesGET2QueryKey(id: string): QueryKey;
export function authorizationProfilesGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as AuthorizationProfilesGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'authorizationProfilesGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'authorizationProfilesGET2',
        ...params
      ]);
  }
}
export function __authorizationProfilesGET2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.authorizationProfilesGET2(
      context.queryKey[2] as string,axiosConfig    );
}

export function useAuthorizationProfilesGET2Query<TSelectData = Types.AuthorizationProfileDto, TError = unknown>(dto: AuthorizationProfilesGET2QueryParameters, options?: Omit<UseQueryOptions<Types.AuthorizationProfileDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useAuthorizationProfilesGET2Query<TSelectData = Types.AuthorizationProfileDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.AuthorizationProfileDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useAuthorizationProfilesGET2Query<TSelectData = Types.AuthorizationProfileDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.AuthorizationProfileDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as AuthorizationProfilesGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.AuthorizationProfileDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __authorizationProfilesGET2(context, axiosConfig) : __authorizationProfilesGET2,
    queryKey: authorizationProfilesGET2QueryKey(id),
    ...authorizationProfilesGET2DefaultOptions as unknown as Omit<UseQueryOptions<Types.AuthorizationProfileDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setAuthorizationProfilesGET2Data(queryClient: QueryClient, updater: (data: Types.AuthorizationProfileDto | undefined) => Types.AuthorizationProfileDto, id: string) {
  queryClient.setQueryData(authorizationProfilesGET2QueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setAuthorizationProfilesGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.AuthorizationProfileDto | undefined) => Types.AuthorizationProfileDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function companiesGETUrl(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined): string {
  let url_ = getBaseUrl() + "/api/Companies?";
if (pageNumber === null)
    throw new Error("The parameter 'pageNumber' cannot be null.");
else if (pageNumber !== undefined)
    url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
if (totalCount === null)
    throw new Error("The parameter 'totalCount' cannot be null.");
else if (totalCount !== undefined)
    url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&";
if (sort_SortBy === null)
    throw new Error("The parameter 'sort_SortBy' cannot be null.");
else if (sort_SortBy !== undefined)
    url_ += "Sort.SortBy=" + encodeURIComponent("" + sort_SortBy) + "&";
if (sort_Ascending === null)
    throw new Error("The parameter 'sort_Ascending' cannot be null.");
else if (sort_Ascending !== undefined)
    url_ += "Sort.Ascending=" + encodeURIComponent("" + sort_Ascending) + "&";
if (filter_Logic === null)
    throw new Error("The parameter 'filter_Logic' cannot be null.");
else if (filter_Logic !== undefined)
    url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&";
if (filter_Conditions === null)
    throw new Error("The parameter 'filter_Conditions' cannot be null.");
else if (filter_Conditions !== undefined)
    filter_Conditions && filter_Conditions.forEach((item, index) => {
        for (let attr in item)
			if (item.hasOwnProperty(attr)) {
				url_ += "Filter.Conditions[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
			}
    });
if (filter_Groups === null)
    throw new Error("The parameter 'filter_Groups' cannot be null.");
else if (filter_Groups !== undefined)
    filter_Groups && filter_Groups.forEach((item, index) => {
        for (let attr in item)
			if (item.hasOwnProperty(attr)) {
				url_ += "Filter.Groups[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
			}
    });
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let companiesGETDefaultOptions: Omit<UseQueryOptions<Types.CompanyDtoQueryResponse, unknown, Types.CompanyDtoQueryResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.CompanyDtoQueryResponse, unknown, Types.CompanyDtoQueryResponse>, 'queryFn'>> = {
};
export function getCompaniesGETDefaultOptions() {
  return companiesGETDefaultOptions;
};
export function setCompaniesGETDefaultOptions(options: typeof companiesGETDefaultOptions) {
  companiesGETDefaultOptions = options;
}

export function companiesGETQueryKey(dto: CompaniesGETQueryParameters): QueryKey;
export function companiesGETQueryKey(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined): QueryKey;
export function companiesGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups,  } = params[0] as CompaniesGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'companiesGET',
        pageNumber as any,
        pageSize as any,
        totalCount as any,
        sort_SortBy as any,
        sort_Ascending as any,
        filter_Logic as any,
        filter_Conditions as any,
        filter_Groups as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'companiesGET',
        ...params
      ]);
  }
}
export function __companiesGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.companiesGET(
      context.queryKey[2] as number | undefined,       context.queryKey[3] as number | undefined,       context.queryKey[4] as number | undefined,       context.queryKey[5] as string | undefined,       context.queryKey[6] as boolean | undefined,       context.queryKey[7] as Types.LogicalOperator | undefined,       context.queryKey[8] as Types.FilterCondition[] | undefined,       context.queryKey[9] as Types.FilterGroup[] | undefined,axiosConfig    );
}

export function useCompaniesGETQuery<TSelectData = Types.CompanyDtoQueryResponse, TError = unknown>(dto: CompaniesGETQueryParameters, options?: Omit<UseQueryOptions<Types.CompanyDtoQueryResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function useCompaniesGETQuery<TSelectData = Types.CompanyDtoQueryResponse, TError = unknown>(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined, options?: Omit<UseQueryOptions<Types.CompanyDtoQueryResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useCompaniesGETQuery<TSelectData = Types.CompanyDtoQueryResponse, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.CompanyDtoQueryResponse, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let pageNumber: any = undefined;
  let pageSize: any = undefined;
  let totalCount: any = undefined;
  let sort_SortBy: any = undefined;
  let sort_Ascending: any = undefined;
  let filter_Logic: any = undefined;
  let filter_Conditions: any = undefined;
  let filter_Groups: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups,  } = params[0] as CompaniesGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.CompanyDtoQueryResponse, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __companiesGET(context, axiosConfig) : __companiesGET,
    queryKey: companiesGETQueryKey(pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups),
    ...companiesGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.CompanyDtoQueryResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function setCompaniesGETData(queryClient: QueryClient, updater: (data: Types.CompanyDtoQueryResponse | undefined) => Types.CompanyDtoQueryResponse, pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined) {
  queryClient.setQueryData(companiesGETQueryKey(pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups),
    updater
  );
}

/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function setCompaniesGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.CompanyDtoQueryResponse | undefined) => Types.CompanyDtoQueryResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function companiesPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/Companies";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function companiesPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'companiesPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useCompaniesPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.CompanyDto, unknown, Types.CompanyDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.CompanyDto, unknown, Types.CompanyDto, TContext> {
  const key = companiesPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.CompanyDto) => Client.companiesPOST(body),
    mutationKey: key,
  });
}
  
export function companiesGET2Url(id: string): string {
  let url_ = getBaseUrl() + "/api/Companies/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let companiesGET2DefaultOptions: Omit<UseQueryOptions<Types.CompanyDto, unknown, Types.CompanyDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.CompanyDto, unknown, Types.CompanyDto>, 'queryFn'>> = {
};
export function getCompaniesGET2DefaultOptions() {
  return companiesGET2DefaultOptions;
};
export function setCompaniesGET2DefaultOptions(options: typeof companiesGET2DefaultOptions) {
  companiesGET2DefaultOptions = options;
}

export function companiesGET2QueryKey(id: string): QueryKey;
export function companiesGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as CompaniesGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'companiesGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'companiesGET2',
        ...params
      ]);
  }
}
export function __companiesGET2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.companiesGET2(
      context.queryKey[2] as string,axiosConfig    );
}

export function useCompaniesGET2Query<TSelectData = Types.CompanyDto, TError = unknown>(dto: CompaniesGET2QueryParameters, options?: Omit<UseQueryOptions<Types.CompanyDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useCompaniesGET2Query<TSelectData = Types.CompanyDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.CompanyDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useCompaniesGET2Query<TSelectData = Types.CompanyDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.CompanyDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as CompaniesGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.CompanyDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __companiesGET2(context, axiosConfig) : __companiesGET2,
    queryKey: companiesGET2QueryKey(id),
    ...companiesGET2DefaultOptions as unknown as Omit<UseQueryOptions<Types.CompanyDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setCompaniesGET2Data(queryClient: QueryClient, updater: (data: Types.CompanyDto | undefined) => Types.CompanyDto, id: string) {
  queryClient.setQueryData(companiesGET2QueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setCompaniesGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.CompanyDto | undefined) => Types.CompanyDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function companiesPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Companies/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function companiesPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'companiesPUT',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useCompaniesPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.CompanyDto, unknown, Types.CompanyDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.CompanyDto, unknown, Types.CompanyDto, TContext> {
  const key = companiesPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.CompanyDto) => Client.companiesPUT(id, body),
    mutationKey: key,
  });
}
  
type CompaniesPUT__MutationParameters = CompaniesPUTQueryParameters & {
  body: Types.CompanyDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useCompaniesPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.CompanyDto, unknown, CompaniesPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: CompaniesPUTQueryParameters}): UseMutationResult<Types.CompanyDto, unknown, CompaniesPUT__MutationParameters, TContext> {
  const key = companiesPUTMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: CompaniesPUT__MutationParameters) => Client.companiesPUT(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function companiesDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Companies/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function companiesDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'companiesDELETE',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useCompaniesDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<boolean, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<boolean, unknown, void, TContext> {
  const key = companiesDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.companiesDELETE(id),
    mutationKey: key,
  });
}
  
type CompaniesDELETE__MutationParameters = CompaniesDELETEQueryParameters

/**
 * @return OK
 */
export function useCompaniesDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<boolean, unknown, CompaniesDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: CompaniesDELETEQueryParameters}): UseMutationResult<boolean, unknown, CompaniesDELETE__MutationParameters, TContext> {
  const key = companiesDELETEMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: CompaniesDELETE__MutationParameters) => Client.companiesDELETE(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function createContactUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Companies/{id}/create-contact";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function createContactMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'createContact',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useCreateContactMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.ContactDto, unknown, Types.ContactDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ContactDto, unknown, Types.ContactDto, TContext> {
  const key = createContactMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ContactDto) => Client.createContact(id, body),
    mutationKey: key,
  });
}
  
type CreateContact__MutationParameters = CreateContactQueryParameters & {
  body: Types.ContactDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useCreateContactMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.ContactDto, unknown, CreateContact__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: CreateContactQueryParameters}): UseMutationResult<Types.ContactDto, unknown, CreateContact__MutationParameters, TContext> {
  const key = createContactMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: CreateContact__MutationParameters) => Client.createContact(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function inviteUserUrl(companyId: string, contactId: string): string {
  let url_ = getBaseUrl() + "/api/Companies/{companyId}/invite-user/{contactId}";
if (companyId === undefined || companyId === null)
  throw new Error("The parameter 'companyId' must be defined.");
url_ = url_.replace("{companyId}", encodeURIComponent("" + companyId));
if (contactId === undefined || contactId === null)
  throw new Error("The parameter 'contactId' must be defined.");
url_ = url_.replace("{contactId}", encodeURIComponent("" + contactId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function inviteUserMutationKey(companyId: string, contactId: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'inviteUser',
      companyId as any,
      contactId as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useInviteUserMutation<TContext>(companyId: string, contactId: string, options?: Omit<UseMutationOptions<boolean, unknown, Types.InviteContactDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<boolean, unknown, Types.InviteContactDto, TContext> {
  const key = inviteUserMutationKey(companyId, contactId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.InviteContactDto) => Client.inviteUser(companyId, contactId, body),
    mutationKey: key,
  });
}
  
type InviteUser__MutationParameters = InviteUserQueryParameters & {
  body: Types.InviteContactDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useInviteUserMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<boolean, unknown, InviteUser__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: InviteUserQueryParameters}): UseMutationResult<boolean, unknown, InviteUser__MutationParameters, TContext> {
  const key = inviteUserMutationKey(options?.parameters?.companyId!, options?.parameters?.contactId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: InviteUser__MutationParameters) => Client.inviteUser(data.companyId ?? options?.parameters?.companyId!, data.contactId ?? options?.parameters?.contactId!, data.body),
  mutationKey: key,
});
}
  
export function configurationGETUrl(): string {
  let url_ = getBaseUrl() + "/api/Configuration";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let configurationGETDefaultOptions: Omit<UseQueryOptions<Types.ConfigurationDtoQueryResponse, unknown, Types.ConfigurationDtoQueryResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ConfigurationDtoQueryResponse, unknown, Types.ConfigurationDtoQueryResponse>, 'queryFn'>> = {
};
export function getConfigurationGETDefaultOptions() {
  return configurationGETDefaultOptions;
};
export function setConfigurationGETDefaultOptions(options: typeof configurationGETDefaultOptions) {
  configurationGETDefaultOptions = options;
}

export function configurationGETQueryKey(body?: Types.QueryPayload | undefined): QueryKey;
export function configurationGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { body,  } = params[0] as ConfigurationGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'configurationGET',
        body as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'configurationGET',
        ...params
      ]);
  }
}
export function __configurationGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.configurationGET(
      context.queryKey[2] as Types.QueryPayload | undefined,axiosConfig    );
}

export function useConfigurationGETQuery<TSelectData = Types.ConfigurationDtoQueryResponse, TError = unknown>(dto: ConfigurationGETQueryParameters, options?: Omit<UseQueryOptions<Types.ConfigurationDtoQueryResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @param body (optional) 
 * @return OK
 */
export function useConfigurationGETQuery<TSelectData = Types.ConfigurationDtoQueryResponse, TError = unknown>(body?: Types.QueryPayload | undefined, options?: Omit<UseQueryOptions<Types.ConfigurationDtoQueryResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useConfigurationGETQuery<TSelectData = Types.ConfigurationDtoQueryResponse, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ConfigurationDtoQueryResponse, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let body: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ body,  } = params[0] as ConfigurationGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [body, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ConfigurationDtoQueryResponse, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __configurationGET(context, axiosConfig) : __configurationGET,
    queryKey: configurationGETQueryKey(body),
    ...configurationGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.ConfigurationDtoQueryResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @param body (optional) 
 * @return OK
 */
export function setConfigurationGETData(queryClient: QueryClient, updater: (data: Types.ConfigurationDtoQueryResponse | undefined) => Types.ConfigurationDtoQueryResponse, body?: Types.QueryPayload | undefined) {
  queryClient.setQueryData(configurationGETQueryKey(body),
    updater
  );
}

/**
 * @param body (optional) 
 * @return OK
 */
export function setConfigurationGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ConfigurationDtoQueryResponse | undefined) => Types.ConfigurationDtoQueryResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function configurationPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/Configuration";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function configurationPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'configurationPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useConfigurationPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.ConfigurationDto, unknown, Types.ConfigurationDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ConfigurationDto, unknown, Types.ConfigurationDto, TContext> {
  const key = configurationPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ConfigurationDto) => Client.configurationPOST(body),
    mutationKey: key,
  });
}
  
export function configurationGET2Url(id: string): string {
  let url_ = getBaseUrl() + "/api/Configuration/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let configurationGET2DefaultOptions: Omit<UseQueryOptions<Types.ConfigurationDto, unknown, Types.ConfigurationDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ConfigurationDto, unknown, Types.ConfigurationDto>, 'queryFn'>> = {
};
export function getConfigurationGET2DefaultOptions() {
  return configurationGET2DefaultOptions;
};
export function setConfigurationGET2DefaultOptions(options: typeof configurationGET2DefaultOptions) {
  configurationGET2DefaultOptions = options;
}

export function configurationGET2QueryKey(id: string): QueryKey;
export function configurationGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as ConfigurationGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'configurationGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'configurationGET2',
        ...params
      ]);
  }
}
export function __configurationGET2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.configurationGET2(
      context.queryKey[2] as string,axiosConfig    );
}

export function useConfigurationGET2Query<TSelectData = Types.ConfigurationDto, TError = unknown>(dto: ConfigurationGET2QueryParameters, options?: Omit<UseQueryOptions<Types.ConfigurationDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useConfigurationGET2Query<TSelectData = Types.ConfigurationDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.ConfigurationDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useConfigurationGET2Query<TSelectData = Types.ConfigurationDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ConfigurationDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as ConfigurationGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ConfigurationDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __configurationGET2(context, axiosConfig) : __configurationGET2,
    queryKey: configurationGET2QueryKey(id),
    ...configurationGET2DefaultOptions as unknown as Omit<UseQueryOptions<Types.ConfigurationDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setConfigurationGET2Data(queryClient: QueryClient, updater: (data: Types.ConfigurationDto | undefined) => Types.ConfigurationDto, id: string) {
  queryClient.setQueryData(configurationGET2QueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setConfigurationGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ConfigurationDto | undefined) => Types.ConfigurationDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function configurationPATCHUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Configuration/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function configurationPATCHMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'configurationPATCH',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useConfigurationPATCHMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.ConfigurationDto, unknown, Types.ConfigurationDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ConfigurationDto, unknown, Types.ConfigurationDto, TContext> {
  const key = configurationPATCHMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ConfigurationDto) => Client.configurationPATCH(id, body),
    mutationKey: key,
  });
}
  
type ConfigurationPATCH__MutationParameters = ConfigurationPATCHQueryParameters & {
  body: Types.ConfigurationDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useConfigurationPATCHMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.ConfigurationDto, unknown, ConfigurationPATCH__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: ConfigurationPATCHQueryParameters}): UseMutationResult<Types.ConfigurationDto, unknown, ConfigurationPATCH__MutationParameters, TContext> {
  const key = configurationPATCHMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: ConfigurationPATCH__MutationParameters) => Client.configurationPATCH(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function configurationPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Configuration/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function configurationPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'configurationPUT',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useConfigurationPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.ConfigurationDto, unknown, Types.ConfigurationDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ConfigurationDto, unknown, Types.ConfigurationDto, TContext> {
  const key = configurationPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ConfigurationDto) => Client.configurationPUT(id, body),
    mutationKey: key,
  });
}
  
type ConfigurationPUT__MutationParameters = ConfigurationPUTQueryParameters & {
  body: Types.ConfigurationDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useConfigurationPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.ConfigurationDto, unknown, ConfigurationPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: ConfigurationPUTQueryParameters}): UseMutationResult<Types.ConfigurationDto, unknown, ConfigurationPUT__MutationParameters, TContext> {
  const key = configurationPUTMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: ConfigurationPUT__MutationParameters) => Client.configurationPUT(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function configurationDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Configuration/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function configurationDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'configurationDELETE',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useConfigurationDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<boolean, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<boolean, unknown, void, TContext> {
  const key = configurationDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.configurationDELETE(id),
    mutationKey: key,
  });
}
  
type ConfigurationDELETE__MutationParameters = ConfigurationDELETEQueryParameters

/**
 * @return OK
 */
export function useConfigurationDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<boolean, unknown, ConfigurationDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: ConfigurationDELETEQueryParameters}): UseMutationResult<boolean, unknown, ConfigurationDELETE__MutationParameters, TContext> {
  const key = configurationDELETEMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: ConfigurationDELETE__MutationParameters) => Client.configurationDELETE(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function consignmentsGETUrl(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined): string {
  let url_ = getBaseUrl() + "/api/Consignments?";
if (pageNumber === null)
    throw new Error("The parameter 'pageNumber' cannot be null.");
else if (pageNumber !== undefined)
    url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
if (totalCount === null)
    throw new Error("The parameter 'totalCount' cannot be null.");
else if (totalCount !== undefined)
    url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&";
if (sort_SortBy === null)
    throw new Error("The parameter 'sort_SortBy' cannot be null.");
else if (sort_SortBy !== undefined)
    url_ += "Sort.SortBy=" + encodeURIComponent("" + sort_SortBy) + "&";
if (sort_Ascending === null)
    throw new Error("The parameter 'sort_Ascending' cannot be null.");
else if (sort_Ascending !== undefined)
    url_ += "Sort.Ascending=" + encodeURIComponent("" + sort_Ascending) + "&";
if (filter_Logic === null)
    throw new Error("The parameter 'filter_Logic' cannot be null.");
else if (filter_Logic !== undefined)
    url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&";
if (filter_Conditions === null)
    throw new Error("The parameter 'filter_Conditions' cannot be null.");
else if (filter_Conditions !== undefined)
    filter_Conditions && filter_Conditions.forEach((item, index) => {
        for (let attr in item)
			if (item.hasOwnProperty(attr)) {
				url_ += "Filter.Conditions[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
			}
    });
if (filter_Groups === null)
    throw new Error("The parameter 'filter_Groups' cannot be null.");
else if (filter_Groups !== undefined)
    filter_Groups && filter_Groups.forEach((item, index) => {
        for (let attr in item)
			if (item.hasOwnProperty(attr)) {
				url_ += "Filter.Groups[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
			}
    });
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let consignmentsGETDefaultOptions: Omit<UseQueryOptions<Types.ConsignmentDtoQueryResponse, unknown, Types.ConsignmentDtoQueryResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ConsignmentDtoQueryResponse, unknown, Types.ConsignmentDtoQueryResponse>, 'queryFn'>> = {
};
export function getConsignmentsGETDefaultOptions() {
  return consignmentsGETDefaultOptions;
};
export function setConsignmentsGETDefaultOptions(options: typeof consignmentsGETDefaultOptions) {
  consignmentsGETDefaultOptions = options;
}

export function consignmentsGETQueryKey(dto: ConsignmentsGETQueryParameters): QueryKey;
export function consignmentsGETQueryKey(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined): QueryKey;
export function consignmentsGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups,  } = params[0] as ConsignmentsGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'consignmentsGET',
        pageNumber as any,
        pageSize as any,
        totalCount as any,
        sort_SortBy as any,
        sort_Ascending as any,
        filter_Logic as any,
        filter_Conditions as any,
        filter_Groups as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'consignmentsGET',
        ...params
      ]);
  }
}
export function __consignmentsGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.consignmentsGET(
      context.queryKey[2] as number | undefined,       context.queryKey[3] as number | undefined,       context.queryKey[4] as number | undefined,       context.queryKey[5] as string | undefined,       context.queryKey[6] as boolean | undefined,       context.queryKey[7] as Types.LogicalOperator | undefined,       context.queryKey[8] as Types.FilterCondition[] | undefined,       context.queryKey[9] as Types.FilterGroup[] | undefined,axiosConfig    );
}

export function useConsignmentsGETQuery<TSelectData = Types.ConsignmentDtoQueryResponse, TError = unknown>(dto: ConsignmentsGETQueryParameters, options?: Omit<UseQueryOptions<Types.ConsignmentDtoQueryResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function useConsignmentsGETQuery<TSelectData = Types.ConsignmentDtoQueryResponse, TError = unknown>(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined, options?: Omit<UseQueryOptions<Types.ConsignmentDtoQueryResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useConsignmentsGETQuery<TSelectData = Types.ConsignmentDtoQueryResponse, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ConsignmentDtoQueryResponse, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let pageNumber: any = undefined;
  let pageSize: any = undefined;
  let totalCount: any = undefined;
  let sort_SortBy: any = undefined;
  let sort_Ascending: any = undefined;
  let filter_Logic: any = undefined;
  let filter_Conditions: any = undefined;
  let filter_Groups: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups,  } = params[0] as ConsignmentsGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ConsignmentDtoQueryResponse, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __consignmentsGET(context, axiosConfig) : __consignmentsGET,
    queryKey: consignmentsGETQueryKey(pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups),
    ...consignmentsGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.ConsignmentDtoQueryResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function setConsignmentsGETData(queryClient: QueryClient, updater: (data: Types.ConsignmentDtoQueryResponse | undefined) => Types.ConsignmentDtoQueryResponse, pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined) {
  queryClient.setQueryData(consignmentsGETQueryKey(pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups),
    updater
  );
}

/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function setConsignmentsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ConsignmentDtoQueryResponse | undefined) => Types.ConsignmentDtoQueryResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function consignmentsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/Consignments";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function consignmentsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'consignmentsPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useConsignmentsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.ConsignmentDto, unknown, Types.ConsignmentDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ConsignmentDto, unknown, Types.ConsignmentDto, TContext> {
  const key = consignmentsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ConsignmentDto) => Client.consignmentsPOST(body),
    mutationKey: key,
  });
}
  
export function consignmentsGET2Url(id: string): string {
  let url_ = getBaseUrl() + "/api/Consignments/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let consignmentsGET2DefaultOptions: Omit<UseQueryOptions<Types.ConsignmentDto, unknown, Types.ConsignmentDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ConsignmentDto, unknown, Types.ConsignmentDto>, 'queryFn'>> = {
};
export function getConsignmentsGET2DefaultOptions() {
  return consignmentsGET2DefaultOptions;
};
export function setConsignmentsGET2DefaultOptions(options: typeof consignmentsGET2DefaultOptions) {
  consignmentsGET2DefaultOptions = options;
}

export function consignmentsGET2QueryKey(id: string): QueryKey;
export function consignmentsGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as ConsignmentsGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'consignmentsGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'consignmentsGET2',
        ...params
      ]);
  }
}
export function __consignmentsGET2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.consignmentsGET2(
      context.queryKey[2] as string,axiosConfig    );
}

export function useConsignmentsGET2Query<TSelectData = Types.ConsignmentDto, TError = unknown>(dto: ConsignmentsGET2QueryParameters, options?: Omit<UseQueryOptions<Types.ConsignmentDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useConsignmentsGET2Query<TSelectData = Types.ConsignmentDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.ConsignmentDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useConsignmentsGET2Query<TSelectData = Types.ConsignmentDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ConsignmentDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as ConsignmentsGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ConsignmentDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __consignmentsGET2(context, axiosConfig) : __consignmentsGET2,
    queryKey: consignmentsGET2QueryKey(id),
    ...consignmentsGET2DefaultOptions as unknown as Omit<UseQueryOptions<Types.ConsignmentDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setConsignmentsGET2Data(queryClient: QueryClient, updater: (data: Types.ConsignmentDto | undefined) => Types.ConsignmentDto, id: string) {
  queryClient.setQueryData(consignmentsGET2QueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setConsignmentsGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ConsignmentDto | undefined) => Types.ConsignmentDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function consignmentsPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Consignments/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function consignmentsPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'consignmentsPUT',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useConsignmentsPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.ConsignmentDto, unknown, Types.ConsignmentDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ConsignmentDto, unknown, Types.ConsignmentDto, TContext> {
  const key = consignmentsPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ConsignmentDto) => Client.consignmentsPUT(id, body),
    mutationKey: key,
  });
}
  
type ConsignmentsPUT__MutationParameters = ConsignmentsPUTQueryParameters & {
  body: Types.ConsignmentDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useConsignmentsPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.ConsignmentDto, unknown, ConsignmentsPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: ConsignmentsPUTQueryParameters}): UseMutationResult<Types.ConsignmentDto, unknown, ConsignmentsPUT__MutationParameters, TContext> {
  const key = consignmentsPUTMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: ConsignmentsPUT__MutationParameters) => Client.consignmentsPUT(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function consignmentsDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Consignments/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function consignmentsDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'consignmentsDELETE',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useConsignmentsDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<boolean, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<boolean, unknown, void, TContext> {
  const key = consignmentsDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.consignmentsDELETE(id),
    mutationKey: key,
  });
}
  
type ConsignmentsDELETE__MutationParameters = ConsignmentsDELETEQueryParameters

/**
 * @return OK
 */
export function useConsignmentsDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<boolean, unknown, ConsignmentsDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: ConsignmentsDELETEQueryParameters}): UseMutationResult<boolean, unknown, ConsignmentsDELETE__MutationParameters, TContext> {
  const key = consignmentsDELETEMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: ConsignmentsDELETE__MutationParameters) => Client.consignmentsDELETE(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function validateAddressUrl(address?: string | undefined): string {
  let url_ = getBaseUrl() + "/api/Consignments/validate-address?";
if (address === null)
    throw new Error("The parameter 'address' cannot be null.");
else if (address !== undefined)
    url_ += "address=" + encodeURIComponent("" + address) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function validateAddressMutationKey(address?: string | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'validateAddress',
      address as any,
    ]);
}

/**
 * @param address (optional) 
 * @return OK
 */
export function useValidateAddressMutation<TContext>(address?: string | undefined, options?: Omit<UseMutationOptions<boolean, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<boolean, unknown, void, TContext> {
  const key = validateAddressMutationKey(address);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.validateAddress(address),
    mutationKey: key,
  });
}
  
type ValidateAddress__MutationParameters = ValidateAddressQueryParameters

/**
 * @param address (optional) 
 * @return OK
 */
export function useValidateAddressMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<boolean, unknown, ValidateAddress__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: ValidateAddressQueryParameters}): UseMutationResult<boolean, unknown, ValidateAddress__MutationParameters, TContext> {
  const key = validateAddressMutationKey(options?.parameters?.address!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: ValidateAddress__MutationParameters) => Client.validateAddress(data.address ?? options?.parameters?.address!),
  mutationKey: key,
});
}
  
export function updateStatusUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Consignments/update-status/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function updateStatusMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'updateStatus',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useUpdateStatusMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.ConsignmentDto, unknown, Types.ConsignmentStatusUpdateDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ConsignmentDto, unknown, Types.ConsignmentStatusUpdateDto, TContext> {
  const key = updateStatusMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ConsignmentStatusUpdateDto) => Client.updateStatus(id, body),
    mutationKey: key,
  });
}
  
type UpdateStatus__MutationParameters = UpdateStatusQueryParameters & {
  body: Types.ConsignmentStatusUpdateDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useUpdateStatusMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.ConsignmentDto, unknown, UpdateStatus__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: UpdateStatusQueryParameters}): UseMutationResult<Types.ConsignmentDto, unknown, UpdateStatus__MutationParameters, TContext> {
  const key = updateStatusMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: UpdateStatus__MutationParameters) => Client.updateStatus(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function uploadPodUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Consignments/upload-pod/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function uploadPodMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'uploadPod',
      id as any,
    ]);
}

/**
 * @param file (optional) 
 * @return OK
 */
export function useUploadPodMutation<TContext>(id: string, options?: Omit<UseMutationOptions<boolean, unknown, UploadPodMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<boolean, unknown, UploadPodMutationParameters, TContext> {
  const key = uploadPodMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (uploadPodMutationParameters: UploadPodMutationParameters) => Client.uploadPod(id, uploadPodMutationParameters.file),
    mutationKey: key,
  });
}
  
type UploadPod__MutationParameters = UploadPodQueryParameters & {
  uploadPodMutationParameters: UploadPodMutationParameters;
}

/**
 * @param file (optional) 
 * @return OK
 */
export function useUploadPodMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<boolean, unknown, UploadPod__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: UploadPodQueryParameters}): UseMutationResult<boolean, unknown, UploadPod__MutationParameters, TContext> {
  const key = uploadPodMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options, 
    mutationFn: (data: UploadPod__MutationParameters) => Client.uploadPod(data.id, data.file),
    mutationKey: key,
  });
}
  
export function downloadPodUrl(id: string, assetId: string): string {
  let url_ = getBaseUrl() + "/api/Consignments/download-pod/{id}/{assetId}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
if (assetId === undefined || assetId === null)
  throw new Error("The parameter 'assetId' must be defined.");
url_ = url_.replace("{assetId}", encodeURIComponent("" + assetId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let downloadPodDefaultOptions: Omit<UseQueryOptions<void, unknown, void>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<void, unknown, void>, 'queryFn'>> = {
};
export function getDownloadPodDefaultOptions() {
  return downloadPodDefaultOptions;
};
export function setDownloadPodDefaultOptions(options: typeof downloadPodDefaultOptions) {
  downloadPodDefaultOptions = options;
}

export function downloadPodQueryKey(dto: DownloadPodQueryParameters): QueryKey;
export function downloadPodQueryKey(id: string, assetId: string): QueryKey;
export function downloadPodQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id, assetId,  } = params[0] as DownloadPodQueryParameters;

    return trimArrayEnd([
        'Client',
        'downloadPod',
        id as any,
        assetId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'downloadPod',
        ...params
      ]);
  }
}
export function __downloadPod(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.downloadPod(
      context.queryKey[2] as string,       context.queryKey[3] as string,axiosConfig    );
}

export function useDownloadPodQuery<TSelectData = void, TError = unknown>(dto: DownloadPodQueryParameters, options?: Omit<UseQueryOptions<void, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useDownloadPodQuery<TSelectData = void, TError = unknown>(id: string, assetId: string, options?: Omit<UseQueryOptions<void, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useDownloadPodQuery<TSelectData = void, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<void, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  let assetId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id, assetId,  } = params[0] as DownloadPodQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, assetId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<void, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __downloadPod(context, axiosConfig) : __downloadPod,
    queryKey: downloadPodQueryKey(id, assetId),
    ...downloadPodDefaultOptions as unknown as Omit<UseQueryOptions<void, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setDownloadPodData(queryClient: QueryClient, updater: (data: void | undefined) => void, id: string, assetId: string) {
  queryClient.setQueryData(downloadPodQueryKey(id, assetId),
    updater
  );
}

/**
 * @return OK
 */
export function setDownloadPodDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: void | undefined) => void) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function deletePodUrl(id: string, assetId: string): string {
  let url_ = getBaseUrl() + "/api/Consignments/delete-pod/{id}/{assetId}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
if (assetId === undefined || assetId === null)
  throw new Error("The parameter 'assetId' must be defined.");
url_ = url_.replace("{assetId}", encodeURIComponent("" + assetId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function deletePodMutationKey(id: string, assetId: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'deletePod',
      id as any,
      assetId as any,
    ]);
}

/**
 * @return OK
 */
export function useDeletePodMutation<TContext>(id: string, assetId: string, options?: Omit<UseMutationOptions<boolean, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<boolean, unknown, void, TContext> {
  const key = deletePodMutationKey(id, assetId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.deletePod(id, assetId),
    mutationKey: key,
  });
}
  
type DeletePod__MutationParameters = DeletePodQueryParameters

/**
 * @return OK
 */
export function useDeletePodMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<boolean, unknown, DeletePod__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: DeletePodQueryParameters}): UseMutationResult<boolean, unknown, DeletePod__MutationParameters, TContext> {
  const key = deletePodMutationKey(options?.parameters?.id!, options?.parameters?.assetId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: DeletePod__MutationParameters) => Client.deletePod(data.id ?? options?.parameters?.id!, data.assetId ?? options?.parameters?.assetId!),
  mutationKey: key,
});
}
  
export function dashboardsAllUrl(): string {
  let url_ = getBaseUrl() + "/api/layout/Dashboards";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let dashboardsAllDefaultOptions: Omit<UseQueryOptions<Types.DashboardDto[], unknown, Types.DashboardDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.DashboardDto[], unknown, Types.DashboardDto[]>, 'queryFn'>> = {
};
export function getDashboardsAllDefaultOptions() {
  return dashboardsAllDefaultOptions;
};
export function setDashboardsAllDefaultOptions(options: typeof dashboardsAllDefaultOptions) {
  dashboardsAllDefaultOptions = options;
}

export function dashboardsAllQueryKey(): QueryKey;
export function dashboardsAllQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'dashboardsAll',
    ]);
}
export function __dashboardsAll(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.dashboardsAll(
axiosConfig    );
}

/**
 * @return OK
 */
export function useDashboardsAllQuery<TSelectData = Types.DashboardDto[], TError = unknown>(options?: Omit<UseQueryOptions<Types.DashboardDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useDashboardsAllQuery<TSelectData = Types.DashboardDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.DashboardDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.DashboardDto[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __dashboardsAll(context, axiosConfig) : __dashboardsAll,
    queryKey: dashboardsAllQueryKey(),
    ...dashboardsAllDefaultOptions as unknown as Omit<UseQueryOptions<Types.DashboardDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setDashboardsAllData(queryClient: QueryClient, updater: (data: Types.DashboardDto[] | undefined) => Types.DashboardDto[], ) {
  queryClient.setQueryData(dashboardsAllQueryKey(),
    updater
  );
}

/**
 * @return OK
 */
export function setDashboardsAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.DashboardDto[] | undefined) => Types.DashboardDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function dashboardsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/layout/Dashboards";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function dashboardsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'dashboardsPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useDashboardsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.DashboardDto, unknown, Types.DashboardDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DashboardDto, unknown, Types.DashboardDto, TContext> {
  const key = dashboardsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.DashboardDto) => Client.dashboardsPOST(body),
    mutationKey: key,
  });
}
  
export function dashboardsGETUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/Dashboards/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let dashboardsGETDefaultOptions: Omit<UseQueryOptions<Types.DashboardDto, unknown, Types.DashboardDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.DashboardDto, unknown, Types.DashboardDto>, 'queryFn'>> = {
};
export function getDashboardsGETDefaultOptions() {
  return dashboardsGETDefaultOptions;
};
export function setDashboardsGETDefaultOptions(options: typeof dashboardsGETDefaultOptions) {
  dashboardsGETDefaultOptions = options;
}

export function dashboardsGETQueryKey(id: string): QueryKey;
export function dashboardsGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as DashboardsGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'dashboardsGET',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'dashboardsGET',
        ...params
      ]);
  }
}
export function __dashboardsGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.dashboardsGET(
      context.queryKey[2] as string,axiosConfig    );
}

export function useDashboardsGETQuery<TSelectData = Types.DashboardDto, TError = unknown>(dto: DashboardsGETQueryParameters, options?: Omit<UseQueryOptions<Types.DashboardDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useDashboardsGETQuery<TSelectData = Types.DashboardDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.DashboardDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useDashboardsGETQuery<TSelectData = Types.DashboardDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.DashboardDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as DashboardsGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.DashboardDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __dashboardsGET(context, axiosConfig) : __dashboardsGET,
    queryKey: dashboardsGETQueryKey(id),
    ...dashboardsGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.DashboardDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setDashboardsGETData(queryClient: QueryClient, updater: (data: Types.DashboardDto | undefined) => Types.DashboardDto, id: string) {
  queryClient.setQueryData(dashboardsGETQueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setDashboardsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.DashboardDto | undefined) => Types.DashboardDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function dashboardsPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/Dashboards/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function dashboardsPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'dashboardsPUT',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useDashboardsPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.DashboardDto, unknown, Types.DashboardDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DashboardDto, unknown, Types.DashboardDto, TContext> {
  const key = dashboardsPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.DashboardDto) => Client.dashboardsPUT(id, body),
    mutationKey: key,
  });
}
  
type DashboardsPUT__MutationParameters = DashboardsPUTQueryParameters & {
  body: Types.DashboardDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useDashboardsPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.DashboardDto, unknown, DashboardsPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: DashboardsPUTQueryParameters}): UseMutationResult<Types.DashboardDto, unknown, DashboardsPUT__MutationParameters, TContext> {
  const key = dashboardsPUTMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: DashboardsPUT__MutationParameters) => Client.dashboardsPUT(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function dashboardsDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/Dashboards/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function dashboardsDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'dashboardsDELETE',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useDashboardsDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<boolean, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<boolean, unknown, void, TContext> {
  const key = dashboardsDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.dashboardsDELETE(id),
    mutationKey: key,
  });
}
  
type DashboardsDELETE__MutationParameters = DashboardsDELETEQueryParameters

/**
 * @return OK
 */
export function useDashboardsDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<boolean, unknown, DashboardsDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: DashboardsDELETEQueryParameters}): UseMutationResult<boolean, unknown, DashboardsDELETE__MutationParameters, TContext> {
  const key = dashboardsDELETEMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: DashboardsDELETE__MutationParameters) => Client.dashboardsDELETE(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function dataSourcesAllUrl(): string {
  let url_ = getBaseUrl() + "/api/layout/DataSources";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let dataSourcesAllDefaultOptions: Omit<UseQueryOptions<Types.DataSourceDto[], unknown, Types.DataSourceDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.DataSourceDto[], unknown, Types.DataSourceDto[]>, 'queryFn'>> = {
};
export function getDataSourcesAllDefaultOptions() {
  return dataSourcesAllDefaultOptions;
};
export function setDataSourcesAllDefaultOptions(options: typeof dataSourcesAllDefaultOptions) {
  dataSourcesAllDefaultOptions = options;
}

export function dataSourcesAllQueryKey(): QueryKey;
export function dataSourcesAllQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'dataSourcesAll',
    ]);
}
export function __dataSourcesAll(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.dataSourcesAll(
axiosConfig    );
}

/**
 * @return OK
 */
export function useDataSourcesAllQuery<TSelectData = Types.DataSourceDto[], TError = unknown>(options?: Omit<UseQueryOptions<Types.DataSourceDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useDataSourcesAllQuery<TSelectData = Types.DataSourceDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.DataSourceDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.DataSourceDto[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __dataSourcesAll(context, axiosConfig) : __dataSourcesAll,
    queryKey: dataSourcesAllQueryKey(),
    ...dataSourcesAllDefaultOptions as unknown as Omit<UseQueryOptions<Types.DataSourceDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setDataSourcesAllData(queryClient: QueryClient, updater: (data: Types.DataSourceDto[] | undefined) => Types.DataSourceDto[], ) {
  queryClient.setQueryData(dataSourcesAllQueryKey(),
    updater
  );
}

/**
 * @return OK
 */
export function setDataSourcesAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.DataSourceDto[] | undefined) => Types.DataSourceDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function dataSourcesPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/layout/DataSources";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function dataSourcesPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'dataSourcesPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useDataSourcesPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.DataSourceDto, unknown, Types.DataSourceDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DataSourceDto, unknown, Types.DataSourceDto, TContext> {
  const key = dataSourcesPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.DataSourceDto) => Client.dataSourcesPOST(body),
    mutationKey: key,
  });
}
  
export function dataSourcesGETUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/DataSources/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let dataSourcesGETDefaultOptions: Omit<UseQueryOptions<Types.DataSourceDto, unknown, Types.DataSourceDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.DataSourceDto, unknown, Types.DataSourceDto>, 'queryFn'>> = {
};
export function getDataSourcesGETDefaultOptions() {
  return dataSourcesGETDefaultOptions;
};
export function setDataSourcesGETDefaultOptions(options: typeof dataSourcesGETDefaultOptions) {
  dataSourcesGETDefaultOptions = options;
}

export function dataSourcesGETQueryKey(id: string): QueryKey;
export function dataSourcesGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as DataSourcesGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'dataSourcesGET',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'dataSourcesGET',
        ...params
      ]);
  }
}
export function __dataSourcesGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.dataSourcesGET(
      context.queryKey[2] as string,axiosConfig    );
}

export function useDataSourcesGETQuery<TSelectData = Types.DataSourceDto, TError = unknown>(dto: DataSourcesGETQueryParameters, options?: Omit<UseQueryOptions<Types.DataSourceDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useDataSourcesGETQuery<TSelectData = Types.DataSourceDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.DataSourceDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useDataSourcesGETQuery<TSelectData = Types.DataSourceDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.DataSourceDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as DataSourcesGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.DataSourceDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __dataSourcesGET(context, axiosConfig) : __dataSourcesGET,
    queryKey: dataSourcesGETQueryKey(id),
    ...dataSourcesGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.DataSourceDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setDataSourcesGETData(queryClient: QueryClient, updater: (data: Types.DataSourceDto | undefined) => Types.DataSourceDto, id: string) {
  queryClient.setQueryData(dataSourcesGETQueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setDataSourcesGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.DataSourceDto | undefined) => Types.DataSourceDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function dataSourcesPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/DataSources/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function dataSourcesPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'dataSourcesPUT',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useDataSourcesPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.DataSourceDto, unknown, Types.DataSourceDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DataSourceDto, unknown, Types.DataSourceDto, TContext> {
  const key = dataSourcesPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.DataSourceDto) => Client.dataSourcesPUT(id, body),
    mutationKey: key,
  });
}
  
type DataSourcesPUT__MutationParameters = DataSourcesPUTQueryParameters & {
  body: Types.DataSourceDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useDataSourcesPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.DataSourceDto, unknown, DataSourcesPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: DataSourcesPUTQueryParameters}): UseMutationResult<Types.DataSourceDto, unknown, DataSourcesPUT__MutationParameters, TContext> {
  const key = dataSourcesPUTMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: DataSourcesPUT__MutationParameters) => Client.dataSourcesPUT(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function dataSourcesDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/DataSources/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function dataSourcesDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'dataSourcesDELETE',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useDataSourcesDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<boolean, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<boolean, unknown, void, TContext> {
  const key = dataSourcesDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.dataSourcesDELETE(id),
    mutationKey: key,
  });
}
  
type DataSourcesDELETE__MutationParameters = DataSourcesDELETEQueryParameters

/**
 * @return OK
 */
export function useDataSourcesDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<boolean, unknown, DataSourcesDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: DataSourcesDELETEQueryParameters}): UseMutationResult<boolean, unknown, DataSourcesDELETE__MutationParameters, TContext> {
  const key = dataSourcesDELETEMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: DataSourcesDELETE__MutationParameters) => Client.dataSourcesDELETE(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function driversUrl(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined): string {
  let url_ = getBaseUrl() + "/api/Drivers?";
if (pageNumber === null)
    throw new Error("The parameter 'pageNumber' cannot be null.");
else if (pageNumber !== undefined)
    url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
if (totalCount === null)
    throw new Error("The parameter 'totalCount' cannot be null.");
else if (totalCount !== undefined)
    url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&";
if (sort_SortBy === null)
    throw new Error("The parameter 'sort_SortBy' cannot be null.");
else if (sort_SortBy !== undefined)
    url_ += "Sort.SortBy=" + encodeURIComponent("" + sort_SortBy) + "&";
if (sort_Ascending === null)
    throw new Error("The parameter 'sort_Ascending' cannot be null.");
else if (sort_Ascending !== undefined)
    url_ += "Sort.Ascending=" + encodeURIComponent("" + sort_Ascending) + "&";
if (filter_Logic === null)
    throw new Error("The parameter 'filter_Logic' cannot be null.");
else if (filter_Logic !== undefined)
    url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&";
if (filter_Conditions === null)
    throw new Error("The parameter 'filter_Conditions' cannot be null.");
else if (filter_Conditions !== undefined)
    filter_Conditions && filter_Conditions.forEach((item, index) => {
        for (let attr in item)
			if (item.hasOwnProperty(attr)) {
				url_ += "Filter.Conditions[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
			}
    });
if (filter_Groups === null)
    throw new Error("The parameter 'filter_Groups' cannot be null.");
else if (filter_Groups !== undefined)
    filter_Groups && filter_Groups.forEach((item, index) => {
        for (let attr in item)
			if (item.hasOwnProperty(attr)) {
				url_ += "Filter.Groups[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
			}
    });
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let driversDefaultOptions: Omit<UseQueryOptions<Types.EmployeeDtoQueryResponse, unknown, Types.EmployeeDtoQueryResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.EmployeeDtoQueryResponse, unknown, Types.EmployeeDtoQueryResponse>, 'queryFn'>> = {
};
export function getDriversDefaultOptions() {
  return driversDefaultOptions;
};
export function setDriversDefaultOptions(options: typeof driversDefaultOptions) {
  driversDefaultOptions = options;
}

export function driversQueryKey(dto: DriversQueryParameters): QueryKey;
export function driversQueryKey(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined): QueryKey;
export function driversQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups,  } = params[0] as DriversQueryParameters;

    return trimArrayEnd([
        'Client',
        'drivers',
        pageNumber as any,
        pageSize as any,
        totalCount as any,
        sort_SortBy as any,
        sort_Ascending as any,
        filter_Logic as any,
        filter_Conditions as any,
        filter_Groups as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'drivers',
        ...params
      ]);
  }
}
export function __drivers(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.drivers(
      context.queryKey[2] as number | undefined,       context.queryKey[3] as number | undefined,       context.queryKey[4] as number | undefined,       context.queryKey[5] as string | undefined,       context.queryKey[6] as boolean | undefined,       context.queryKey[7] as Types.LogicalOperator | undefined,       context.queryKey[8] as Types.FilterCondition[] | undefined,       context.queryKey[9] as Types.FilterGroup[] | undefined,axiosConfig    );
}

export function useDriversQuery<TSelectData = Types.EmployeeDtoQueryResponse, TError = unknown>(dto: DriversQueryParameters, options?: Omit<UseQueryOptions<Types.EmployeeDtoQueryResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function useDriversQuery<TSelectData = Types.EmployeeDtoQueryResponse, TError = unknown>(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined, options?: Omit<UseQueryOptions<Types.EmployeeDtoQueryResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useDriversQuery<TSelectData = Types.EmployeeDtoQueryResponse, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.EmployeeDtoQueryResponse, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let pageNumber: any = undefined;
  let pageSize: any = undefined;
  let totalCount: any = undefined;
  let sort_SortBy: any = undefined;
  let sort_Ascending: any = undefined;
  let filter_Logic: any = undefined;
  let filter_Conditions: any = undefined;
  let filter_Groups: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups,  } = params[0] as DriversQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.EmployeeDtoQueryResponse, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __drivers(context, axiosConfig) : __drivers,
    queryKey: driversQueryKey(pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups),
    ...driversDefaultOptions as unknown as Omit<UseQueryOptions<Types.EmployeeDtoQueryResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function setDriversData(queryClient: QueryClient, updater: (data: Types.EmployeeDtoQueryResponse | undefined) => Types.EmployeeDtoQueryResponse, pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined) {
  queryClient.setQueryData(driversQueryKey(pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups),
    updater
  );
}

/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function setDriversDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.EmployeeDtoQueryResponse | undefined) => Types.EmployeeDtoQueryResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function drivers2Url(id: string): string {
  let url_ = getBaseUrl() + "/api/Drivers/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let drivers2DefaultOptions: Omit<UseQueryOptions<Types.EmployeeDto, unknown, Types.EmployeeDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.EmployeeDto, unknown, Types.EmployeeDto>, 'queryFn'>> = {
};
export function getDrivers2DefaultOptions() {
  return drivers2DefaultOptions;
};
export function setDrivers2DefaultOptions(options: typeof drivers2DefaultOptions) {
  drivers2DefaultOptions = options;
}

export function drivers2QueryKey(id: string): QueryKey;
export function drivers2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as Drivers2QueryParameters;

    return trimArrayEnd([
        'Client',
        'drivers2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'drivers2',
        ...params
      ]);
  }
}
export function __drivers2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.drivers2(
      context.queryKey[2] as string,axiosConfig    );
}

export function useDrivers2Query<TSelectData = Types.EmployeeDto, TError = unknown>(dto: Drivers2QueryParameters, options?: Omit<UseQueryOptions<Types.EmployeeDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useDrivers2Query<TSelectData = Types.EmployeeDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.EmployeeDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useDrivers2Query<TSelectData = Types.EmployeeDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.EmployeeDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as Drivers2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.EmployeeDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __drivers2(context, axiosConfig) : __drivers2,
    queryKey: drivers2QueryKey(id),
    ...drivers2DefaultOptions as unknown as Omit<UseQueryOptions<Types.EmployeeDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setDrivers2Data(queryClient: QueryClient, updater: (data: Types.EmployeeDto | undefined) => Types.EmployeeDto, id: string) {
  queryClient.setQueryData(drivers2QueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setDrivers2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.EmployeeDto | undefined) => Types.EmployeeDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function recordHistoryUrl(): string {
  let url_ = getBaseUrl() + "/api/Drivers/record-history";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function recordHistoryMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'recordHistory',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useRecordHistoryMutation<TContext>(options?: Omit<UseMutationOptions<Types.EmployeeDto, unknown, Types.DriverHistoryDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.EmployeeDto, unknown, Types.DriverHistoryDto, TContext> {
  const key = recordHistoryMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.DriverHistoryDto) => Client.recordHistory(body),
    mutationKey: key,
  });
}
  
export function getHistoryUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Drivers/get-history/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getHistoryDefaultOptions: Omit<UseQueryOptions<Types.DriverHistoryDto[], unknown, Types.DriverHistoryDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.DriverHistoryDto[], unknown, Types.DriverHistoryDto[]>, 'queryFn'>> = {
};
export function getGetHistoryDefaultOptions() {
  return getHistoryDefaultOptions;
};
export function setGetHistoryDefaultOptions(options: typeof getHistoryDefaultOptions) {
  getHistoryDefaultOptions = options;
}

export function getHistoryQueryKey(id: string): QueryKey;
export function getHistoryQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as GetHistoryQueryParameters;

    return trimArrayEnd([
        'Client',
        'getHistory',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'getHistory',
        ...params
      ]);
  }
}
export function __getHistory(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.getHistory(
      context.queryKey[2] as string,axiosConfig    );
}

export function useGetHistoryQuery<TSelectData = Types.DriverHistoryDto[], TError = unknown>(dto: GetHistoryQueryParameters, options?: Omit<UseQueryOptions<Types.DriverHistoryDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useGetHistoryQuery<TSelectData = Types.DriverHistoryDto[], TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.DriverHistoryDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGetHistoryQuery<TSelectData = Types.DriverHistoryDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.DriverHistoryDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as GetHistoryQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.DriverHistoryDto[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __getHistory(context, axiosConfig) : __getHistory,
    queryKey: getHistoryQueryKey(id),
    ...getHistoryDefaultOptions as unknown as Omit<UseQueryOptions<Types.DriverHistoryDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setGetHistoryData(queryClient: QueryClient, updater: (data: Types.DriverHistoryDto[] | undefined) => Types.DriverHistoryDto[], id: string) {
  queryClient.setQueryData(getHistoryQueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setGetHistoryDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.DriverHistoryDto[] | undefined) => Types.DriverHistoryDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function employeesGETUrl(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined): string {
  let url_ = getBaseUrl() + "/api/Employees?";
if (pageNumber === null)
    throw new Error("The parameter 'pageNumber' cannot be null.");
else if (pageNumber !== undefined)
    url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
if (totalCount === null)
    throw new Error("The parameter 'totalCount' cannot be null.");
else if (totalCount !== undefined)
    url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&";
if (sort_SortBy === null)
    throw new Error("The parameter 'sort_SortBy' cannot be null.");
else if (sort_SortBy !== undefined)
    url_ += "Sort.SortBy=" + encodeURIComponent("" + sort_SortBy) + "&";
if (sort_Ascending === null)
    throw new Error("The parameter 'sort_Ascending' cannot be null.");
else if (sort_Ascending !== undefined)
    url_ += "Sort.Ascending=" + encodeURIComponent("" + sort_Ascending) + "&";
if (filter_Logic === null)
    throw new Error("The parameter 'filter_Logic' cannot be null.");
else if (filter_Logic !== undefined)
    url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&";
if (filter_Conditions === null)
    throw new Error("The parameter 'filter_Conditions' cannot be null.");
else if (filter_Conditions !== undefined)
    filter_Conditions && filter_Conditions.forEach((item, index) => {
        for (let attr in item)
			if (item.hasOwnProperty(attr)) {
				url_ += "Filter.Conditions[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
			}
    });
if (filter_Groups === null)
    throw new Error("The parameter 'filter_Groups' cannot be null.");
else if (filter_Groups !== undefined)
    filter_Groups && filter_Groups.forEach((item, index) => {
        for (let attr in item)
			if (item.hasOwnProperty(attr)) {
				url_ += "Filter.Groups[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
			}
    });
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let employeesGETDefaultOptions: Omit<UseQueryOptions<Types.EmployeeDtoQueryResponse, unknown, Types.EmployeeDtoQueryResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.EmployeeDtoQueryResponse, unknown, Types.EmployeeDtoQueryResponse>, 'queryFn'>> = {
};
export function getEmployeesGETDefaultOptions() {
  return employeesGETDefaultOptions;
};
export function setEmployeesGETDefaultOptions(options: typeof employeesGETDefaultOptions) {
  employeesGETDefaultOptions = options;
}

export function employeesGETQueryKey(dto: EmployeesGETQueryParameters): QueryKey;
export function employeesGETQueryKey(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined): QueryKey;
export function employeesGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups,  } = params[0] as EmployeesGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'employeesGET',
        pageNumber as any,
        pageSize as any,
        totalCount as any,
        sort_SortBy as any,
        sort_Ascending as any,
        filter_Logic as any,
        filter_Conditions as any,
        filter_Groups as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'employeesGET',
        ...params
      ]);
  }
}
export function __employeesGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.employeesGET(
      context.queryKey[2] as number | undefined,       context.queryKey[3] as number | undefined,       context.queryKey[4] as number | undefined,       context.queryKey[5] as string | undefined,       context.queryKey[6] as boolean | undefined,       context.queryKey[7] as Types.LogicalOperator | undefined,       context.queryKey[8] as Types.FilterCondition[] | undefined,       context.queryKey[9] as Types.FilterGroup[] | undefined,axiosConfig    );
}

export function useEmployeesGETQuery<TSelectData = Types.EmployeeDtoQueryResponse, TError = unknown>(dto: EmployeesGETQueryParameters, options?: Omit<UseQueryOptions<Types.EmployeeDtoQueryResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function useEmployeesGETQuery<TSelectData = Types.EmployeeDtoQueryResponse, TError = unknown>(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined, options?: Omit<UseQueryOptions<Types.EmployeeDtoQueryResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useEmployeesGETQuery<TSelectData = Types.EmployeeDtoQueryResponse, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.EmployeeDtoQueryResponse, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let pageNumber: any = undefined;
  let pageSize: any = undefined;
  let totalCount: any = undefined;
  let sort_SortBy: any = undefined;
  let sort_Ascending: any = undefined;
  let filter_Logic: any = undefined;
  let filter_Conditions: any = undefined;
  let filter_Groups: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups,  } = params[0] as EmployeesGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.EmployeeDtoQueryResponse, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __employeesGET(context, axiosConfig) : __employeesGET,
    queryKey: employeesGETQueryKey(pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups),
    ...employeesGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.EmployeeDtoQueryResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function setEmployeesGETData(queryClient: QueryClient, updater: (data: Types.EmployeeDtoQueryResponse | undefined) => Types.EmployeeDtoQueryResponse, pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined) {
  queryClient.setQueryData(employeesGETQueryKey(pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups),
    updater
  );
}

/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function setEmployeesGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.EmployeeDtoQueryResponse | undefined) => Types.EmployeeDtoQueryResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function employeesGET2Url(id: string): string {
  let url_ = getBaseUrl() + "/api/Employees/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let employeesGET2DefaultOptions: Omit<UseQueryOptions<Types.CompanyDto, unknown, Types.CompanyDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.CompanyDto, unknown, Types.CompanyDto>, 'queryFn'>> = {
};
export function getEmployeesGET2DefaultOptions() {
  return employeesGET2DefaultOptions;
};
export function setEmployeesGET2DefaultOptions(options: typeof employeesGET2DefaultOptions) {
  employeesGET2DefaultOptions = options;
}

export function employeesGET2QueryKey(id: string): QueryKey;
export function employeesGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as EmployeesGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'employeesGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'employeesGET2',
        ...params
      ]);
  }
}
export function __employeesGET2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.employeesGET2(
      context.queryKey[2] as string,axiosConfig    );
}

export function useEmployeesGET2Query<TSelectData = Types.CompanyDto, TError = unknown>(dto: EmployeesGET2QueryParameters, options?: Omit<UseQueryOptions<Types.CompanyDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useEmployeesGET2Query<TSelectData = Types.CompanyDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.CompanyDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useEmployeesGET2Query<TSelectData = Types.CompanyDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.CompanyDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as EmployeesGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.CompanyDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __employeesGET2(context, axiosConfig) : __employeesGET2,
    queryKey: employeesGET2QueryKey(id),
    ...employeesGET2DefaultOptions as unknown as Omit<UseQueryOptions<Types.CompanyDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setEmployeesGET2Data(queryClient: QueryClient, updater: (data: Types.CompanyDto | undefined) => Types.CompanyDto, id: string) {
  queryClient.setQueryData(employeesGET2QueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setEmployeesGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.CompanyDto | undefined) => Types.CompanyDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function employeesPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Employees/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function employeesPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'employeesPUT',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useEmployeesPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.EmployeeDto, unknown, Types.EmployeeDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.EmployeeDto, unknown, Types.EmployeeDto, TContext> {
  const key = employeesPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.EmployeeDto) => Client.employeesPUT(id, body),
    mutationKey: key,
  });
}
  
type EmployeesPUT__MutationParameters = EmployeesPUTQueryParameters & {
  body: Types.EmployeeDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useEmployeesPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.EmployeeDto, unknown, EmployeesPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: EmployeesPUTQueryParameters}): UseMutationResult<Types.EmployeeDto, unknown, EmployeesPUT__MutationParameters, TContext> {
  const key = employeesPUTMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: EmployeesPUT__MutationParameters) => Client.employeesPUT(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function deactivateEmployeeUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Employees/{id}/deactivate-employee";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function deactivateEmployeeMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'deactivateEmployee',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useDeactivateEmployeeMutation<TContext>(id: string, options?: Omit<UseMutationOptions<boolean, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<boolean, unknown, void, TContext> {
  const key = deactivateEmployeeMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.deactivateEmployee(id),
    mutationKey: key,
  });
}
  
type DeactivateEmployee__MutationParameters = DeactivateEmployeeQueryParameters

/**
 * @return OK
 */
export function useDeactivateEmployeeMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<boolean, unknown, DeactivateEmployee__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: DeactivateEmployeeQueryParameters}): UseMutationResult<boolean, unknown, DeactivateEmployee__MutationParameters, TContext> {
  const key = deactivateEmployeeMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: DeactivateEmployee__MutationParameters) => Client.deactivateEmployee(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function reactivateEmployeeUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Employees/{id}/reactivate-employee";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let reactivateEmployeeDefaultOptions: Omit<UseQueryOptions<boolean, unknown, boolean>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<boolean, unknown, boolean>, 'queryFn'>> = {
};
export function getReactivateEmployeeDefaultOptions() {
  return reactivateEmployeeDefaultOptions;
};
export function setReactivateEmployeeDefaultOptions(options: typeof reactivateEmployeeDefaultOptions) {
  reactivateEmployeeDefaultOptions = options;
}

export function reactivateEmployeeQueryKey(id: string): QueryKey;
export function reactivateEmployeeQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as ReactivateEmployeeQueryParameters;

    return trimArrayEnd([
        'Client',
        'reactivateEmployee',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'reactivateEmployee',
        ...params
      ]);
  }
}
export function __reactivateEmployee(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.reactivateEmployee(
      context.queryKey[2] as string,axiosConfig    );
}

export function useReactivateEmployeeQuery<TSelectData = boolean, TError = unknown>(dto: ReactivateEmployeeQueryParameters, options?: Omit<UseQueryOptions<boolean, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useReactivateEmployeeQuery<TSelectData = boolean, TError = unknown>(id: string, options?: Omit<UseQueryOptions<boolean, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useReactivateEmployeeQuery<TSelectData = boolean, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<boolean, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as ReactivateEmployeeQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<boolean, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __reactivateEmployee(context, axiosConfig) : __reactivateEmployee,
    queryKey: reactivateEmployeeQueryKey(id),
    ...reactivateEmployeeDefaultOptions as unknown as Omit<UseQueryOptions<boolean, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setReactivateEmployeeData(queryClient: QueryClient, updater: (data: boolean | undefined) => boolean, id: string) {
  queryClient.setQueryData(reactivateEmployeeQueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setReactivateEmployeeDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: boolean | undefined) => boolean) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function deletedEmployeesUrl(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined): string {
  let url_ = getBaseUrl() + "/api/Employees/deleted-employees?";
if (pageNumber === null)
    throw new Error("The parameter 'pageNumber' cannot be null.");
else if (pageNumber !== undefined)
    url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
if (totalCount === null)
    throw new Error("The parameter 'totalCount' cannot be null.");
else if (totalCount !== undefined)
    url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&";
if (sort_SortBy === null)
    throw new Error("The parameter 'sort_SortBy' cannot be null.");
else if (sort_SortBy !== undefined)
    url_ += "Sort.SortBy=" + encodeURIComponent("" + sort_SortBy) + "&";
if (sort_Ascending === null)
    throw new Error("The parameter 'sort_Ascending' cannot be null.");
else if (sort_Ascending !== undefined)
    url_ += "Sort.Ascending=" + encodeURIComponent("" + sort_Ascending) + "&";
if (filter_Logic === null)
    throw new Error("The parameter 'filter_Logic' cannot be null.");
else if (filter_Logic !== undefined)
    url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&";
if (filter_Conditions === null)
    throw new Error("The parameter 'filter_Conditions' cannot be null.");
else if (filter_Conditions !== undefined)
    filter_Conditions && filter_Conditions.forEach((item, index) => {
        for (let attr in item)
			if (item.hasOwnProperty(attr)) {
				url_ += "Filter.Conditions[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
			}
    });
if (filter_Groups === null)
    throw new Error("The parameter 'filter_Groups' cannot be null.");
else if (filter_Groups !== undefined)
    filter_Groups && filter_Groups.forEach((item, index) => {
        for (let attr in item)
			if (item.hasOwnProperty(attr)) {
				url_ += "Filter.Groups[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
			}
    });
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let deletedEmployeesDefaultOptions: Omit<UseQueryOptions<Types.EmployeeDtoQueryResponse, unknown, Types.EmployeeDtoQueryResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.EmployeeDtoQueryResponse, unknown, Types.EmployeeDtoQueryResponse>, 'queryFn'>> = {
};
export function getDeletedEmployeesDefaultOptions() {
  return deletedEmployeesDefaultOptions;
};
export function setDeletedEmployeesDefaultOptions(options: typeof deletedEmployeesDefaultOptions) {
  deletedEmployeesDefaultOptions = options;
}

export function deletedEmployeesQueryKey(dto: DeletedEmployeesQueryParameters): QueryKey;
export function deletedEmployeesQueryKey(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined): QueryKey;
export function deletedEmployeesQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups,  } = params[0] as DeletedEmployeesQueryParameters;

    return trimArrayEnd([
        'Client',
        'deletedEmployees',
        pageNumber as any,
        pageSize as any,
        totalCount as any,
        sort_SortBy as any,
        sort_Ascending as any,
        filter_Logic as any,
        filter_Conditions as any,
        filter_Groups as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'deletedEmployees',
        ...params
      ]);
  }
}
export function __deletedEmployees(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.deletedEmployees(
      context.queryKey[2] as number | undefined,       context.queryKey[3] as number | undefined,       context.queryKey[4] as number | undefined,       context.queryKey[5] as string | undefined,       context.queryKey[6] as boolean | undefined,       context.queryKey[7] as Types.LogicalOperator | undefined,       context.queryKey[8] as Types.FilterCondition[] | undefined,       context.queryKey[9] as Types.FilterGroup[] | undefined,axiosConfig    );
}

export function useDeletedEmployeesQuery<TSelectData = Types.EmployeeDtoQueryResponse, TError = unknown>(dto: DeletedEmployeesQueryParameters, options?: Omit<UseQueryOptions<Types.EmployeeDtoQueryResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function useDeletedEmployeesQuery<TSelectData = Types.EmployeeDtoQueryResponse, TError = unknown>(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined, options?: Omit<UseQueryOptions<Types.EmployeeDtoQueryResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useDeletedEmployeesQuery<TSelectData = Types.EmployeeDtoQueryResponse, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.EmployeeDtoQueryResponse, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let pageNumber: any = undefined;
  let pageSize: any = undefined;
  let totalCount: any = undefined;
  let sort_SortBy: any = undefined;
  let sort_Ascending: any = undefined;
  let filter_Logic: any = undefined;
  let filter_Conditions: any = undefined;
  let filter_Groups: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups,  } = params[0] as DeletedEmployeesQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.EmployeeDtoQueryResponse, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __deletedEmployees(context, axiosConfig) : __deletedEmployees,
    queryKey: deletedEmployeesQueryKey(pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups),
    ...deletedEmployeesDefaultOptions as unknown as Omit<UseQueryOptions<Types.EmployeeDtoQueryResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function setDeletedEmployeesData(queryClient: QueryClient, updater: (data: Types.EmployeeDtoQueryResponse | undefined) => Types.EmployeeDtoQueryResponse, pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined) {
  queryClient.setQueryData(deletedEmployeesQueryKey(pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups),
    updater
  );
}

/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function setDeletedEmployeesDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.EmployeeDtoQueryResponse | undefined) => Types.EmployeeDtoQueryResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function failureReasonsGETUrl(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined): string {
  let url_ = getBaseUrl() + "/api/FailureReasons?";
if (pageNumber === null)
    throw new Error("The parameter 'pageNumber' cannot be null.");
else if (pageNumber !== undefined)
    url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
if (totalCount === null)
    throw new Error("The parameter 'totalCount' cannot be null.");
else if (totalCount !== undefined)
    url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&";
if (sort_SortBy === null)
    throw new Error("The parameter 'sort_SortBy' cannot be null.");
else if (sort_SortBy !== undefined)
    url_ += "Sort.SortBy=" + encodeURIComponent("" + sort_SortBy) + "&";
if (sort_Ascending === null)
    throw new Error("The parameter 'sort_Ascending' cannot be null.");
else if (sort_Ascending !== undefined)
    url_ += "Sort.Ascending=" + encodeURIComponent("" + sort_Ascending) + "&";
if (filter_Logic === null)
    throw new Error("The parameter 'filter_Logic' cannot be null.");
else if (filter_Logic !== undefined)
    url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&";
if (filter_Conditions === null)
    throw new Error("The parameter 'filter_Conditions' cannot be null.");
else if (filter_Conditions !== undefined)
    filter_Conditions && filter_Conditions.forEach((item, index) => {
        for (let attr in item)
			if (item.hasOwnProperty(attr)) {
				url_ += "Filter.Conditions[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
			}
    });
if (filter_Groups === null)
    throw new Error("The parameter 'filter_Groups' cannot be null.");
else if (filter_Groups !== undefined)
    filter_Groups && filter_Groups.forEach((item, index) => {
        for (let attr in item)
			if (item.hasOwnProperty(attr)) {
				url_ += "Filter.Groups[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
			}
    });
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let failureReasonsGETDefaultOptions: Omit<UseQueryOptions<Types.FailureReasonDtoQueryResponse, unknown, Types.FailureReasonDtoQueryResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.FailureReasonDtoQueryResponse, unknown, Types.FailureReasonDtoQueryResponse>, 'queryFn'>> = {
};
export function getFailureReasonsGETDefaultOptions() {
  return failureReasonsGETDefaultOptions;
};
export function setFailureReasonsGETDefaultOptions(options: typeof failureReasonsGETDefaultOptions) {
  failureReasonsGETDefaultOptions = options;
}

export function failureReasonsGETQueryKey(dto: FailureReasonsGETQueryParameters): QueryKey;
export function failureReasonsGETQueryKey(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined): QueryKey;
export function failureReasonsGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups,  } = params[0] as FailureReasonsGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'failureReasonsGET',
        pageNumber as any,
        pageSize as any,
        totalCount as any,
        sort_SortBy as any,
        sort_Ascending as any,
        filter_Logic as any,
        filter_Conditions as any,
        filter_Groups as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'failureReasonsGET',
        ...params
      ]);
  }
}
export function __failureReasonsGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.failureReasonsGET(
      context.queryKey[2] as number | undefined,       context.queryKey[3] as number | undefined,       context.queryKey[4] as number | undefined,       context.queryKey[5] as string | undefined,       context.queryKey[6] as boolean | undefined,       context.queryKey[7] as Types.LogicalOperator | undefined,       context.queryKey[8] as Types.FilterCondition[] | undefined,       context.queryKey[9] as Types.FilterGroup[] | undefined,axiosConfig    );
}

export function useFailureReasonsGETQuery<TSelectData = Types.FailureReasonDtoQueryResponse, TError = unknown>(dto: FailureReasonsGETQueryParameters, options?: Omit<UseQueryOptions<Types.FailureReasonDtoQueryResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function useFailureReasonsGETQuery<TSelectData = Types.FailureReasonDtoQueryResponse, TError = unknown>(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined, options?: Omit<UseQueryOptions<Types.FailureReasonDtoQueryResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useFailureReasonsGETQuery<TSelectData = Types.FailureReasonDtoQueryResponse, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.FailureReasonDtoQueryResponse, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let pageNumber: any = undefined;
  let pageSize: any = undefined;
  let totalCount: any = undefined;
  let sort_SortBy: any = undefined;
  let sort_Ascending: any = undefined;
  let filter_Logic: any = undefined;
  let filter_Conditions: any = undefined;
  let filter_Groups: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups,  } = params[0] as FailureReasonsGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.FailureReasonDtoQueryResponse, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __failureReasonsGET(context, axiosConfig) : __failureReasonsGET,
    queryKey: failureReasonsGETQueryKey(pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups),
    ...failureReasonsGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.FailureReasonDtoQueryResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function setFailureReasonsGETData(queryClient: QueryClient, updater: (data: Types.FailureReasonDtoQueryResponse | undefined) => Types.FailureReasonDtoQueryResponse, pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined) {
  queryClient.setQueryData(failureReasonsGETQueryKey(pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups),
    updater
  );
}

/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function setFailureReasonsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.FailureReasonDtoQueryResponse | undefined) => Types.FailureReasonDtoQueryResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function failureReasonsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/FailureReasons";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function failureReasonsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'failureReasonsPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useFailureReasonsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.FailureReasonDto, unknown, Types.FailureReasonDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.FailureReasonDto, unknown, Types.FailureReasonDto, TContext> {
  const key = failureReasonsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.FailureReasonDto) => Client.failureReasonsPOST(body),
    mutationKey: key,
  });
}
  
export function failureReasonsGET2Url(id: string): string {
  let url_ = getBaseUrl() + "/api/FailureReasons/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let failureReasonsGET2DefaultOptions: Omit<UseQueryOptions<Types.FailureReasonDto, unknown, Types.FailureReasonDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.FailureReasonDto, unknown, Types.FailureReasonDto>, 'queryFn'>> = {
};
export function getFailureReasonsGET2DefaultOptions() {
  return failureReasonsGET2DefaultOptions;
};
export function setFailureReasonsGET2DefaultOptions(options: typeof failureReasonsGET2DefaultOptions) {
  failureReasonsGET2DefaultOptions = options;
}

export function failureReasonsGET2QueryKey(id: string): QueryKey;
export function failureReasonsGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as FailureReasonsGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'failureReasonsGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'failureReasonsGET2',
        ...params
      ]);
  }
}
export function __failureReasonsGET2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.failureReasonsGET2(
      context.queryKey[2] as string,axiosConfig    );
}

export function useFailureReasonsGET2Query<TSelectData = Types.FailureReasonDto, TError = unknown>(dto: FailureReasonsGET2QueryParameters, options?: Omit<UseQueryOptions<Types.FailureReasonDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useFailureReasonsGET2Query<TSelectData = Types.FailureReasonDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.FailureReasonDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useFailureReasonsGET2Query<TSelectData = Types.FailureReasonDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.FailureReasonDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as FailureReasonsGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.FailureReasonDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __failureReasonsGET2(context, axiosConfig) : __failureReasonsGET2,
    queryKey: failureReasonsGET2QueryKey(id),
    ...failureReasonsGET2DefaultOptions as unknown as Omit<UseQueryOptions<Types.FailureReasonDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setFailureReasonsGET2Data(queryClient: QueryClient, updater: (data: Types.FailureReasonDto | undefined) => Types.FailureReasonDto, id: string) {
  queryClient.setQueryData(failureReasonsGET2QueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setFailureReasonsGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.FailureReasonDto | undefined) => Types.FailureReasonDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function failureReasonsPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/FailureReasons/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function failureReasonsPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'failureReasonsPUT',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useFailureReasonsPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.FailureReasonDto, unknown, Types.FailureReasonDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.FailureReasonDto, unknown, Types.FailureReasonDto, TContext> {
  const key = failureReasonsPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.FailureReasonDto) => Client.failureReasonsPUT(id, body),
    mutationKey: key,
  });
}
  
type FailureReasonsPUT__MutationParameters = FailureReasonsPUTQueryParameters & {
  body: Types.FailureReasonDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useFailureReasonsPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.FailureReasonDto, unknown, FailureReasonsPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: FailureReasonsPUTQueryParameters}): UseMutationResult<Types.FailureReasonDto, unknown, FailureReasonsPUT__MutationParameters, TContext> {
  const key = failureReasonsPUTMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: FailureReasonsPUT__MutationParameters) => Client.failureReasonsPUT(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function failureReasonsDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/FailureReasons/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function failureReasonsDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'failureReasonsDELETE',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useFailureReasonsDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<boolean, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<boolean, unknown, void, TContext> {
  const key = failureReasonsDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.failureReasonsDELETE(id),
    mutationKey: key,
  });
}
  
type FailureReasonsDELETE__MutationParameters = FailureReasonsDELETEQueryParameters

/**
 * @return OK
 */
export function useFailureReasonsDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<boolean, unknown, FailureReasonsDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: FailureReasonsDELETEQueryParameters}): UseMutationResult<boolean, unknown, FailureReasonsDELETE__MutationParameters, TContext> {
  const key = failureReasonsDELETEMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: FailureReasonsDELETE__MutationParameters) => Client.failureReasonsDELETE(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function fieldsAllUrl(): string {
  let url_ = getBaseUrl() + "/api/layout/Fields";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let fieldsAllDefaultOptions: Omit<UseQueryOptions<Types.FieldDto[], unknown, Types.FieldDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.FieldDto[], unknown, Types.FieldDto[]>, 'queryFn'>> = {
};
export function getFieldsAllDefaultOptions() {
  return fieldsAllDefaultOptions;
};
export function setFieldsAllDefaultOptions(options: typeof fieldsAllDefaultOptions) {
  fieldsAllDefaultOptions = options;
}

export function fieldsAllQueryKey(): QueryKey;
export function fieldsAllQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'fieldsAll',
    ]);
}
export function __fieldsAll(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.fieldsAll(
axiosConfig    );
}

/**
 * @return OK
 */
export function useFieldsAllQuery<TSelectData = Types.FieldDto[], TError = unknown>(options?: Omit<UseQueryOptions<Types.FieldDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useFieldsAllQuery<TSelectData = Types.FieldDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.FieldDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.FieldDto[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __fieldsAll(context, axiosConfig) : __fieldsAll,
    queryKey: fieldsAllQueryKey(),
    ...fieldsAllDefaultOptions as unknown as Omit<UseQueryOptions<Types.FieldDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setFieldsAllData(queryClient: QueryClient, updater: (data: Types.FieldDto[] | undefined) => Types.FieldDto[], ) {
  queryClient.setQueryData(fieldsAllQueryKey(),
    updater
  );
}

/**
 * @return OK
 */
export function setFieldsAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.FieldDto[] | undefined) => Types.FieldDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function fieldsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/layout/Fields";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function fieldsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'fieldsPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useFieldsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.FieldDto, unknown, Types.FieldDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.FieldDto, unknown, Types.FieldDto, TContext> {
  const key = fieldsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.FieldDto) => Client.fieldsPOST(body),
    mutationKey: key,
  });
}
  
export function fieldsGETUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/Fields/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let fieldsGETDefaultOptions: Omit<UseQueryOptions<Types.FieldDto, unknown, Types.FieldDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.FieldDto, unknown, Types.FieldDto>, 'queryFn'>> = {
};
export function getFieldsGETDefaultOptions() {
  return fieldsGETDefaultOptions;
};
export function setFieldsGETDefaultOptions(options: typeof fieldsGETDefaultOptions) {
  fieldsGETDefaultOptions = options;
}

export function fieldsGETQueryKey(id: string): QueryKey;
export function fieldsGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as FieldsGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'fieldsGET',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'fieldsGET',
        ...params
      ]);
  }
}
export function __fieldsGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.fieldsGET(
      context.queryKey[2] as string,axiosConfig    );
}

export function useFieldsGETQuery<TSelectData = Types.FieldDto, TError = unknown>(dto: FieldsGETQueryParameters, options?: Omit<UseQueryOptions<Types.FieldDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useFieldsGETQuery<TSelectData = Types.FieldDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.FieldDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useFieldsGETQuery<TSelectData = Types.FieldDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.FieldDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as FieldsGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.FieldDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __fieldsGET(context, axiosConfig) : __fieldsGET,
    queryKey: fieldsGETQueryKey(id),
    ...fieldsGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.FieldDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setFieldsGETData(queryClient: QueryClient, updater: (data: Types.FieldDto | undefined) => Types.FieldDto, id: string) {
  queryClient.setQueryData(fieldsGETQueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setFieldsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.FieldDto | undefined) => Types.FieldDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function fieldsPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/Fields/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function fieldsPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'fieldsPUT',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useFieldsPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.FieldDto, unknown, Types.FieldDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.FieldDto, unknown, Types.FieldDto, TContext> {
  const key = fieldsPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.FieldDto) => Client.fieldsPUT(id, body),
    mutationKey: key,
  });
}
  
type FieldsPUT__MutationParameters = FieldsPUTQueryParameters & {
  body: Types.FieldDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useFieldsPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.FieldDto, unknown, FieldsPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: FieldsPUTQueryParameters}): UseMutationResult<Types.FieldDto, unknown, FieldsPUT__MutationParameters, TContext> {
  const key = fieldsPUTMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: FieldsPUT__MutationParameters) => Client.fieldsPUT(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function fieldsDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/Fields/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function fieldsDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'fieldsDELETE',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useFieldsDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<boolean, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<boolean, unknown, void, TContext> {
  const key = fieldsDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.fieldsDELETE(id),
    mutationKey: key,
  });
}
  
type FieldsDELETE__MutationParameters = FieldsDELETEQueryParameters

/**
 * @return OK
 */
export function useFieldsDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<boolean, unknown, FieldsDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: FieldsDELETEQueryParameters}): UseMutationResult<boolean, unknown, FieldsDELETE__MutationParameters, TContext> {
  const key = fieldsDELETEMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: FieldsDELETE__MutationParameters) => Client.fieldsDELETE(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function fullRegistrationUrl(): string {
  let url_ = getBaseUrl() + "/api/Identity/full-registration";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function fullRegistrationMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'fullRegistration',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useFullRegistrationMutation<TContext>(options?: Omit<UseMutationOptions<Types.FullRegistrationResponse, unknown, Types.FullRegistrationDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.FullRegistrationResponse, unknown, Types.FullRegistrationDto, TContext> {
  const key = fullRegistrationMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.FullRegistrationDto) => Client.fullRegistration(body),
    mutationKey: key,
  });
}
  
export function registerOrgUrl(): string {
  let url_ = getBaseUrl() + "/api/Identity/register-org";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function registerOrgMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'registerOrg',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useRegisterOrgMutation<TContext>(options?: Omit<UseMutationOptions<Types.OrgRegistrationResponse, unknown, Types.RegisterNewOrganizationDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.OrgRegistrationResponse, unknown, Types.RegisterNewOrganizationDto, TContext> {
  const key = registerOrgMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.RegisterNewOrganizationDto) => Client.registerOrg(body),
    mutationKey: key,
  });
}
  
export function inviteEmployeeUrl(): string {
  let url_ = getBaseUrl() + "/api/Identity/invite-employee";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function inviteEmployeeMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'inviteEmployee',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useInviteEmployeeMutation<TContext>(options?: Omit<UseMutationOptions<void, unknown, Types.EmployeeInvitationRequestDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.EmployeeInvitationRequestDto, TContext> {
  const key = inviteEmployeeMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.EmployeeInvitationRequestDto) => Client.inviteEmployee(body),
    mutationKey: key,
  });
}
  
export function registerUserUrl(): string {
  let url_ = getBaseUrl() + "/api/Identity/register-user";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function registerUserMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'registerUser',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useRegisterUserMutation<TContext>(options?: Omit<UseMutationOptions<string, unknown, Types.RegisterUserDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<string, unknown, Types.RegisterUserDto, TContext> {
  const key = registerUserMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.RegisterUserDto) => Client.registerUser(body),
    mutationKey: key,
  });
}
  
export function loginUrl(): string {
  let url_ = getBaseUrl() + "/api/Identity/login";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function loginMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'login',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useLoginMutation<TContext>(options?: Omit<UseMutationOptions<Types.LoginResponse, unknown, Types.LoginRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.LoginResponse, unknown, Types.LoginRequest, TContext> {
  const key = loginMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.LoginRequest) => Client.login(body),
    mutationKey: key,
  });
}
  
export function userOrganizationsUrl(): string {
  let url_ = getBaseUrl() + "/api/Identity/user-organizations";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let userOrganizationsDefaultOptions: Omit<UseQueryOptions<Types.OrganizationDetailsDto[], unknown, Types.OrganizationDetailsDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.OrganizationDetailsDto[], unknown, Types.OrganizationDetailsDto[]>, 'queryFn'>> = {
};
export function getUserOrganizationsDefaultOptions() {
  return userOrganizationsDefaultOptions;
};
export function setUserOrganizationsDefaultOptions(options: typeof userOrganizationsDefaultOptions) {
  userOrganizationsDefaultOptions = options;
}

export function userOrganizationsQueryKey(): QueryKey;
export function userOrganizationsQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'userOrganizations',
    ]);
}
export function __userOrganizations(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.userOrganizations(
axiosConfig    );
}

/**
 * @return OK
 */
export function useUserOrganizationsQuery<TSelectData = Types.OrganizationDetailsDto[], TError = unknown>(options?: Omit<UseQueryOptions<Types.OrganizationDetailsDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useUserOrganizationsQuery<TSelectData = Types.OrganizationDetailsDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.OrganizationDetailsDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.OrganizationDetailsDto[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __userOrganizations(context, axiosConfig) : __userOrganizations,
    queryKey: userOrganizationsQueryKey(),
    ...userOrganizationsDefaultOptions as unknown as Omit<UseQueryOptions<Types.OrganizationDetailsDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setUserOrganizationsData(queryClient: QueryClient, updater: (data: Types.OrganizationDetailsDto[] | undefined) => Types.OrganizationDetailsDto[], ) {
  queryClient.setQueryData(userOrganizationsQueryKey(),
    updater
  );
}

/**
 * @return OK
 */
export function setUserOrganizationsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.OrganizationDetailsDto[] | undefined) => Types.OrganizationDetailsDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function orgLoginUrl(): string {
  let url_ = getBaseUrl() + "/api/Identity/org-login";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function orgLoginMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'orgLogin',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useOrgLoginMutation<TContext>(options?: Omit<UseMutationOptions<Types.OrgLoginResponse, unknown, Types.OrgLoginRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.OrgLoginResponse, unknown, Types.OrgLoginRequest, TContext> {
  const key = orgLoginMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.OrgLoginRequest) => Client.orgLogin(body),
    mutationKey: key,
  });
}
  
export function refreshTokenUrl(): string {
  let url_ = getBaseUrl() + "/api/Identity/refresh-token";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function refreshTokenMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'refreshToken',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useRefreshTokenMutation<TContext>(options?: Omit<UseMutationOptions<Types.OrgLoginResponse, unknown, Types.RefreshTokenPayload, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.OrgLoginResponse, unknown, Types.RefreshTokenPayload, TContext> {
  const key = refreshTokenMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.RefreshTokenPayload) => Client.refreshToken(body),
    mutationKey: key,
  });
}
  
export function associateCompaniesUrl(): string {
  let url_ = getBaseUrl() + "/api/Identity/associate-companies";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let associateCompaniesDefaultOptions: Omit<UseQueryOptions<Types.CompanyDto[], unknown, Types.CompanyDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.CompanyDto[], unknown, Types.CompanyDto[]>, 'queryFn'>> = {
};
export function getAssociateCompaniesDefaultOptions() {
  return associateCompaniesDefaultOptions;
};
export function setAssociateCompaniesDefaultOptions(options: typeof associateCompaniesDefaultOptions) {
  associateCompaniesDefaultOptions = options;
}

export function associateCompaniesQueryKey(): QueryKey;
export function associateCompaniesQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'associateCompanies',
    ]);
}
export function __associateCompanies(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.associateCompanies(
axiosConfig    );
}

/**
 * @return OK
 */
export function useAssociateCompaniesQuery<TSelectData = Types.CompanyDto[], TError = unknown>(options?: Omit<UseQueryOptions<Types.CompanyDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useAssociateCompaniesQuery<TSelectData = Types.CompanyDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.CompanyDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.CompanyDto[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __associateCompanies(context, axiosConfig) : __associateCompanies,
    queryKey: associateCompaniesQueryKey(),
    ...associateCompaniesDefaultOptions as unknown as Omit<UseQueryOptions<Types.CompanyDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setAssociateCompaniesData(queryClient: QueryClient, updater: (data: Types.CompanyDto[] | undefined) => Types.CompanyDto[], ) {
  queryClient.setQueryData(associateCompaniesQueryKey(),
    updater
  );
}

/**
 * @return OK
 */
export function setAssociateCompaniesDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.CompanyDto[] | undefined) => Types.CompanyDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function associateLoginUrl(): string {
  let url_ = getBaseUrl() + "/api/Identity/associate-login";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function associateLoginMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'associateLogin',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useAssociateLoginMutation<TContext>(options?: Omit<UseMutationOptions<Types.OrgLoginResponse, unknown, Types.AssociateLoginDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.OrgLoginResponse, unknown, Types.AssociateLoginDto, TContext> {
  const key = associateLoginMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.AssociateLoginDto) => Client.associateLogin(body),
    mutationKey: key,
  });
}
  
export function currentUserUrl(): string {
  let url_ = getBaseUrl() + "/api/Identity/current-user";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let currentUserDefaultOptions: Omit<UseQueryOptions<Types.UserWithOrgDetailsDto, unknown, Types.UserWithOrgDetailsDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.UserWithOrgDetailsDto, unknown, Types.UserWithOrgDetailsDto>, 'queryFn'>> = {
};
export function getCurrentUserDefaultOptions() {
  return currentUserDefaultOptions;
};
export function setCurrentUserDefaultOptions(options: typeof currentUserDefaultOptions) {
  currentUserDefaultOptions = options;
}

export function currentUserQueryKey(): QueryKey;
export function currentUserQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'currentUser',
    ]);
}
export function __currentUser(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.currentUser(
axiosConfig    );
}

/**
 * @return OK
 */
export function useCurrentUserQuery<TSelectData = Types.UserWithOrgDetailsDto, TError = unknown>(options?: Omit<UseQueryOptions<Types.UserWithOrgDetailsDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useCurrentUserQuery<TSelectData = Types.UserWithOrgDetailsDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.UserWithOrgDetailsDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.UserWithOrgDetailsDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __currentUser(context, axiosConfig) : __currentUser,
    queryKey: currentUserQueryKey(),
    ...currentUserDefaultOptions as unknown as Omit<UseQueryOptions<Types.UserWithOrgDetailsDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setCurrentUserData(queryClient: QueryClient, updater: (data: Types.UserWithOrgDetailsDto | undefined) => Types.UserWithOrgDetailsDto, ) {
  queryClient.setQueryData(currentUserQueryKey(),
    updater
  );
}

/**
 * @return OK
 */
export function setCurrentUserDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.UserWithOrgDetailsDto | undefined) => Types.UserWithOrgDetailsDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function organizationUsersUrl(): string {
  let url_ = getBaseUrl() + "/api/Identity/organization-users";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let organizationUsersDefaultOptions: Omit<UseQueryOptions<Types.UserListDto[], unknown, Types.UserListDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.UserListDto[], unknown, Types.UserListDto[]>, 'queryFn'>> = {
};
export function getOrganizationUsersDefaultOptions() {
  return organizationUsersDefaultOptions;
};
export function setOrganizationUsersDefaultOptions(options: typeof organizationUsersDefaultOptions) {
  organizationUsersDefaultOptions = options;
}

export function organizationUsersQueryKey(): QueryKey;
export function organizationUsersQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'organizationUsers',
    ]);
}
export function __organizationUsers(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.organizationUsers(
axiosConfig    );
}

/**
 * @return OK
 */
export function useOrganizationUsersQuery<TSelectData = Types.UserListDto[], TError = unknown>(options?: Omit<UseQueryOptions<Types.UserListDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useOrganizationUsersQuery<TSelectData = Types.UserListDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.UserListDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.UserListDto[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __organizationUsers(context, axiosConfig) : __organizationUsers,
    queryKey: organizationUsersQueryKey(),
    ...organizationUsersDefaultOptions as unknown as Omit<UseQueryOptions<Types.UserListDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setOrganizationUsersData(queryClient: QueryClient, updater: (data: Types.UserListDto[] | undefined) => Types.UserListDto[], ) {
  queryClient.setQueryData(organizationUsersQueryKey(),
    updater
  );
}

/**
 * @return OK
 */
export function setOrganizationUsersDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.UserListDto[] | undefined) => Types.UserListDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function logoutUrl(): string {
  let url_ = getBaseUrl() + "/api/Identity/logout";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function logoutMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'logout',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useLogoutMutation<TContext>(options?: Omit<UseMutationOptions<void, unknown, Types.LogoutRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.LogoutRequest, TContext> {
  const key = logoutMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.LogoutRequest) => Client.logout(body),
    mutationKey: key,
  });
}
  
export function resetPasswordRequestUrl(): string {
  let url_ = getBaseUrl() + "/api/Identity/reset-password-request";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function resetPasswordRequestMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'resetPasswordRequest',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useResetPasswordRequestMutation<TContext>(options?: Omit<UseMutationOptions<void, unknown, Types.ResetPasswordRequest, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.ResetPasswordRequest, TContext> {
  const key = resetPasswordRequestMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ResetPasswordRequest) => Client.resetPasswordRequest(body),
    mutationKey: key,
  });
}
  
export function confirmResetPasswordUrl(): string {
  let url_ = getBaseUrl() + "/api/Identity/confirm-reset-password";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function confirmResetPasswordMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'confirmResetPassword',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useConfirmResetPasswordMutation<TContext>(options?: Omit<UseMutationOptions<void, unknown, Types.ResetPasswordConfirmation, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.ResetPasswordConfirmation, TContext> {
  const key = confirmResetPasswordMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ResetPasswordConfirmation) => Client.confirmResetPassword(body),
    mutationKey: key,
  });
}
  
export function resetPasswordUrl(): string {
  let url_ = getBaseUrl() + "/api/Identity/reset-password";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function resetPasswordMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'resetPassword',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useResetPasswordMutation<TContext>(options?: Omit<UseMutationOptions<void, unknown, Types.ResetPassword, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.ResetPassword, TContext> {
  const key = resetPasswordMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ResetPassword) => Client.resetPassword(body),
    mutationKey: key,
  });
}
  
export function updateUserUrl(): string {
  let url_ = getBaseUrl() + "/api/Identity/update-user";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function updateUserMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'updateUser',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useUpdateUserMutation<TContext>(options?: Omit<UseMutationOptions<void, unknown, Types.UpdateUserDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.UpdateUserDto, TContext> {
  const key = updateUserMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.UpdateUserDto) => Client.updateUser(body),
    mutationKey: key,
  });
}
  
export function deactivateAccountUrl(): string {
  let url_ = getBaseUrl() + "/api/Identity/deactivate-account";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function deactivateAccountMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'deactivateAccount',
    ]);
}

/**
 * @return OK
 */
export function useDeactivateAccountMutation<TContext>(options?: Omit<UseMutationOptions<boolean, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<boolean, unknown, void, TContext> {
  const key = deactivateAccountMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.deactivateAccount(),
    mutationKey: key,
  });
}
  
export function supportedCountriesUrl(): string {
  let url_ = getBaseUrl() + "/api/Identity/supported-countries";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let supportedCountriesDefaultOptions: Omit<UseQueryOptions<Types.CountryDto[], unknown, Types.CountryDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.CountryDto[], unknown, Types.CountryDto[]>, 'queryFn'>> = {
};
export function getSupportedCountriesDefaultOptions() {
  return supportedCountriesDefaultOptions;
};
export function setSupportedCountriesDefaultOptions(options: typeof supportedCountriesDefaultOptions) {
  supportedCountriesDefaultOptions = options;
}

export function supportedCountriesQueryKey(): QueryKey;
export function supportedCountriesQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'supportedCountries',
    ]);
}
export function __supportedCountries(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.supportedCountries(
axiosConfig    );
}

/**
 * @return OK
 */
export function useSupportedCountriesQuery<TSelectData = Types.CountryDto[], TError = unknown>(options?: Omit<UseQueryOptions<Types.CountryDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useSupportedCountriesQuery<TSelectData = Types.CountryDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.CountryDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.CountryDto[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __supportedCountries(context, axiosConfig) : __supportedCountries,
    queryKey: supportedCountriesQueryKey(),
    ...supportedCountriesDefaultOptions as unknown as Omit<UseQueryOptions<Types.CountryDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setSupportedCountriesData(queryClient: QueryClient, updater: (data: Types.CountryDto[] | undefined) => Types.CountryDto[], ) {
  queryClient.setQueryData(supportedCountriesQueryKey(),
    updater
  );
}

/**
 * @return OK
 */
export function setSupportedCountriesDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.CountryDto[] | undefined) => Types.CountryDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function rolesUrl(): string {
  let url_ = getBaseUrl() + "/api/Identity/roles";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let rolesDefaultOptions: Omit<UseQueryOptions<Types.RoleDto[], unknown, Types.RoleDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.RoleDto[], unknown, Types.RoleDto[]>, 'queryFn'>> = {
};
export function getRolesDefaultOptions() {
  return rolesDefaultOptions;
};
export function setRolesDefaultOptions(options: typeof rolesDefaultOptions) {
  rolesDefaultOptions = options;
}

export function rolesQueryKey(): QueryKey;
export function rolesQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'roles',
    ]);
}
export function __roles(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.roles(
axiosConfig    );
}

/**
 * @return OK
 */
export function useRolesQuery<TSelectData = Types.RoleDto[], TError = unknown>(options?: Omit<UseQueryOptions<Types.RoleDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useRolesQuery<TSelectData = Types.RoleDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.RoleDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.RoleDto[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __roles(context, axiosConfig) : __roles,
    queryKey: rolesQueryKey(),
    ...rolesDefaultOptions as unknown as Omit<UseQueryOptions<Types.RoleDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setRolesData(queryClient: QueryClient, updater: (data: Types.RoleDto[] | undefined) => Types.RoleDto[], ) {
  queryClient.setQueryData(rolesQueryKey(),
    updater
  );
}

/**
 * @return OK
 */
export function setRolesDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.RoleDto[] | undefined) => Types.RoleDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function layoutDefinitionsAllUrl(): string {
  let url_ = getBaseUrl() + "/api/layout/LayoutDefinitions";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let layoutDefinitionsAllDefaultOptions: Omit<UseQueryOptions<Types.LayoutDefinitionDto[], unknown, Types.LayoutDefinitionDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.LayoutDefinitionDto[], unknown, Types.LayoutDefinitionDto[]>, 'queryFn'>> = {
};
export function getLayoutDefinitionsAllDefaultOptions() {
  return layoutDefinitionsAllDefaultOptions;
};
export function setLayoutDefinitionsAllDefaultOptions(options: typeof layoutDefinitionsAllDefaultOptions) {
  layoutDefinitionsAllDefaultOptions = options;
}

export function layoutDefinitionsAllQueryKey(): QueryKey;
export function layoutDefinitionsAllQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'layoutDefinitionsAll',
    ]);
}
export function __layoutDefinitionsAll(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.layoutDefinitionsAll(
axiosConfig    );
}

/**
 * @return OK
 */
export function useLayoutDefinitionsAllQuery<TSelectData = Types.LayoutDefinitionDto[], TError = unknown>(options?: Omit<UseQueryOptions<Types.LayoutDefinitionDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useLayoutDefinitionsAllQuery<TSelectData = Types.LayoutDefinitionDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.LayoutDefinitionDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.LayoutDefinitionDto[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __layoutDefinitionsAll(context, axiosConfig) : __layoutDefinitionsAll,
    queryKey: layoutDefinitionsAllQueryKey(),
    ...layoutDefinitionsAllDefaultOptions as unknown as Omit<UseQueryOptions<Types.LayoutDefinitionDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setLayoutDefinitionsAllData(queryClient: QueryClient, updater: (data: Types.LayoutDefinitionDto[] | undefined) => Types.LayoutDefinitionDto[], ) {
  queryClient.setQueryData(layoutDefinitionsAllQueryKey(),
    updater
  );
}

/**
 * @return OK
 */
export function setLayoutDefinitionsAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.LayoutDefinitionDto[] | undefined) => Types.LayoutDefinitionDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function layoutDefinitionsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/layout/LayoutDefinitions";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function layoutDefinitionsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'layoutDefinitionsPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useLayoutDefinitionsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.LayoutDefinitionDto, unknown, Types.LayoutDefinitionDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.LayoutDefinitionDto, unknown, Types.LayoutDefinitionDto, TContext> {
  const key = layoutDefinitionsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.LayoutDefinitionDto) => Client.layoutDefinitionsPOST(body),
    mutationKey: key,
  });
}
  
export function layoutDefinitionsGETUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/LayoutDefinitions/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let layoutDefinitionsGETDefaultOptions: Omit<UseQueryOptions<Types.LayoutDefinitionDto, unknown, Types.LayoutDefinitionDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.LayoutDefinitionDto, unknown, Types.LayoutDefinitionDto>, 'queryFn'>> = {
};
export function getLayoutDefinitionsGETDefaultOptions() {
  return layoutDefinitionsGETDefaultOptions;
};
export function setLayoutDefinitionsGETDefaultOptions(options: typeof layoutDefinitionsGETDefaultOptions) {
  layoutDefinitionsGETDefaultOptions = options;
}

export function layoutDefinitionsGETQueryKey(id: string): QueryKey;
export function layoutDefinitionsGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as LayoutDefinitionsGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'layoutDefinitionsGET',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'layoutDefinitionsGET',
        ...params
      ]);
  }
}
export function __layoutDefinitionsGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.layoutDefinitionsGET(
      context.queryKey[2] as string,axiosConfig    );
}

export function useLayoutDefinitionsGETQuery<TSelectData = Types.LayoutDefinitionDto, TError = unknown>(dto: LayoutDefinitionsGETQueryParameters, options?: Omit<UseQueryOptions<Types.LayoutDefinitionDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useLayoutDefinitionsGETQuery<TSelectData = Types.LayoutDefinitionDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.LayoutDefinitionDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useLayoutDefinitionsGETQuery<TSelectData = Types.LayoutDefinitionDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.LayoutDefinitionDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as LayoutDefinitionsGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.LayoutDefinitionDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __layoutDefinitionsGET(context, axiosConfig) : __layoutDefinitionsGET,
    queryKey: layoutDefinitionsGETQueryKey(id),
    ...layoutDefinitionsGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.LayoutDefinitionDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setLayoutDefinitionsGETData(queryClient: QueryClient, updater: (data: Types.LayoutDefinitionDto | undefined) => Types.LayoutDefinitionDto, id: string) {
  queryClient.setQueryData(layoutDefinitionsGETQueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setLayoutDefinitionsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.LayoutDefinitionDto | undefined) => Types.LayoutDefinitionDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function layoutDefinitionsPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/LayoutDefinitions/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function layoutDefinitionsPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'layoutDefinitionsPUT',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useLayoutDefinitionsPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.LayoutDefinitionDto, unknown, Types.LayoutDefinitionDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.LayoutDefinitionDto, unknown, Types.LayoutDefinitionDto, TContext> {
  const key = layoutDefinitionsPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.LayoutDefinitionDto) => Client.layoutDefinitionsPUT(id, body),
    mutationKey: key,
  });
}
  
type LayoutDefinitionsPUT__MutationParameters = LayoutDefinitionsPUTQueryParameters & {
  body: Types.LayoutDefinitionDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useLayoutDefinitionsPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.LayoutDefinitionDto, unknown, LayoutDefinitionsPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: LayoutDefinitionsPUTQueryParameters}): UseMutationResult<Types.LayoutDefinitionDto, unknown, LayoutDefinitionsPUT__MutationParameters, TContext> {
  const key = layoutDefinitionsPUTMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: LayoutDefinitionsPUT__MutationParameters) => Client.layoutDefinitionsPUT(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function layoutDefinitionsDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/LayoutDefinitions/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function layoutDefinitionsDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'layoutDefinitionsDELETE',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useLayoutDefinitionsDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<boolean, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<boolean, unknown, void, TContext> {
  const key = layoutDefinitionsDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.layoutDefinitionsDELETE(id),
    mutationKey: key,
  });
}
  
type LayoutDefinitionsDELETE__MutationParameters = LayoutDefinitionsDELETEQueryParameters

/**
 * @return OK
 */
export function useLayoutDefinitionsDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<boolean, unknown, LayoutDefinitionsDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: LayoutDefinitionsDELETEQueryParameters}): UseMutationResult<boolean, unknown, LayoutDefinitionsDELETE__MutationParameters, TContext> {
  const key = layoutDefinitionsDELETEMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: LayoutDefinitionsDELETE__MutationParameters) => Client.layoutDefinitionsDELETE(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function layoutParametersAllUrl(): string {
  let url_ = getBaseUrl() + "/api/layout/LayoutParameters";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let layoutParametersAllDefaultOptions: Omit<UseQueryOptions<Types.LayoutParameterDto[], unknown, Types.LayoutParameterDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.LayoutParameterDto[], unknown, Types.LayoutParameterDto[]>, 'queryFn'>> = {
};
export function getLayoutParametersAllDefaultOptions() {
  return layoutParametersAllDefaultOptions;
};
export function setLayoutParametersAllDefaultOptions(options: typeof layoutParametersAllDefaultOptions) {
  layoutParametersAllDefaultOptions = options;
}

export function layoutParametersAllQueryKey(): QueryKey;
export function layoutParametersAllQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'layoutParametersAll',
    ]);
}
export function __layoutParametersAll(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.layoutParametersAll(
axiosConfig    );
}

/**
 * @return OK
 */
export function useLayoutParametersAllQuery<TSelectData = Types.LayoutParameterDto[], TError = unknown>(options?: Omit<UseQueryOptions<Types.LayoutParameterDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useLayoutParametersAllQuery<TSelectData = Types.LayoutParameterDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.LayoutParameterDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.LayoutParameterDto[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __layoutParametersAll(context, axiosConfig) : __layoutParametersAll,
    queryKey: layoutParametersAllQueryKey(),
    ...layoutParametersAllDefaultOptions as unknown as Omit<UseQueryOptions<Types.LayoutParameterDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setLayoutParametersAllData(queryClient: QueryClient, updater: (data: Types.LayoutParameterDto[] | undefined) => Types.LayoutParameterDto[], ) {
  queryClient.setQueryData(layoutParametersAllQueryKey(),
    updater
  );
}

/**
 * @return OK
 */
export function setLayoutParametersAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.LayoutParameterDto[] | undefined) => Types.LayoutParameterDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function layoutParametersPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/layout/LayoutParameters";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function layoutParametersPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'layoutParametersPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useLayoutParametersPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.LayoutParameterDto, unknown, Types.LayoutParameterDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.LayoutParameterDto, unknown, Types.LayoutParameterDto, TContext> {
  const key = layoutParametersPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.LayoutParameterDto) => Client.layoutParametersPOST(body),
    mutationKey: key,
  });
}
  
export function layoutParametersGETUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/LayoutParameters/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let layoutParametersGETDefaultOptions: Omit<UseQueryOptions<Types.LayoutParameterDto, unknown, Types.LayoutParameterDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.LayoutParameterDto, unknown, Types.LayoutParameterDto>, 'queryFn'>> = {
};
export function getLayoutParametersGETDefaultOptions() {
  return layoutParametersGETDefaultOptions;
};
export function setLayoutParametersGETDefaultOptions(options: typeof layoutParametersGETDefaultOptions) {
  layoutParametersGETDefaultOptions = options;
}

export function layoutParametersGETQueryKey(id: string): QueryKey;
export function layoutParametersGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as LayoutParametersGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'layoutParametersGET',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'layoutParametersGET',
        ...params
      ]);
  }
}
export function __layoutParametersGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.layoutParametersGET(
      context.queryKey[2] as string,axiosConfig    );
}

export function useLayoutParametersGETQuery<TSelectData = Types.LayoutParameterDto, TError = unknown>(dto: LayoutParametersGETQueryParameters, options?: Omit<UseQueryOptions<Types.LayoutParameterDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useLayoutParametersGETQuery<TSelectData = Types.LayoutParameterDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.LayoutParameterDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useLayoutParametersGETQuery<TSelectData = Types.LayoutParameterDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.LayoutParameterDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as LayoutParametersGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.LayoutParameterDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __layoutParametersGET(context, axiosConfig) : __layoutParametersGET,
    queryKey: layoutParametersGETQueryKey(id),
    ...layoutParametersGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.LayoutParameterDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setLayoutParametersGETData(queryClient: QueryClient, updater: (data: Types.LayoutParameterDto | undefined) => Types.LayoutParameterDto, id: string) {
  queryClient.setQueryData(layoutParametersGETQueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setLayoutParametersGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.LayoutParameterDto | undefined) => Types.LayoutParameterDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function layoutParametersPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/LayoutParameters/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function layoutParametersPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'layoutParametersPUT',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useLayoutParametersPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.LayoutParameterDto, unknown, Types.LayoutParameterDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.LayoutParameterDto, unknown, Types.LayoutParameterDto, TContext> {
  const key = layoutParametersPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.LayoutParameterDto) => Client.layoutParametersPUT(id, body),
    mutationKey: key,
  });
}
  
type LayoutParametersPUT__MutationParameters = LayoutParametersPUTQueryParameters & {
  body: Types.LayoutParameterDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useLayoutParametersPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.LayoutParameterDto, unknown, LayoutParametersPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: LayoutParametersPUTQueryParameters}): UseMutationResult<Types.LayoutParameterDto, unknown, LayoutParametersPUT__MutationParameters, TContext> {
  const key = layoutParametersPUTMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: LayoutParametersPUT__MutationParameters) => Client.layoutParametersPUT(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function layoutParametersDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/LayoutParameters/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function layoutParametersDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'layoutParametersDELETE',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useLayoutParametersDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<boolean, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<boolean, unknown, void, TContext> {
  const key = layoutParametersDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.layoutParametersDELETE(id),
    mutationKey: key,
  });
}
  
type LayoutParametersDELETE__MutationParameters = LayoutParametersDELETEQueryParameters

/**
 * @return OK
 */
export function useLayoutParametersDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<boolean, unknown, LayoutParametersDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: LayoutParametersDELETEQueryParameters}): UseMutationResult<boolean, unknown, LayoutParametersDELETE__MutationParameters, TContext> {
  const key = layoutParametersDELETEMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: LayoutParametersDELETE__MutationParameters) => Client.layoutParametersDELETE(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function menusAllUrl(): string {
  let url_ = getBaseUrl() + "/api/layout/Menus";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let menusAllDefaultOptions: Omit<UseQueryOptions<Types.MenuDto[], unknown, Types.MenuDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.MenuDto[], unknown, Types.MenuDto[]>, 'queryFn'>> = {
};
export function getMenusAllDefaultOptions() {
  return menusAllDefaultOptions;
};
export function setMenusAllDefaultOptions(options: typeof menusAllDefaultOptions) {
  menusAllDefaultOptions = options;
}

export function menusAllQueryKey(): QueryKey;
export function menusAllQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'menusAll',
    ]);
}
export function __menusAll(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.menusAll(
axiosConfig    );
}

/**
 * @return OK
 */
export function useMenusAllQuery<TSelectData = Types.MenuDto[], TError = unknown>(options?: Omit<UseQueryOptions<Types.MenuDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useMenusAllQuery<TSelectData = Types.MenuDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.MenuDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.MenuDto[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __menusAll(context, axiosConfig) : __menusAll,
    queryKey: menusAllQueryKey(),
    ...menusAllDefaultOptions as unknown as Omit<UseQueryOptions<Types.MenuDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setMenusAllData(queryClient: QueryClient, updater: (data: Types.MenuDto[] | undefined) => Types.MenuDto[], ) {
  queryClient.setQueryData(menusAllQueryKey(),
    updater
  );
}

/**
 * @return OK
 */
export function setMenusAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.MenuDto[] | undefined) => Types.MenuDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function menusPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/layout/Menus";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function menusPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'menusPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useMenusPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.MenuDto, unknown, Types.MenuDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.MenuDto, unknown, Types.MenuDto, TContext> {
  const key = menusPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.MenuDto) => Client.menusPOST(body),
    mutationKey: key,
  });
}
  
export function menusGETUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/Menus/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let menusGETDefaultOptions: Omit<UseQueryOptions<Types.MenuDto, unknown, Types.MenuDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.MenuDto, unknown, Types.MenuDto>, 'queryFn'>> = {
};
export function getMenusGETDefaultOptions() {
  return menusGETDefaultOptions;
};
export function setMenusGETDefaultOptions(options: typeof menusGETDefaultOptions) {
  menusGETDefaultOptions = options;
}

export function menusGETQueryKey(id: string): QueryKey;
export function menusGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as MenusGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'menusGET',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'menusGET',
        ...params
      ]);
  }
}
export function __menusGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.menusGET(
      context.queryKey[2] as string,axiosConfig    );
}

export function useMenusGETQuery<TSelectData = Types.MenuDto, TError = unknown>(dto: MenusGETQueryParameters, options?: Omit<UseQueryOptions<Types.MenuDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useMenusGETQuery<TSelectData = Types.MenuDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.MenuDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useMenusGETQuery<TSelectData = Types.MenuDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.MenuDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as MenusGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.MenuDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __menusGET(context, axiosConfig) : __menusGET,
    queryKey: menusGETQueryKey(id),
    ...menusGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.MenuDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setMenusGETData(queryClient: QueryClient, updater: (data: Types.MenuDto | undefined) => Types.MenuDto, id: string) {
  queryClient.setQueryData(menusGETQueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setMenusGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.MenuDto | undefined) => Types.MenuDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function menusPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/Menus/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function menusPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'menusPUT',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useMenusPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.MenuDto, unknown, Types.MenuDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.MenuDto, unknown, Types.MenuDto, TContext> {
  const key = menusPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.MenuDto) => Client.menusPUT(id, body),
    mutationKey: key,
  });
}
  
type MenusPUT__MutationParameters = MenusPUTQueryParameters & {
  body: Types.MenuDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useMenusPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.MenuDto, unknown, MenusPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: MenusPUTQueryParameters}): UseMutationResult<Types.MenuDto, unknown, MenusPUT__MutationParameters, TContext> {
  const key = menusPUTMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: MenusPUT__MutationParameters) => Client.menusPUT(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function menusDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/Menus/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function menusDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'menusDELETE',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useMenusDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<boolean, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<boolean, unknown, void, TContext> {
  const key = menusDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.menusDELETE(id),
    mutationKey: key,
  });
}
  
type MenusDELETE__MutationParameters = MenusDELETEQueryParameters

/**
 * @return OK
 */
export function useMenusDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<boolean, unknown, MenusDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: MenusDELETEQueryParameters}): UseMutationResult<boolean, unknown, MenusDELETE__MutationParameters, TContext> {
  const key = menusDELETEMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: MenusDELETE__MutationParameters) => Client.menusDELETE(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function moduleButtonsAllUrl(): string {
  let url_ = getBaseUrl() + "/api/layout/ModuleButtons";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let moduleButtonsAllDefaultOptions: Omit<UseQueryOptions<Types.ModuleButtonsDto[], unknown, Types.ModuleButtonsDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ModuleButtonsDto[], unknown, Types.ModuleButtonsDto[]>, 'queryFn'>> = {
};
export function getModuleButtonsAllDefaultOptions() {
  return moduleButtonsAllDefaultOptions;
};
export function setModuleButtonsAllDefaultOptions(options: typeof moduleButtonsAllDefaultOptions) {
  moduleButtonsAllDefaultOptions = options;
}

export function moduleButtonsAllQueryKey(): QueryKey;
export function moduleButtonsAllQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'moduleButtonsAll',
    ]);
}
export function __moduleButtonsAll(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.moduleButtonsAll(
axiosConfig    );
}

/**
 * @return OK
 */
export function useModuleButtonsAllQuery<TSelectData = Types.ModuleButtonsDto[], TError = unknown>(options?: Omit<UseQueryOptions<Types.ModuleButtonsDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useModuleButtonsAllQuery<TSelectData = Types.ModuleButtonsDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ModuleButtonsDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ModuleButtonsDto[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __moduleButtonsAll(context, axiosConfig) : __moduleButtonsAll,
    queryKey: moduleButtonsAllQueryKey(),
    ...moduleButtonsAllDefaultOptions as unknown as Omit<UseQueryOptions<Types.ModuleButtonsDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setModuleButtonsAllData(queryClient: QueryClient, updater: (data: Types.ModuleButtonsDto[] | undefined) => Types.ModuleButtonsDto[], ) {
  queryClient.setQueryData(moduleButtonsAllQueryKey(),
    updater
  );
}

/**
 * @return OK
 */
export function setModuleButtonsAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ModuleButtonsDto[] | undefined) => Types.ModuleButtonsDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function moduleButtonsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/layout/ModuleButtons";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function moduleButtonsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'moduleButtonsPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useModuleButtonsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.ModuleButtonsDto, unknown, Types.ModuleButtonsDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModuleButtonsDto, unknown, Types.ModuleButtonsDto, TContext> {
  const key = moduleButtonsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ModuleButtonsDto) => Client.moduleButtonsPOST(body),
    mutationKey: key,
  });
}
  
export function moduleButtonsGETUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/ModuleButtons/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let moduleButtonsGETDefaultOptions: Omit<UseQueryOptions<Types.ModuleButtonsDto, unknown, Types.ModuleButtonsDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ModuleButtonsDto, unknown, Types.ModuleButtonsDto>, 'queryFn'>> = {
};
export function getModuleButtonsGETDefaultOptions() {
  return moduleButtonsGETDefaultOptions;
};
export function setModuleButtonsGETDefaultOptions(options: typeof moduleButtonsGETDefaultOptions) {
  moduleButtonsGETDefaultOptions = options;
}

export function moduleButtonsGETQueryKey(id: string): QueryKey;
export function moduleButtonsGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as ModuleButtonsGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'moduleButtonsGET',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'moduleButtonsGET',
        ...params
      ]);
  }
}
export function __moduleButtonsGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.moduleButtonsGET(
      context.queryKey[2] as string,axiosConfig    );
}

export function useModuleButtonsGETQuery<TSelectData = Types.ModuleButtonsDto, TError = unknown>(dto: ModuleButtonsGETQueryParameters, options?: Omit<UseQueryOptions<Types.ModuleButtonsDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useModuleButtonsGETQuery<TSelectData = Types.ModuleButtonsDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.ModuleButtonsDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useModuleButtonsGETQuery<TSelectData = Types.ModuleButtonsDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ModuleButtonsDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as ModuleButtonsGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ModuleButtonsDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __moduleButtonsGET(context, axiosConfig) : __moduleButtonsGET,
    queryKey: moduleButtonsGETQueryKey(id),
    ...moduleButtonsGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.ModuleButtonsDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setModuleButtonsGETData(queryClient: QueryClient, updater: (data: Types.ModuleButtonsDto | undefined) => Types.ModuleButtonsDto, id: string) {
  queryClient.setQueryData(moduleButtonsGETQueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setModuleButtonsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ModuleButtonsDto | undefined) => Types.ModuleButtonsDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function moduleButtonsPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/ModuleButtons/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function moduleButtonsPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'moduleButtonsPUT',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useModuleButtonsPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.ModuleButtonsDto, unknown, Types.ModuleButtonsDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModuleButtonsDto, unknown, Types.ModuleButtonsDto, TContext> {
  const key = moduleButtonsPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ModuleButtonsDto) => Client.moduleButtonsPUT(id, body),
    mutationKey: key,
  });
}
  
type ModuleButtonsPUT__MutationParameters = ModuleButtonsPUTQueryParameters & {
  body: Types.ModuleButtonsDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useModuleButtonsPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.ModuleButtonsDto, unknown, ModuleButtonsPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: ModuleButtonsPUTQueryParameters}): UseMutationResult<Types.ModuleButtonsDto, unknown, ModuleButtonsPUT__MutationParameters, TContext> {
  const key = moduleButtonsPUTMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: ModuleButtonsPUT__MutationParameters) => Client.moduleButtonsPUT(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function moduleButtonsDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/ModuleButtons/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function moduleButtonsDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'moduleButtonsDELETE',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useModuleButtonsDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<boolean, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<boolean, unknown, void, TContext> {
  const key = moduleButtonsDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.moduleButtonsDELETE(id),
    mutationKey: key,
  });
}
  
type ModuleButtonsDELETE__MutationParameters = ModuleButtonsDELETEQueryParameters

/**
 * @return OK
 */
export function useModuleButtonsDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<boolean, unknown, ModuleButtonsDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: ModuleButtonsDELETEQueryParameters}): UseMutationResult<boolean, unknown, ModuleButtonsDELETE__MutationParameters, TContext> {
  const key = moduleButtonsDELETEMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: ModuleButtonsDELETE__MutationParameters) => Client.moduleButtonsDELETE(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function modulesAllUrl(): string {
  let url_ = getBaseUrl() + "/api/layout/Modules";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let modulesAllDefaultOptions: Omit<UseQueryOptions<Types.ModuleDto[], unknown, Types.ModuleDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ModuleDto[], unknown, Types.ModuleDto[]>, 'queryFn'>> = {
};
export function getModulesAllDefaultOptions() {
  return modulesAllDefaultOptions;
};
export function setModulesAllDefaultOptions(options: typeof modulesAllDefaultOptions) {
  modulesAllDefaultOptions = options;
}

export function modulesAllQueryKey(): QueryKey;
export function modulesAllQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'modulesAll',
    ]);
}
export function __modulesAll(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.modulesAll(
axiosConfig    );
}

/**
 * @return OK
 */
export function useModulesAllQuery<TSelectData = Types.ModuleDto[], TError = unknown>(options?: Omit<UseQueryOptions<Types.ModuleDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useModulesAllQuery<TSelectData = Types.ModuleDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ModuleDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ModuleDto[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __modulesAll(context, axiosConfig) : __modulesAll,
    queryKey: modulesAllQueryKey(),
    ...modulesAllDefaultOptions as unknown as Omit<UseQueryOptions<Types.ModuleDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setModulesAllData(queryClient: QueryClient, updater: (data: Types.ModuleDto[] | undefined) => Types.ModuleDto[], ) {
  queryClient.setQueryData(modulesAllQueryKey(),
    updater
  );
}

/**
 * @return OK
 */
export function setModulesAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ModuleDto[] | undefined) => Types.ModuleDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function modulesPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/layout/Modules";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function modulesPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'modulesPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useModulesPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.ModuleDto, unknown, Types.ModuleDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModuleDto, unknown, Types.ModuleDto, TContext> {
  const key = modulesPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ModuleDto) => Client.modulesPOST(body),
    mutationKey: key,
  });
}
  
export function modulesGETUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/Modules/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let modulesGETDefaultOptions: Omit<UseQueryOptions<Types.ModuleDto, unknown, Types.ModuleDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.ModuleDto, unknown, Types.ModuleDto>, 'queryFn'>> = {
};
export function getModulesGETDefaultOptions() {
  return modulesGETDefaultOptions;
};
export function setModulesGETDefaultOptions(options: typeof modulesGETDefaultOptions) {
  modulesGETDefaultOptions = options;
}

export function modulesGETQueryKey(id: string): QueryKey;
export function modulesGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as ModulesGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'modulesGET',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'modulesGET',
        ...params
      ]);
  }
}
export function __modulesGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.modulesGET(
      context.queryKey[2] as string,axiosConfig    );
}

export function useModulesGETQuery<TSelectData = Types.ModuleDto, TError = unknown>(dto: ModulesGETQueryParameters, options?: Omit<UseQueryOptions<Types.ModuleDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useModulesGETQuery<TSelectData = Types.ModuleDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.ModuleDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useModulesGETQuery<TSelectData = Types.ModuleDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ModuleDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as ModulesGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.ModuleDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __modulesGET(context, axiosConfig) : __modulesGET,
    queryKey: modulesGETQueryKey(id),
    ...modulesGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.ModuleDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setModulesGETData(queryClient: QueryClient, updater: (data: Types.ModuleDto | undefined) => Types.ModuleDto, id: string) {
  queryClient.setQueryData(modulesGETQueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setModulesGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ModuleDto | undefined) => Types.ModuleDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function modulesPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/Modules/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function modulesPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'modulesPUT',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useModulesPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.ModuleDto, unknown, Types.ModuleDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ModuleDto, unknown, Types.ModuleDto, TContext> {
  const key = modulesPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.ModuleDto) => Client.modulesPUT(id, body),
    mutationKey: key,
  });
}
  
type ModulesPUT__MutationParameters = ModulesPUTQueryParameters & {
  body: Types.ModuleDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useModulesPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.ModuleDto, unknown, ModulesPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: ModulesPUTQueryParameters}): UseMutationResult<Types.ModuleDto, unknown, ModulesPUT__MutationParameters, TContext> {
  const key = modulesPUTMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: ModulesPUT__MutationParameters) => Client.modulesPUT(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function modulesDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/Modules/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function modulesDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'modulesDELETE',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useModulesDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.BooleanActionResult, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.BooleanActionResult, unknown, void, TContext> {
  const key = modulesDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.modulesDELETE(id),
    mutationKey: key,
  });
}
  
type ModulesDELETE__MutationParameters = ModulesDELETEQueryParameters

/**
 * @return OK
 */
export function useModulesDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.BooleanActionResult, unknown, ModulesDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: ModulesDELETEQueryParameters}): UseMutationResult<Types.BooleanActionResult, unknown, ModulesDELETE__MutationParameters, TContext> {
  const key = modulesDELETEMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: ModulesDELETE__MutationParameters) => Client.modulesDELETE(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function overridesAllUrl(): string {
  let url_ = getBaseUrl() + "/api/layout/Overrides";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let overridesAllDefaultOptions: Omit<UseQueryOptions<Types.OverrideDto[], unknown, Types.OverrideDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.OverrideDto[], unknown, Types.OverrideDto[]>, 'queryFn'>> = {
};
export function getOverridesAllDefaultOptions() {
  return overridesAllDefaultOptions;
};
export function setOverridesAllDefaultOptions(options: typeof overridesAllDefaultOptions) {
  overridesAllDefaultOptions = options;
}

export function overridesAllQueryKey(): QueryKey;
export function overridesAllQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'overridesAll',
    ]);
}
export function __overridesAll(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.overridesAll(
axiosConfig    );
}

/**
 * @return OK
 */
export function useOverridesAllQuery<TSelectData = Types.OverrideDto[], TError = unknown>(options?: Omit<UseQueryOptions<Types.OverrideDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useOverridesAllQuery<TSelectData = Types.OverrideDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.OverrideDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.OverrideDto[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __overridesAll(context, axiosConfig) : __overridesAll,
    queryKey: overridesAllQueryKey(),
    ...overridesAllDefaultOptions as unknown as Omit<UseQueryOptions<Types.OverrideDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setOverridesAllData(queryClient: QueryClient, updater: (data: Types.OverrideDto[] | undefined) => Types.OverrideDto[], ) {
  queryClient.setQueryData(overridesAllQueryKey(),
    updater
  );
}

/**
 * @return OK
 */
export function setOverridesAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.OverrideDto[] | undefined) => Types.OverrideDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function overridesPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/layout/Overrides";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function overridesPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'overridesPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useOverridesPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.OverrideDtoActionResult, unknown, Types.OverrideDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.OverrideDtoActionResult, unknown, Types.OverrideDto, TContext> {
  const key = overridesPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.OverrideDto) => Client.overridesPOST(body),
    mutationKey: key,
  });
}
  
export function overridesGETUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/Overrides/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let overridesGETDefaultOptions: Omit<UseQueryOptions<Types.OverrideDto, unknown, Types.OverrideDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.OverrideDto, unknown, Types.OverrideDto>, 'queryFn'>> = {
};
export function getOverridesGETDefaultOptions() {
  return overridesGETDefaultOptions;
};
export function setOverridesGETDefaultOptions(options: typeof overridesGETDefaultOptions) {
  overridesGETDefaultOptions = options;
}

export function overridesGETQueryKey(id: string): QueryKey;
export function overridesGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as OverridesGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'overridesGET',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'overridesGET',
        ...params
      ]);
  }
}
export function __overridesGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.overridesGET(
      context.queryKey[2] as string,axiosConfig    );
}

export function useOverridesGETQuery<TSelectData = Types.OverrideDto, TError = unknown>(dto: OverridesGETQueryParameters, options?: Omit<UseQueryOptions<Types.OverrideDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useOverridesGETQuery<TSelectData = Types.OverrideDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.OverrideDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useOverridesGETQuery<TSelectData = Types.OverrideDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.OverrideDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as OverridesGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.OverrideDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __overridesGET(context, axiosConfig) : __overridesGET,
    queryKey: overridesGETQueryKey(id),
    ...overridesGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.OverrideDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setOverridesGETData(queryClient: QueryClient, updater: (data: Types.OverrideDto | undefined) => Types.OverrideDto, id: string) {
  queryClient.setQueryData(overridesGETQueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setOverridesGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.OverrideDto | undefined) => Types.OverrideDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function overridesPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/Overrides/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function overridesPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'overridesPUT',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useOverridesPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.OverrideDto, unknown, Types.OverrideDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.OverrideDto, unknown, Types.OverrideDto, TContext> {
  const key = overridesPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.OverrideDto) => Client.overridesPUT(id, body),
    mutationKey: key,
  });
}
  
type OverridesPUT__MutationParameters = OverridesPUTQueryParameters & {
  body: Types.OverrideDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useOverridesPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.OverrideDto, unknown, OverridesPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: OverridesPUTQueryParameters}): UseMutationResult<Types.OverrideDto, unknown, OverridesPUT__MutationParameters, TContext> {
  const key = overridesPUTMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: OverridesPUT__MutationParameters) => Client.overridesPUT(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function overridesDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/Overrides/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function overridesDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'overridesDELETE',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useOverridesDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<boolean, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<boolean, unknown, void, TContext> {
  const key = overridesDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.overridesDELETE(id),
    mutationKey: key,
  });
}
  
type OverridesDELETE__MutationParameters = OverridesDELETEQueryParameters

/**
 * @return OK
 */
export function useOverridesDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<boolean, unknown, OverridesDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: OverridesDELETEQueryParameters}): UseMutationResult<boolean, unknown, OverridesDELETE__MutationParameters, TContext> {
  const key = overridesDELETEMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: OverridesDELETE__MutationParameters) => Client.overridesDELETE(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function paymentGatewayUrl(): string {
  let url_ = getBaseUrl() + "/api/PaymentGateway";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function paymentGatewayMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'paymentGateway',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function usePaymentGatewayMutation<TContext>(options?: Omit<UseMutationOptions<Types.PaymentGatewayDto, unknown, Types.PaymentGatewayDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.PaymentGatewayDto, unknown, Types.PaymentGatewayDto, TContext> {
  const key = paymentGatewayMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.PaymentGatewayDto) => Client.paymentGateway(body),
    mutationKey: key,
  });
}
  
export function generateLinkUrl(paymentGatewayId: string): string {
  let url_ = getBaseUrl() + "/api/PaymentGateway/{paymentGatewayId}/generate-link";
if (paymentGatewayId === undefined || paymentGatewayId === null)
  throw new Error("The parameter 'paymentGatewayId' must be defined.");
url_ = url_.replace("{paymentGatewayId}", encodeURIComponent("" + paymentGatewayId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function generateLinkMutationKey(paymentGatewayId: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'generateLink',
      paymentGatewayId as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useGenerateLinkMutation<TContext>(paymentGatewayId: string, options?: Omit<UseMutationOptions<string, unknown, Types.PaymentRequestsDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<string, unknown, Types.PaymentRequestsDto, TContext> {
  const key = generateLinkMutationKey(paymentGatewayId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.PaymentRequestsDto) => Client.generateLink(paymentGatewayId, body),
    mutationKey: key,
  });
}
  
type GenerateLink__MutationParameters = GenerateLinkQueryParameters & {
  body: Types.PaymentRequestsDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useGenerateLinkMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<string, unknown, GenerateLink__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: GenerateLinkQueryParameters}): UseMutationResult<string, unknown, GenerateLink__MutationParameters, TContext> {
  const key = generateLinkMutationKey(options?.parameters?.paymentGatewayId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: GenerateLink__MutationParameters) => Client.generateLink(data.paymentGatewayId ?? options?.parameters?.paymentGatewayId!, data.body),
  mutationKey: key,
});
}
  
export function paymentCheckoutUrl(paymentGatewayId: string): string {
  let url_ = getBaseUrl() + "/api/PaymentGateway/{paymentGatewayId}/payment-checkout";
if (paymentGatewayId === undefined || paymentGatewayId === null)
  throw new Error("The parameter 'paymentGatewayId' must be defined.");
url_ = url_.replace("{paymentGatewayId}", encodeURIComponent("" + paymentGatewayId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function paymentCheckoutMutationKey(paymentGatewayId: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'paymentCheckout',
      paymentGatewayId as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function usePaymentCheckoutMutation<TContext>(paymentGatewayId: string, options?: Omit<UseMutationOptions<string, unknown, Types.PaymentRequestsDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<string, unknown, Types.PaymentRequestsDto, TContext> {
  const key = paymentCheckoutMutationKey(paymentGatewayId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.PaymentRequestsDto) => Client.paymentCheckout(paymentGatewayId, body),
    mutationKey: key,
  });
}
  
type PaymentCheckout__MutationParameters = PaymentCheckoutQueryParameters & {
  body: Types.PaymentRequestsDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function usePaymentCheckoutMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<string, unknown, PaymentCheckout__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: PaymentCheckoutQueryParameters}): UseMutationResult<string, unknown, PaymentCheckout__MutationParameters, TContext> {
  const key = paymentCheckoutMutationKey(options?.parameters?.paymentGatewayId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: PaymentCheckout__MutationParameters) => Client.paymentCheckout(data.paymentGatewayId ?? options?.parameters?.paymentGatewayId!, data.body),
  mutationKey: key,
});
}
  
 

export function paymentTransactionsMutationKey(paymentGatewayId: string, startDate?: Date | undefined, endDate?: Date | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'paymentTransactions',
      paymentGatewayId as any,
      startDate as any,
      endDate as any,
    ]);
}
 
type PaymentTransactions__MutationParameters = PaymentTransactionsQueryParameters

 
export function paymentTransactionsUrl(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined): string {
  let url_ = getBaseUrl() + "/api/PaymentTransactions?";
if (pageNumber === null)
    throw new Error("The parameter 'pageNumber' cannot be null.");
else if (pageNumber !== undefined)
    url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
if (totalCount === null)
    throw new Error("The parameter 'totalCount' cannot be null.");
else if (totalCount !== undefined)
    url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&";
if (sort_SortBy === null)
    throw new Error("The parameter 'sort_SortBy' cannot be null.");
else if (sort_SortBy !== undefined)
    url_ += "Sort.SortBy=" + encodeURIComponent("" + sort_SortBy) + "&";
if (sort_Ascending === null)
    throw new Error("The parameter 'sort_Ascending' cannot be null.");
else if (sort_Ascending !== undefined)
    url_ += "Sort.Ascending=" + encodeURIComponent("" + sort_Ascending) + "&";
if (filter_Logic === null)
    throw new Error("The parameter 'filter_Logic' cannot be null.");
else if (filter_Logic !== undefined)
    url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&";
if (filter_Conditions === null)
    throw new Error("The parameter 'filter_Conditions' cannot be null.");
else if (filter_Conditions !== undefined)
    filter_Conditions && filter_Conditions.forEach((item, index) => {
        for (let attr in item)
			if (item.hasOwnProperty(attr)) {
				url_ += "Filter.Conditions[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
			}
    });
if (filter_Groups === null)
    throw new Error("The parameter 'filter_Groups' cannot be null.");
else if (filter_Groups !== undefined)
    filter_Groups && filter_Groups.forEach((item, index) => {
        for (let attr in item)
			if (item.hasOwnProperty(attr)) {
				url_ += "Filter.Groups[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
			}
    });
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let paymentTransactionsDefaultOptions: Omit<UseQueryOptions<Types.PaymentTransactionsDtoQueryResponse, unknown, Types.PaymentTransactionsDtoQueryResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.PaymentTransactionsDtoQueryResponse, unknown, Types.PaymentTransactionsDtoQueryResponse>, 'queryFn'>> = {
};
export function getPaymentTransactionsDefaultOptions() {
  return paymentTransactionsDefaultOptions;
};
export function setPaymentTransactionsDefaultOptions(options: typeof paymentTransactionsDefaultOptions) {
  paymentTransactionsDefaultOptions = options;
}

export function paymentTransactionsQueryKey(dto: PaymentTransactionsQueryParameters): QueryKey;
export function paymentTransactionsQueryKey(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined): QueryKey;
export function paymentTransactionsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups,  } = params[0] as PaymentTransactionsQueryParameters;

    return trimArrayEnd([
        'Client',
        'paymentTransactions',
        pageNumber as any,
        pageSize as any,
        totalCount as any,
        sort_SortBy as any,
        sort_Ascending as any,
        filter_Logic as any,
        filter_Conditions as any,
        filter_Groups as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'paymentTransactions',
        ...params
      ]);
  }
}
 
 
/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function setPaymentTransactionsData(queryClient: QueryClient, updater: (data: Types.PaymentTransactionsDtoQueryResponse | undefined) => Types.PaymentTransactionsDtoQueryResponse, pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined) {
  queryClient.setQueryData(paymentTransactionsQueryKey(pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups),
    updater
  );
}

/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function setPaymentTransactionsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PaymentTransactionsDtoQueryResponse | undefined) => Types.PaymentTransactionsDtoQueryResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function routesGETUrl(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined): string {
  let url_ = getBaseUrl() + "/api/Routes?";
if (pageNumber === null)
    throw new Error("The parameter 'pageNumber' cannot be null.");
else if (pageNumber !== undefined)
    url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
if (totalCount === null)
    throw new Error("The parameter 'totalCount' cannot be null.");
else if (totalCount !== undefined)
    url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&";
if (sort_SortBy === null)
    throw new Error("The parameter 'sort_SortBy' cannot be null.");
else if (sort_SortBy !== undefined)
    url_ += "Sort.SortBy=" + encodeURIComponent("" + sort_SortBy) + "&";
if (sort_Ascending === null)
    throw new Error("The parameter 'sort_Ascending' cannot be null.");
else if (sort_Ascending !== undefined)
    url_ += "Sort.Ascending=" + encodeURIComponent("" + sort_Ascending) + "&";
if (filter_Logic === null)
    throw new Error("The parameter 'filter_Logic' cannot be null.");
else if (filter_Logic !== undefined)
    url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&";
if (filter_Conditions === null)
    throw new Error("The parameter 'filter_Conditions' cannot be null.");
else if (filter_Conditions !== undefined)
    filter_Conditions && filter_Conditions.forEach((item, index) => {
        for (let attr in item)
			if (item.hasOwnProperty(attr)) {
				url_ += "Filter.Conditions[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
			}
    });
if (filter_Groups === null)
    throw new Error("The parameter 'filter_Groups' cannot be null.");
else if (filter_Groups !== undefined)
    filter_Groups && filter_Groups.forEach((item, index) => {
        for (let attr in item)
			if (item.hasOwnProperty(attr)) {
				url_ += "Filter.Groups[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
			}
    });
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let routesGETDefaultOptions: Omit<UseQueryOptions<Types.RouteDtoQueryResponse, unknown, Types.RouteDtoQueryResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.RouteDtoQueryResponse, unknown, Types.RouteDtoQueryResponse>, 'queryFn'>> = {
};
export function getRoutesGETDefaultOptions() {
  return routesGETDefaultOptions;
};
export function setRoutesGETDefaultOptions(options: typeof routesGETDefaultOptions) {
  routesGETDefaultOptions = options;
}

export function routesGETQueryKey(dto: RoutesGETQueryParameters): QueryKey;
export function routesGETQueryKey(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined): QueryKey;
export function routesGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups,  } = params[0] as RoutesGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'routesGET',
        pageNumber as any,
        pageSize as any,
        totalCount as any,
        sort_SortBy as any,
        sort_Ascending as any,
        filter_Logic as any,
        filter_Conditions as any,
        filter_Groups as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'routesGET',
        ...params
      ]);
  }
}
 












export function __routesGET(
  pageNumber?: number,
  pageSize?: number,
  totalCount?: number,
  sort_SortBy?: string,
  sort_Ascending?: boolean,
  filter_Logic?: Types.LogicalOperator,
  filter_Conditions?: Types.FilterCondition[],
  filter_Groups?: Types.FilterGroup[],
  axiosConfig?: AxiosRequestConfig
) {
  // Perform the API call with all provided parameters
  return Client.routesGET(
    pageNumber,
    pageSize,
    totalCount,
    sort_SortBy,
    sort_Ascending,
    filter_Logic,
    filter_Conditions
  );
}

export function useRoutesGETQuery<
  TSelectData = Types.RouteDtoQueryResponse,
  TError = unknown
>(
  dto?: RoutesGETQueryParameters,
  options?: Omit<
    UseQueryOptions<Types.RouteDtoQueryResponse, TError, TSelectData>,
    "queryKey"
  >,
  axiosConfig?: Partial<AxiosRequestConfig>
): UseQueryResult<TSelectData, TError>;

export function useRoutesGETQuery<
  TSelectData = Types.RouteDtoQueryResponse,
  TError = unknown
>(
  pageNumber?: number,
  pageSize?: number,
  totalCount?: number,
  sort_SortBy?: string,
  sort_Ascending?: boolean,
  filter_Logic?: Types.LogicalOperator,
  filter_Conditions?: Types.FilterCondition[],
  filter_Groups?: Types.FilterGroup[],
  options?: Omit<
    UseQueryOptions<Types.RouteDtoQueryResponse, TError, TSelectData>,
    "queryKey"
  >,
  axiosConfig?: Partial<AxiosRequestConfig>
): UseQueryResult<TSelectData, TError>;

export function useRoutesGETQuery<
  TSelectData = Types.RouteDtoQueryResponse,
  TError = unknown
>(...params: any[]): UseQueryResult<TSelectData, TError> {
  let options:
    | UseQueryOptions<Types.RouteDtoQueryResponse, TError, TSelectData>
    | undefined = undefined;
  let axiosConfig: AxiosRequestConfig | undefined = undefined;
  let pageNumber: any = undefined;
  let pageSize: any = undefined;
  let totalCount: any = undefined;
  let sort_SortBy: any = undefined;
  let sort_Ascending: any = undefined;
  let filter_Logic: any = undefined;
  let filter_Conditions: any = undefined;
  let filter_Groups: any = undefined;

  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({
        pageNumber,
        pageSize,
        totalCount,
        sort_SortBy,
        sort_Ascending,
        filter_Logic,
        filter_Conditions,
        filter_Groups,
      } = params[0] as RoutesGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [
        pageNumber,
        pageSize,
        totalCount,
        sort_SortBy,
        sort_Ascending,
        filter_Logic,
        filter_Conditions,
        filter_Groups,
        options,
        axiosConfig,
      ] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.RouteDtoQueryResponse, TError, TSelectData>({
    queryFn: () =>
      __routesGET(
        pageNumber,
        pageSize,
        totalCount,
        sort_SortBy,
        sort_Ascending,
        filter_Logic,
        filter_Conditions,
        filter_Groups,
        axiosConfig
      ),
    queryKey: routesGETQueryKey(
      pageNumber,
      pageSize,
      totalCount,
      sort_SortBy,
      sort_Ascending,
      filter_Logic,
      filter_Conditions,
      filter_Groups
    ),
    ...(routesGETDefaultOptions as unknown as Omit<
      UseQueryOptions<Types.RouteDtoQueryResponse, TError, TSelectData>,
      "queryKey"
    >),
    ...options,
  });
}




















 
/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function setRoutesGETData(queryClient: QueryClient, updater: (data: Types.RouteDtoQueryResponse | undefined) => Types.RouteDtoQueryResponse, pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined) {
  queryClient.setQueryData(routesGETQueryKey(pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups),
    updater
  );
}

/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function setRoutesGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.RouteDtoQueryResponse | undefined) => Types.RouteDtoQueryResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function routesPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/Routes";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function routesPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'routesPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useRoutesPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.RouteDto, unknown, Types.RouteDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.RouteDto, unknown, Types.RouteDto, TContext> {
  const key = routesPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.RouteDto) => Client.routesPOST(body),
    mutationKey: key,
  });
}
  
export function routesGET2Url(id: string): string {
  let url_ = getBaseUrl() + "/api/Routes/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let routesGET2DefaultOptions: Omit<UseQueryOptions<Types.RouteDto, unknown, Types.RouteDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.RouteDto, unknown, Types.RouteDto>, 'queryFn'>> = {
};
export function getRoutesGET2DefaultOptions() {
  return routesGET2DefaultOptions;
};
export function setRoutesGET2DefaultOptions(options: typeof routesGET2DefaultOptions) {
  routesGET2DefaultOptions = options;
}

export function routesGET2QueryKey(id: string): QueryKey;
export function routesGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as RoutesGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'routesGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'routesGET2',
        ...params
      ]);
  }
}
export function __routesGET2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.routesGET2(
      context.queryKey[2] as string,axiosConfig    );
}

export function useRoutesGET2Query<TSelectData = Types.RouteDto, TError = unknown>(dto: RoutesGET2QueryParameters, options?: Omit<UseQueryOptions<Types.RouteDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useRoutesGET2Query<TSelectData = Types.RouteDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.RouteDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useRoutesGET2Query<TSelectData = Types.RouteDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.RouteDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as RoutesGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.RouteDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __routesGET2(context, axiosConfig) : __routesGET2,
    queryKey: routesGET2QueryKey(id),
    ...routesGET2DefaultOptions as unknown as Omit<UseQueryOptions<Types.RouteDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setRoutesGET2Data(queryClient: QueryClient, updater: (data: Types.RouteDto | undefined) => Types.RouteDto, id: string) {
  queryClient.setQueryData(routesGET2QueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setRoutesGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.RouteDto | undefined) => Types.RouteDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function routesPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Routes/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function routesPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'routesPUT',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useRoutesPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.RouteDto, unknown, Types.RouteDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.RouteDto, unknown, Types.RouteDto, TContext> {
  const key = routesPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.RouteDto) => Client.routesPUT(id, body),
    mutationKey: key,
  });
}
  
type RoutesPUT__MutationParameters = RoutesPUTQueryParameters & {
  body: Types.RouteDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useRoutesPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.RouteDto, unknown, RoutesPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: RoutesPUTQueryParameters}): UseMutationResult<Types.RouteDto, unknown, RoutesPUT__MutationParameters, TContext> {
  const key = routesPUTMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: RoutesPUT__MutationParameters) => Client.routesPUT(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function routesDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Routes/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function routesDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'routesDELETE',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useRoutesDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<boolean, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<boolean, unknown, void, TContext> {
  const key = routesDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.routesDELETE(id),
    mutationKey: key,
  });
}
  
type RoutesDELETE__MutationParameters = RoutesDELETEQueryParameters

/**
 * @return OK
 */
export function useRoutesDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<boolean, unknown, RoutesDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: RoutesDELETEQueryParameters}): UseMutationResult<boolean, unknown, RoutesDELETE__MutationParameters, TContext> {
  const key = routesDELETEMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: RoutesDELETE__MutationParameters) => Client.routesDELETE(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function startRouteUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Routes/start-route/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function startRouteMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'startRoute',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useStartRouteMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.RouteDto, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.RouteDto, unknown, void, TContext> {
  const key = startRouteMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.startRoute(id),
    mutationKey: key,
  });
}
  
type StartRoute__MutationParameters = StartRouteQueryParameters

/**
 * @return OK
 */
export function useStartRouteMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.RouteDto, unknown, StartRoute__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: StartRouteQueryParameters}): UseMutationResult<Types.RouteDto, unknown, StartRoute__MutationParameters, TContext> {
  const key = startRouteMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: StartRoute__MutationParameters) => Client.startRoute(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function finishRouteUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Routes/finish-route/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function finishRouteMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'finishRoute',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useFinishRouteMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.RouteDto, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.RouteDto, unknown, void, TContext> {
  const key = finishRouteMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.finishRoute(id),
    mutationKey: key,
  });
}
  
type FinishRoute__MutationParameters = FinishRouteQueryParameters

/**
 * @return OK
 */
export function useFinishRouteMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.RouteDto, unknown, FinishRoute__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: FinishRouteQueryParameters}): UseMutationResult<Types.RouteDto, unknown, FinishRoute__MutationParameters, TContext> {
  const key = finishRouteMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: FinishRoute__MutationParameters) => Client.finishRoute(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function searchExpsAllUrl(): string {
  let url_ = getBaseUrl() + "/api/layout/SearchExps";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let searchExpsAllDefaultOptions: Omit<UseQueryOptions<Types.SearchExpDto[], unknown, Types.SearchExpDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.SearchExpDto[], unknown, Types.SearchExpDto[]>, 'queryFn'>> = {
};
export function getSearchExpsAllDefaultOptions() {
  return searchExpsAllDefaultOptions;
};
export function setSearchExpsAllDefaultOptions(options: typeof searchExpsAllDefaultOptions) {
  searchExpsAllDefaultOptions = options;
}

export function searchExpsAllQueryKey(): QueryKey;
export function searchExpsAllQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'searchExpsAll',
    ]);
}
export function __searchExpsAll(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.searchExpsAll(
axiosConfig    );
}

/**
 * @return OK
 */
export function useSearchExpsAllQuery<TSelectData = Types.SearchExpDto[], TError = unknown>(options?: Omit<UseQueryOptions<Types.SearchExpDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useSearchExpsAllQuery<TSelectData = Types.SearchExpDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.SearchExpDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.SearchExpDto[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __searchExpsAll(context, axiosConfig) : __searchExpsAll,
    queryKey: searchExpsAllQueryKey(),
    ...searchExpsAllDefaultOptions as unknown as Omit<UseQueryOptions<Types.SearchExpDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setSearchExpsAllData(queryClient: QueryClient, updater: (data: Types.SearchExpDto[] | undefined) => Types.SearchExpDto[], ) {
  queryClient.setQueryData(searchExpsAllQueryKey(),
    updater
  );
}

/**
 * @return OK
 */
export function setSearchExpsAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.SearchExpDto[] | undefined) => Types.SearchExpDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function searchExpsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/layout/SearchExps";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function searchExpsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'searchExpsPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useSearchExpsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.SearchExpDto, unknown, Types.SearchExpDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.SearchExpDto, unknown, Types.SearchExpDto, TContext> {
  const key = searchExpsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.SearchExpDto) => Client.searchExpsPOST(body),
    mutationKey: key,
  });
}
  
export function searchExpsGETUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/SearchExps/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let searchExpsGETDefaultOptions: Omit<UseQueryOptions<Types.SearchExpDto, unknown, Types.SearchExpDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.SearchExpDto, unknown, Types.SearchExpDto>, 'queryFn'>> = {
};
export function getSearchExpsGETDefaultOptions() {
  return searchExpsGETDefaultOptions;
};
export function setSearchExpsGETDefaultOptions(options: typeof searchExpsGETDefaultOptions) {
  searchExpsGETDefaultOptions = options;
}

export function searchExpsGETQueryKey(id: string): QueryKey;
export function searchExpsGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as SearchExpsGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'searchExpsGET',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'searchExpsGET',
        ...params
      ]);
  }
}
export function __searchExpsGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.searchExpsGET(
      context.queryKey[2] as string,axiosConfig    );
}

export function useSearchExpsGETQuery<TSelectData = Types.SearchExpDto, TError = unknown>(dto: SearchExpsGETQueryParameters, options?: Omit<UseQueryOptions<Types.SearchExpDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useSearchExpsGETQuery<TSelectData = Types.SearchExpDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.SearchExpDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useSearchExpsGETQuery<TSelectData = Types.SearchExpDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.SearchExpDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as SearchExpsGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.SearchExpDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __searchExpsGET(context, axiosConfig) : __searchExpsGET,
    queryKey: searchExpsGETQueryKey(id),
    ...searchExpsGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.SearchExpDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setSearchExpsGETData(queryClient: QueryClient, updater: (data: Types.SearchExpDto | undefined) => Types.SearchExpDto, id: string) {
  queryClient.setQueryData(searchExpsGETQueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setSearchExpsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.SearchExpDto | undefined) => Types.SearchExpDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function searchExpsPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/SearchExps/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function searchExpsPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'searchExpsPUT',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useSearchExpsPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.SearchExpDto, unknown, Types.SearchExpDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.SearchExpDto, unknown, Types.SearchExpDto, TContext> {
  const key = searchExpsPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.SearchExpDto) => Client.searchExpsPUT(id, body),
    mutationKey: key,
  });
}
  
type SearchExpsPUT__MutationParameters = SearchExpsPUTQueryParameters & {
  body: Types.SearchExpDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useSearchExpsPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.SearchExpDto, unknown, SearchExpsPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: SearchExpsPUTQueryParameters}): UseMutationResult<Types.SearchExpDto, unknown, SearchExpsPUT__MutationParameters, TContext> {
  const key = searchExpsPUTMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: SearchExpsPUT__MutationParameters) => Client.searchExpsPUT(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function searchExpsDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/SearchExps/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function searchExpsDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'searchExpsDELETE',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useSearchExpsDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<boolean, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<boolean, unknown, void, TContext> {
  const key = searchExpsDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.searchExpsDELETE(id),
    mutationKey: key,
  });
}
  
type SearchExpsDELETE__MutationParameters = SearchExpsDELETEQueryParameters

/**
 * @return OK
 */
export function useSearchExpsDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<boolean, unknown, SearchExpsDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: SearchExpsDELETEQueryParameters}): UseMutationResult<boolean, unknown, SearchExpsDELETE__MutationParameters, TContext> {
  const key = searchExpsDELETEMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: SearchExpsDELETE__MutationParameters) => Client.searchExpsDELETE(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function sectionsAllUrl(): string {
  let url_ = getBaseUrl() + "/api/layout/Sections";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let sectionsAllDefaultOptions: Omit<UseQueryOptions<Types.SectionDto[], unknown, Types.SectionDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.SectionDto[], unknown, Types.SectionDto[]>, 'queryFn'>> = {
};
export function getSectionsAllDefaultOptions() {
  return sectionsAllDefaultOptions;
};
export function setSectionsAllDefaultOptions(options: typeof sectionsAllDefaultOptions) {
  sectionsAllDefaultOptions = options;
}

export function sectionsAllQueryKey(): QueryKey;
export function sectionsAllQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'sectionsAll',
    ]);
}
export function __sectionsAll(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.sectionsAll(
axiosConfig    );
}

/**
 * @return OK
 */
export function useSectionsAllQuery<TSelectData = Types.SectionDto[], TError = unknown>(options?: Omit<UseQueryOptions<Types.SectionDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useSectionsAllQuery<TSelectData = Types.SectionDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.SectionDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.SectionDto[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __sectionsAll(context, axiosConfig) : __sectionsAll,
    queryKey: sectionsAllQueryKey(),
    ...sectionsAllDefaultOptions as unknown as Omit<UseQueryOptions<Types.SectionDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setSectionsAllData(queryClient: QueryClient, updater: (data: Types.SectionDto[] | undefined) => Types.SectionDto[], ) {
  queryClient.setQueryData(sectionsAllQueryKey(),
    updater
  );
}

/**
 * @return OK
 */
export function setSectionsAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.SectionDto[] | undefined) => Types.SectionDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function sectionsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/layout/Sections";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function sectionsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'sectionsPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useSectionsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.SectionDto, unknown, Types.SectionDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.SectionDto, unknown, Types.SectionDto, TContext> {
  const key = sectionsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.SectionDto) => Client.sectionsPOST(body),
    mutationKey: key,
  });
}
  
export function sectionsGETUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/Sections/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let sectionsGETDefaultOptions: Omit<UseQueryOptions<Types.SectionDto, unknown, Types.SectionDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.SectionDto, unknown, Types.SectionDto>, 'queryFn'>> = {
};
export function getSectionsGETDefaultOptions() {
  return sectionsGETDefaultOptions;
};
export function setSectionsGETDefaultOptions(options: typeof sectionsGETDefaultOptions) {
  sectionsGETDefaultOptions = options;
}

export function sectionsGETQueryKey(id: string): QueryKey;
export function sectionsGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as SectionsGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'sectionsGET',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'sectionsGET',
        ...params
      ]);
  }
}
export function __sectionsGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.sectionsGET(
      context.queryKey[2] as string,axiosConfig    );
}

export function useSectionsGETQuery<TSelectData = Types.SectionDto, TError = unknown>(dto: SectionsGETQueryParameters, options?: Omit<UseQueryOptions<Types.SectionDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useSectionsGETQuery<TSelectData = Types.SectionDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.SectionDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useSectionsGETQuery<TSelectData = Types.SectionDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.SectionDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as SectionsGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.SectionDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __sectionsGET(context, axiosConfig) : __sectionsGET,
    queryKey: sectionsGETQueryKey(id),
    ...sectionsGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.SectionDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setSectionsGETData(queryClient: QueryClient, updater: (data: Types.SectionDto | undefined) => Types.SectionDto, id: string) {
  queryClient.setQueryData(sectionsGETQueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setSectionsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.SectionDto | undefined) => Types.SectionDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function sectionsPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/Sections/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function sectionsPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'sectionsPUT',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useSectionsPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.SectionDto, unknown, Types.SectionDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.SectionDto, unknown, Types.SectionDto, TContext> {
  const key = sectionsPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.SectionDto) => Client.sectionsPUT(id, body),
    mutationKey: key,
  });
}
  
type SectionsPUT__MutationParameters = SectionsPUTQueryParameters & {
  body: Types.SectionDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useSectionsPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.SectionDto, unknown, SectionsPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: SectionsPUTQueryParameters}): UseMutationResult<Types.SectionDto, unknown, SectionsPUT__MutationParameters, TContext> {
  const key = sectionsPUTMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: SectionsPUT__MutationParameters) => Client.sectionsPUT(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function sectionsDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/Sections/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function sectionsDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'sectionsDELETE',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useSectionsDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<boolean, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<boolean, unknown, void, TContext> {
  const key = sectionsDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.sectionsDELETE(id),
    mutationKey: key,
  });
}
  
type SectionsDELETE__MutationParameters = SectionsDELETEQueryParameters

/**
 * @return OK
 */
export function useSectionsDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<boolean, unknown, SectionsDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: SectionsDELETEQueryParameters}): UseMutationResult<boolean, unknown, SectionsDELETE__MutationParameters, TContext> {
  const key = sectionsDELETEMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: SectionsDELETE__MutationParameters) => Client.sectionsDELETE(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function seriesGETUrl(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined): string {
  let url_ = getBaseUrl() + "/api/Series?";
if (pageNumber === null)
    throw new Error("The parameter 'pageNumber' cannot be null.");
else if (pageNumber !== undefined)
    url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
if (totalCount === null)
    throw new Error("The parameter 'totalCount' cannot be null.");
else if (totalCount !== undefined)
    url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&";
if (sort_SortBy === null)
    throw new Error("The parameter 'sort_SortBy' cannot be null.");
else if (sort_SortBy !== undefined)
    url_ += "Sort.SortBy=" + encodeURIComponent("" + sort_SortBy) + "&";
if (sort_Ascending === null)
    throw new Error("The parameter 'sort_Ascending' cannot be null.");
else if (sort_Ascending !== undefined)
    url_ += "Sort.Ascending=" + encodeURIComponent("" + sort_Ascending) + "&";
if (filter_Logic === null)
    throw new Error("The parameter 'filter_Logic' cannot be null.");
else if (filter_Logic !== undefined)
    url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&";
if (filter_Conditions === null)
    throw new Error("The parameter 'filter_Conditions' cannot be null.");
else if (filter_Conditions !== undefined)
    filter_Conditions && filter_Conditions.forEach((item, index) => {
        for (let attr in item)
			if (item.hasOwnProperty(attr)) {
				url_ += "Filter.Conditions[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
			}
    });
if (filter_Groups === null)
    throw new Error("The parameter 'filter_Groups' cannot be null.");
else if (filter_Groups !== undefined)
    filter_Groups && filter_Groups.forEach((item, index) => {
        for (let attr in item)
			if (item.hasOwnProperty(attr)) {
				url_ += "Filter.Groups[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
			}
    });
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let seriesGETDefaultOptions: Omit<UseQueryOptions<Types.SeriesDtoQueryResponse, unknown, Types.SeriesDtoQueryResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.SeriesDtoQueryResponse, unknown, Types.SeriesDtoQueryResponse>, 'queryFn'>> = {
};
export function getSeriesGETDefaultOptions() {
  return seriesGETDefaultOptions;
};
export function setSeriesGETDefaultOptions(options: typeof seriesGETDefaultOptions) {
  seriesGETDefaultOptions = options;
}

export function seriesGETQueryKey(dto: SeriesGETQueryParameters): QueryKey;
export function seriesGETQueryKey(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined): QueryKey;
export function seriesGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups,  } = params[0] as SeriesGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'seriesGET',
        pageNumber as any,
        pageSize as any,
        totalCount as any,
        sort_SortBy as any,
        sort_Ascending as any,
        filter_Logic as any,
        filter_Conditions as any,
        filter_Groups as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'seriesGET',
        ...params
      ]);
  }
}
export function __seriesGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.seriesGET(
      context.queryKey[2] as number | undefined,       context.queryKey[3] as number | undefined,       context.queryKey[4] as number | undefined,       context.queryKey[5] as string | undefined,       context.queryKey[6] as boolean | undefined,       context.queryKey[7] as Types.LogicalOperator | undefined,       context.queryKey[8] as Types.FilterCondition[] | undefined,       context.queryKey[9] as Types.FilterGroup[] | undefined,axiosConfig    );
}

export function useSeriesGETQuery<TSelectData = Types.SeriesDtoQueryResponse, TError = unknown>(dto: SeriesGETQueryParameters, options?: Omit<UseQueryOptions<Types.SeriesDtoQueryResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function useSeriesGETQuery<TSelectData = Types.SeriesDtoQueryResponse, TError = unknown>(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined, options?: Omit<UseQueryOptions<Types.SeriesDtoQueryResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useSeriesGETQuery<TSelectData = Types.SeriesDtoQueryResponse, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.SeriesDtoQueryResponse, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let pageNumber: any = undefined;
  let pageSize: any = undefined;
  let totalCount: any = undefined;
  let sort_SortBy: any = undefined;
  let sort_Ascending: any = undefined;
  let filter_Logic: any = undefined;
  let filter_Conditions: any = undefined;
  let filter_Groups: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups,  } = params[0] as SeriesGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.SeriesDtoQueryResponse, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __seriesGET(context, axiosConfig) : __seriesGET,
    queryKey: seriesGETQueryKey(pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups),
    ...seriesGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.SeriesDtoQueryResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function setSeriesGETData(queryClient: QueryClient, updater: (data: Types.SeriesDtoQueryResponse | undefined) => Types.SeriesDtoQueryResponse, pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined) {
  queryClient.setQueryData(seriesGETQueryKey(pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups),
    updater
  );
}

/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function setSeriesGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.SeriesDtoQueryResponse | undefined) => Types.SeriesDtoQueryResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function seriesPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/Series";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function seriesPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'seriesPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useSeriesPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.SeriesDto, unknown, Types.SeriesDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.SeriesDto, unknown, Types.SeriesDto, TContext> {
  const key = seriesPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.SeriesDto) => Client.seriesPOST(body),
    mutationKey: key,
  });
}
  
export function seriesGET2Url(id: string): string {
  let url_ = getBaseUrl() + "/api/Series/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let seriesGET2DefaultOptions: Omit<UseQueryOptions<Types.SeriesDto, unknown, Types.SeriesDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.SeriesDto, unknown, Types.SeriesDto>, 'queryFn'>> = {
};
export function getSeriesGET2DefaultOptions() {
  return seriesGET2DefaultOptions;
};
export function setSeriesGET2DefaultOptions(options: typeof seriesGET2DefaultOptions) {
  seriesGET2DefaultOptions = options;
}

export function seriesGET2QueryKey(id: string): QueryKey;
export function seriesGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as SeriesGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'seriesGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'seriesGET2',
        ...params
      ]);
  }
}
export function __seriesGET2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.seriesGET2(
      context.queryKey[2] as string,axiosConfig    );
}

export function useSeriesGET2Query<TSelectData = Types.SeriesDto, TError = unknown>(dto: SeriesGET2QueryParameters, options?: Omit<UseQueryOptions<Types.SeriesDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useSeriesGET2Query<TSelectData = Types.SeriesDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.SeriesDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useSeriesGET2Query<TSelectData = Types.SeriesDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.SeriesDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as SeriesGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.SeriesDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __seriesGET2(context, axiosConfig) : __seriesGET2,
    queryKey: seriesGET2QueryKey(id),
    ...seriesGET2DefaultOptions as unknown as Omit<UseQueryOptions<Types.SeriesDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setSeriesGET2Data(queryClient: QueryClient, updater: (data: Types.SeriesDto | undefined) => Types.SeriesDto, id: string) {
  queryClient.setQueryData(seriesGET2QueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setSeriesGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.SeriesDto | undefined) => Types.SeriesDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function seriesPATCHUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Series/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function seriesPATCHMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'seriesPATCH',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useSeriesPATCHMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.SeriesDto, unknown, Types.SeriesDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.SeriesDto, unknown, Types.SeriesDto, TContext> {
  const key = seriesPATCHMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.SeriesDto) => Client.seriesPATCH(id, body),
    mutationKey: key,
  });
}
  
type SeriesPATCH__MutationParameters = SeriesPATCHQueryParameters & {
  body: Types.SeriesDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useSeriesPATCHMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.SeriesDto, unknown, SeriesPATCH__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: SeriesPATCHQueryParameters}): UseMutationResult<Types.SeriesDto, unknown, SeriesPATCH__MutationParameters, TContext> {
  const key = seriesPATCHMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: SeriesPATCH__MutationParameters) => Client.seriesPATCH(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function storageSystemGETUrl(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined): string {
  let url_ = getBaseUrl() + "/api/StorageSystem?";
if (pageNumber === null)
    throw new Error("The parameter 'pageNumber' cannot be null.");
else if (pageNumber !== undefined)
    url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
if (totalCount === null)
    throw new Error("The parameter 'totalCount' cannot be null.");
else if (totalCount !== undefined)
    url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&";
if (sort_SortBy === null)
    throw new Error("The parameter 'sort_SortBy' cannot be null.");
else if (sort_SortBy !== undefined)
    url_ += "Sort.SortBy=" + encodeURIComponent("" + sort_SortBy) + "&";
if (sort_Ascending === null)
    throw new Error("The parameter 'sort_Ascending' cannot be null.");
else if (sort_Ascending !== undefined)
    url_ += "Sort.Ascending=" + encodeURIComponent("" + sort_Ascending) + "&";
if (filter_Logic === null)
    throw new Error("The parameter 'filter_Logic' cannot be null.");
else if (filter_Logic !== undefined)
    url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&";
if (filter_Conditions === null)
    throw new Error("The parameter 'filter_Conditions' cannot be null.");
else if (filter_Conditions !== undefined)
    filter_Conditions && filter_Conditions.forEach((item, index) => {
        for (let attr in item)
			if (item.hasOwnProperty(attr)) {
				url_ += "Filter.Conditions[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
			}
    });
if (filter_Groups === null)
    throw new Error("The parameter 'filter_Groups' cannot be null.");
else if (filter_Groups !== undefined)
    filter_Groups && filter_Groups.forEach((item, index) => {
        for (let attr in item)
			if (item.hasOwnProperty(attr)) {
				url_ += "Filter.Groups[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
			}
    });
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let storageSystemGETDefaultOptions: Omit<UseQueryOptions<Types.StorageSystemDtoQueryResponse, unknown, Types.StorageSystemDtoQueryResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.StorageSystemDtoQueryResponse, unknown, Types.StorageSystemDtoQueryResponse>, 'queryFn'>> = {
};
export function getStorageSystemGETDefaultOptions() {
  return storageSystemGETDefaultOptions;
};
export function setStorageSystemGETDefaultOptions(options: typeof storageSystemGETDefaultOptions) {
  storageSystemGETDefaultOptions = options;
}

export function storageSystemGETQueryKey(dto: StorageSystemGETQueryParameters): QueryKey;
export function storageSystemGETQueryKey(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined): QueryKey;
export function storageSystemGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups,  } = params[0] as StorageSystemGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'storageSystemGET',
        pageNumber as any,
        pageSize as any,
        totalCount as any,
        sort_SortBy as any,
        sort_Ascending as any,
        filter_Logic as any,
        filter_Conditions as any,
        filter_Groups as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'storageSystemGET',
        ...params
      ]);
  }
}
export function __storageSystemGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.storageSystemGET(
      context.queryKey[2] as number | undefined,       context.queryKey[3] as number | undefined,       context.queryKey[4] as number | undefined,       context.queryKey[5] as string | undefined,       context.queryKey[6] as boolean | undefined,       context.queryKey[7] as Types.LogicalOperator | undefined,       context.queryKey[8] as Types.FilterCondition[] | undefined,       context.queryKey[9] as Types.FilterGroup[] | undefined,axiosConfig    );
}

export function useStorageSystemGETQuery<TSelectData = Types.StorageSystemDtoQueryResponse, TError = unknown>(dto: StorageSystemGETQueryParameters, options?: Omit<UseQueryOptions<Types.StorageSystemDtoQueryResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function useStorageSystemGETQuery<TSelectData = Types.StorageSystemDtoQueryResponse, TError = unknown>(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined, options?: Omit<UseQueryOptions<Types.StorageSystemDtoQueryResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useStorageSystemGETQuery<TSelectData = Types.StorageSystemDtoQueryResponse, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.StorageSystemDtoQueryResponse, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let pageNumber: any = undefined;
  let pageSize: any = undefined;
  let totalCount: any = undefined;
  let sort_SortBy: any = undefined;
  let sort_Ascending: any = undefined;
  let filter_Logic: any = undefined;
  let filter_Conditions: any = undefined;
  let filter_Groups: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups,  } = params[0] as StorageSystemGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.StorageSystemDtoQueryResponse, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __storageSystemGET(context, axiosConfig) : __storageSystemGET,
    queryKey: storageSystemGETQueryKey(pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups),
    ...storageSystemGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.StorageSystemDtoQueryResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function setStorageSystemGETData(queryClient: QueryClient, updater: (data: Types.StorageSystemDtoQueryResponse | undefined) => Types.StorageSystemDtoQueryResponse, pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined) {
  queryClient.setQueryData(storageSystemGETQueryKey(pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups),
    updater
  );
}

/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function setStorageSystemGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.StorageSystemDtoQueryResponse | undefined) => Types.StorageSystemDtoQueryResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function storageSystemPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/StorageSystem";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function storageSystemPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'storageSystemPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useStorageSystemPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.StorageSystemDto, unknown, Types.StorageSystemDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.StorageSystemDto, unknown, Types.StorageSystemDto, TContext> {
  const key = storageSystemPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.StorageSystemDto) => Client.storageSystemPOST(body),
    mutationKey: key,
  });
}
  
export function storageSystemGET2Url(id: string): string {
  let url_ = getBaseUrl() + "/api/StorageSystem/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let storageSystemGET2DefaultOptions: Omit<UseQueryOptions<Types.StorageSystemDto, unknown, Types.StorageSystemDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.StorageSystemDto, unknown, Types.StorageSystemDto>, 'queryFn'>> = {
};
export function getStorageSystemGET2DefaultOptions() {
  return storageSystemGET2DefaultOptions;
};
export function setStorageSystemGET2DefaultOptions(options: typeof storageSystemGET2DefaultOptions) {
  storageSystemGET2DefaultOptions = options;
}

export function storageSystemGET2QueryKey(id: string): QueryKey;
export function storageSystemGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as StorageSystemGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'storageSystemGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'storageSystemGET2',
        ...params
      ]);
  }
}
export function __storageSystemGET2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.storageSystemGET2(
      context.queryKey[2] as string,axiosConfig    );
}

export function useStorageSystemGET2Query<TSelectData = Types.StorageSystemDto, TError = unknown>(dto: StorageSystemGET2QueryParameters, options?: Omit<UseQueryOptions<Types.StorageSystemDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useStorageSystemGET2Query<TSelectData = Types.StorageSystemDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.StorageSystemDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useStorageSystemGET2Query<TSelectData = Types.StorageSystemDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.StorageSystemDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as StorageSystemGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.StorageSystemDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __storageSystemGET2(context, axiosConfig) : __storageSystemGET2,
    queryKey: storageSystemGET2QueryKey(id),
    ...storageSystemGET2DefaultOptions as unknown as Omit<UseQueryOptions<Types.StorageSystemDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setStorageSystemGET2Data(queryClient: QueryClient, updater: (data: Types.StorageSystemDto | undefined) => Types.StorageSystemDto, id: string) {
  queryClient.setQueryData(storageSystemGET2QueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setStorageSystemGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.StorageSystemDto | undefined) => Types.StorageSystemDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function storageSystemDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/StorageSystem/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function storageSystemDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'storageSystemDELETE',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useStorageSystemDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<boolean, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<boolean, unknown, void, TContext> {
  const key = storageSystemDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.storageSystemDELETE(id),
    mutationKey: key,
  });
}
  
type StorageSystemDELETE__MutationParameters = StorageSystemDELETEQueryParameters

/**
 * @return OK
 */
export function useStorageSystemDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<boolean, unknown, StorageSystemDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: StorageSystemDELETEQueryParameters}): UseMutationResult<boolean, unknown, StorageSystemDELETE__MutationParameters, TContext> {
  const key = storageSystemDELETEMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: StorageSystemDELETE__MutationParameters) => Client.storageSystemDELETE(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function vehiclesGETUrl(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined): string {
  let url_ = getBaseUrl() + "/api/Vehicles?";
if (pageNumber === null)
    throw new Error("The parameter 'pageNumber' cannot be null.");
else if (pageNumber !== undefined)
    url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
if (totalCount === null)
    throw new Error("The parameter 'totalCount' cannot be null.");
else if (totalCount !== undefined)
    url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&";
if (sort_SortBy === null)
    throw new Error("The parameter 'sort_SortBy' cannot be null.");
else if (sort_SortBy !== undefined)
    url_ += "Sort.SortBy=" + encodeURIComponent("" + sort_SortBy) + "&";
if (sort_Ascending === null)
    throw new Error("The parameter 'sort_Ascending' cannot be null.");
else if (sort_Ascending !== undefined)
    url_ += "Sort.Ascending=" + encodeURIComponent("" + sort_Ascending) + "&";
if (filter_Logic === null)
    throw new Error("The parameter 'filter_Logic' cannot be null.");
else if (filter_Logic !== undefined)
    url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&";
if (filter_Conditions === null)
    throw new Error("The parameter 'filter_Conditions' cannot be null.");
else if (filter_Conditions !== undefined)
    filter_Conditions && filter_Conditions.forEach((item, index) => {
        for (let attr in item)
			if (item.hasOwnProperty(attr)) {
				url_ += "Filter.Conditions[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
			}
    });
if (filter_Groups === null)
    throw new Error("The parameter 'filter_Groups' cannot be null.");
else if (filter_Groups !== undefined)
    filter_Groups && filter_Groups.forEach((item, index) => {
        for (let attr in item)
			if (item.hasOwnProperty(attr)) {
				url_ += "Filter.Groups[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
			}
    });
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let vehiclesGETDefaultOptions: Omit<UseQueryOptions<Types.VehicleDtoQueryResponse, unknown, Types.VehicleDtoQueryResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.VehicleDtoQueryResponse, unknown, Types.VehicleDtoQueryResponse>, 'queryFn'>> = {
};
export function getVehiclesGETDefaultOptions() {
  return vehiclesGETDefaultOptions;
};
export function setVehiclesGETDefaultOptions(options: typeof vehiclesGETDefaultOptions) {
  vehiclesGETDefaultOptions = options;
}

export function vehiclesGETQueryKey(dto: VehiclesGETQueryParameters): QueryKey;
export function vehiclesGETQueryKey(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined): QueryKey;
export function vehiclesGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups,  } = params[0] as VehiclesGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'vehiclesGET',
        pageNumber as any,
        pageSize as any,
        totalCount as any,
        sort_SortBy as any,
        sort_Ascending as any,
        filter_Logic as any,
        filter_Conditions as any,
        filter_Groups as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'vehiclesGET',
        ...params
      ]);
  }
}
export function __vehiclesGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.vehiclesGET(
      context.queryKey[2] as number | undefined,       context.queryKey[3] as number | undefined,       context.queryKey[4] as number | undefined,       context.queryKey[5] as string | undefined,       context.queryKey[6] as boolean | undefined,       context.queryKey[7] as Types.LogicalOperator | undefined,       context.queryKey[8] as Types.FilterCondition[] | undefined,       context.queryKey[9] as Types.FilterGroup[] | undefined,axiosConfig    );
}

export function useVehiclesGETQuery<TSelectData = Types.VehicleDtoQueryResponse, TError = unknown>(dto: VehiclesGETQueryParameters, options?: Omit<UseQueryOptions<Types.VehicleDtoQueryResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function useVehiclesGETQuery<TSelectData = Types.VehicleDtoQueryResponse, TError = unknown>(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined, options?: Omit<UseQueryOptions<Types.VehicleDtoQueryResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useVehiclesGETQuery<TSelectData = Types.VehicleDtoQueryResponse, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.VehicleDtoQueryResponse, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let pageNumber: any = undefined;
  let pageSize: any = undefined;
  let totalCount: any = undefined;
  let sort_SortBy: any = undefined;
  let sort_Ascending: any = undefined;
  let filter_Logic: any = undefined;
  let filter_Conditions: any = undefined;
  let filter_Groups: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups,  } = params[0] as VehiclesGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.VehicleDtoQueryResponse, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __vehiclesGET(context, axiosConfig) : __vehiclesGET,
    queryKey: vehiclesGETQueryKey(pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups),
    ...vehiclesGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.VehicleDtoQueryResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function setVehiclesGETData(queryClient: QueryClient, updater: (data: Types.VehicleDtoQueryResponse | undefined) => Types.VehicleDtoQueryResponse, pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined) {
  queryClient.setQueryData(vehiclesGETQueryKey(pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups),
    updater
  );
}

/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function setVehiclesGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.VehicleDtoQueryResponse | undefined) => Types.VehicleDtoQueryResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function vehiclesPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/Vehicles";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function vehiclesPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'vehiclesPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useVehiclesPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.VehicleDto, unknown, Types.VehicleDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.VehicleDto, unknown, Types.VehicleDto, TContext> {
  const key = vehiclesPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.VehicleDto) => Client.vehiclesPOST(body),
    mutationKey: key,
  });
}
  
export function vehiclesGET2Url(id: string): string {
  let url_ = getBaseUrl() + "/api/Vehicles/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let vehiclesGET2DefaultOptions: Omit<UseQueryOptions<Types.VehicleDto, unknown, Types.VehicleDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.VehicleDto, unknown, Types.VehicleDto>, 'queryFn'>> = {
};
export function getVehiclesGET2DefaultOptions() {
  return vehiclesGET2DefaultOptions;
};
export function setVehiclesGET2DefaultOptions(options: typeof vehiclesGET2DefaultOptions) {
  vehiclesGET2DefaultOptions = options;
}

export function vehiclesGET2QueryKey(id: string): QueryKey;
export function vehiclesGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as VehiclesGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'vehiclesGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'vehiclesGET2',
        ...params
      ]);
  }
}
export function __vehiclesGET2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.vehiclesGET2(
      context.queryKey[2] as string,axiosConfig    );
}

export function useVehiclesGET2Query<TSelectData = Types.VehicleDto, TError = unknown>(dto: VehiclesGET2QueryParameters, options?: Omit<UseQueryOptions<Types.VehicleDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useVehiclesGET2Query<TSelectData = Types.VehicleDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.VehicleDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useVehiclesGET2Query<TSelectData = Types.VehicleDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.VehicleDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as VehiclesGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.VehicleDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __vehiclesGET2(context, axiosConfig) : __vehiclesGET2,
    queryKey: vehiclesGET2QueryKey(id),
    ...vehiclesGET2DefaultOptions as unknown as Omit<UseQueryOptions<Types.VehicleDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setVehiclesGET2Data(queryClient: QueryClient, updater: (data: Types.VehicleDto | undefined) => Types.VehicleDto, id: string) {
  queryClient.setQueryData(vehiclesGET2QueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setVehiclesGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.VehicleDto | undefined) => Types.VehicleDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function vehiclesPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Vehicles/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function vehiclesPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'vehiclesPUT',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useVehiclesPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.VehicleDto, unknown, Types.VehicleDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.VehicleDto, unknown, Types.VehicleDto, TContext> {
  const key = vehiclesPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.VehicleDto) => Client.vehiclesPUT(id, body),
    mutationKey: key,
  });
}
  
type VehiclesPUT__MutationParameters = VehiclesPUTQueryParameters & {
  body: Types.VehicleDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useVehiclesPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.VehicleDto, unknown, VehiclesPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: VehiclesPUTQueryParameters}): UseMutationResult<Types.VehicleDto, unknown, VehiclesPUT__MutationParameters, TContext> {
  const key = vehiclesPUTMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: VehiclesPUT__MutationParameters) => Client.vehiclesPUT(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function vehiclesDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Vehicles/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function vehiclesDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'vehiclesDELETE',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useVehiclesDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<boolean, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<boolean, unknown, void, TContext> {
  const key = vehiclesDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.vehiclesDELETE(id),
    mutationKey: key,
  });
}
  
type VehiclesDELETE__MutationParameters = VehiclesDELETEQueryParameters

/**
 * @return OK
 */
export function useVehiclesDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<boolean, unknown, VehiclesDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: VehiclesDELETEQueryParameters}): UseMutationResult<boolean, unknown, VehiclesDELETE__MutationParameters, TContext> {
  const key = vehiclesDELETEMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: VehiclesDELETE__MutationParameters) => Client.vehiclesDELETE(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function warehousesGETUrl(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined): string {
  let url_ = getBaseUrl() + "/api/Warehouses?";
if (pageNumber === null)
    throw new Error("The parameter 'pageNumber' cannot be null.");
else if (pageNumber !== undefined)
    url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
if (pageSize === null)
    throw new Error("The parameter 'pageSize' cannot be null.");
else if (pageSize !== undefined)
    url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
if (totalCount === null)
    throw new Error("The parameter 'totalCount' cannot be null.");
else if (totalCount !== undefined)
    url_ += "TotalCount=" + encodeURIComponent("" + totalCount) + "&";
if (sort_SortBy === null)
    throw new Error("The parameter 'sort_SortBy' cannot be null.");
else if (sort_SortBy !== undefined)
    url_ += "Sort.SortBy=" + encodeURIComponent("" + sort_SortBy) + "&";
if (sort_Ascending === null)
    throw new Error("The parameter 'sort_Ascending' cannot be null.");
else if (sort_Ascending !== undefined)
    url_ += "Sort.Ascending=" + encodeURIComponent("" + sort_Ascending) + "&";
if (filter_Logic === null)
    throw new Error("The parameter 'filter_Logic' cannot be null.");
else if (filter_Logic !== undefined)
    url_ += "Filter.Logic=" + encodeURIComponent("" + filter_Logic) + "&";
if (filter_Conditions === null)
    throw new Error("The parameter 'filter_Conditions' cannot be null.");
else if (filter_Conditions !== undefined)
    filter_Conditions && filter_Conditions.forEach((item, index) => {
        for (let attr in item)
			if (item.hasOwnProperty(attr)) {
				url_ += "Filter.Conditions[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
			}
    });
if (filter_Groups === null)
    throw new Error("The parameter 'filter_Groups' cannot be null.");
else if (filter_Groups !== undefined)
    filter_Groups && filter_Groups.forEach((item, index) => {
        for (let attr in item)
			if (item.hasOwnProperty(attr)) {
				url_ += "Filter.Groups[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
			}
    });
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let warehousesGETDefaultOptions: Omit<UseQueryOptions<Types.WarehouseDtoQueryResponse, unknown, Types.WarehouseDtoQueryResponse>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.WarehouseDtoQueryResponse, unknown, Types.WarehouseDtoQueryResponse>, 'queryFn'>> = {
};
export function getWarehousesGETDefaultOptions() {
  return warehousesGETDefaultOptions;
};
export function setWarehousesGETDefaultOptions(options: typeof warehousesGETDefaultOptions) {
  warehousesGETDefaultOptions = options;
}

export function warehousesGETQueryKey(dto: WarehousesGETQueryParameters): QueryKey;
export function warehousesGETQueryKey(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined): QueryKey;
export function warehousesGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups,  } = params[0] as WarehousesGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'warehousesGET',
        pageNumber as any,
        pageSize as any,
        totalCount as any,
        sort_SortBy as any,
        sort_Ascending as any,
        filter_Logic as any,
        filter_Conditions as any,
        filter_Groups as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'warehousesGET',
        ...params
      ]);
  }
}
export function __warehousesGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.warehousesGET(
      context.queryKey[2] as number | undefined,       context.queryKey[3] as number | undefined,       context.queryKey[4] as number | undefined,       context.queryKey[5] as string | undefined,       context.queryKey[6] as boolean | undefined,       context.queryKey[7] as Types.LogicalOperator | undefined,       context.queryKey[8] as Types.FilterCondition[] | undefined,       context.queryKey[9] as Types.FilterGroup[] | undefined,axiosConfig    );
}

export function useWarehousesGETQuery<TSelectData = Types.WarehouseDtoQueryResponse, TError = unknown>(dto: WarehousesGETQueryParameters, options?: Omit<UseQueryOptions<Types.WarehouseDtoQueryResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function useWarehousesGETQuery<TSelectData = Types.WarehouseDtoQueryResponse, TError = unknown>(pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined, options?: Omit<UseQueryOptions<Types.WarehouseDtoQueryResponse, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useWarehousesGETQuery<TSelectData = Types.WarehouseDtoQueryResponse, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.WarehouseDtoQueryResponse, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let pageNumber: any = undefined;
  let pageSize: any = undefined;
  let totalCount: any = undefined;
  let sort_SortBy: any = undefined;
  let sort_Ascending: any = undefined;
  let filter_Logic: any = undefined;
  let filter_Conditions: any = undefined;
  let filter_Groups: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups,  } = params[0] as WarehousesGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.WarehouseDtoQueryResponse, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __warehousesGET(context, axiosConfig) : __warehousesGET,
    queryKey: warehousesGETQueryKey(pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups),
    ...warehousesGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.WarehouseDtoQueryResponse, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function setWarehousesGETData(queryClient: QueryClient, updater: (data: Types.WarehouseDtoQueryResponse | undefined) => Types.WarehouseDtoQueryResponse, pageNumber?: number | undefined, pageSize?: number | undefined, totalCount?: number | undefined, sort_SortBy?: string | undefined, sort_Ascending?: boolean | undefined, filter_Logic?: Types.LogicalOperator | undefined, filter_Conditions?: Types.FilterCondition[] | undefined, filter_Groups?: Types.FilterGroup[] | undefined) {
  queryClient.setQueryData(warehousesGETQueryKey(pageNumber, pageSize, totalCount, sort_SortBy, sort_Ascending, filter_Logic, filter_Conditions, filter_Groups),
    updater
  );
}

/**
 * @param pageNumber (optional) 
 * @param pageSize (optional) 
 * @param totalCount (optional) 
 * @param sort_SortBy (optional) 
 * @param sort_Ascending (optional) 
 * @param filter_Logic (optional) 
 * @param filter_Conditions (optional) 
 * @param filter_Groups (optional) 
 * @return OK
 */
export function setWarehousesGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.WarehouseDtoQueryResponse | undefined) => Types.WarehouseDtoQueryResponse) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function warehousesPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/Warehouses";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function warehousesPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'warehousesPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useWarehousesPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.WarehouseDto, unknown, Types.WarehouseDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.WarehouseDto, unknown, Types.WarehouseDto, TContext> {
  const key = warehousesPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.WarehouseDto) => Client.warehousesPOST(body),
    mutationKey: key,
  });
}
  
export function warehousesGET2Url(id: string): string {
  let url_ = getBaseUrl() + "/api/Warehouses/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let warehousesGET2DefaultOptions: Omit<UseQueryOptions<Types.WarehouseDto, unknown, Types.WarehouseDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.WarehouseDto, unknown, Types.WarehouseDto>, 'queryFn'>> = {
};
export function getWarehousesGET2DefaultOptions() {
  return warehousesGET2DefaultOptions;
};
export function setWarehousesGET2DefaultOptions(options: typeof warehousesGET2DefaultOptions) {
  warehousesGET2DefaultOptions = options;
}

export function warehousesGET2QueryKey(id: string): QueryKey;
export function warehousesGET2QueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as WarehousesGET2QueryParameters;

    return trimArrayEnd([
        'Client',
        'warehousesGET2',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'warehousesGET2',
        ...params
      ]);
  }
}
export function __warehousesGET2(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.warehousesGET2(
      context.queryKey[2] as string,axiosConfig    );
}

export function useWarehousesGET2Query<TSelectData = Types.WarehouseDto, TError = unknown>(dto: WarehousesGET2QueryParameters, options?: Omit<UseQueryOptions<Types.WarehouseDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useWarehousesGET2Query<TSelectData = Types.WarehouseDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.WarehouseDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useWarehousesGET2Query<TSelectData = Types.WarehouseDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.WarehouseDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as WarehousesGET2QueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.WarehouseDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __warehousesGET2(context, axiosConfig) : __warehousesGET2,
    queryKey: warehousesGET2QueryKey(id),
    ...warehousesGET2DefaultOptions as unknown as Omit<UseQueryOptions<Types.WarehouseDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setWarehousesGET2Data(queryClient: QueryClient, updater: (data: Types.WarehouseDto | undefined) => Types.WarehouseDto, id: string) {
  queryClient.setQueryData(warehousesGET2QueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setWarehousesGET2DataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.WarehouseDto | undefined) => Types.WarehouseDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function warehousesPATCHUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Warehouses/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function warehousesPATCHMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'warehousesPATCH',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useWarehousesPATCHMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.WarehouseDto, unknown, Types.WarehouseDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.WarehouseDto, unknown, Types.WarehouseDto, TContext> {
  const key = warehousesPATCHMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.WarehouseDto) => Client.warehousesPATCH(id, body),
    mutationKey: key,
  });
}
  
type WarehousesPATCH__MutationParameters = WarehousesPATCHQueryParameters & {
  body: Types.WarehouseDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useWarehousesPATCHMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.WarehouseDto, unknown, WarehousesPATCH__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: WarehousesPATCHQueryParameters}): UseMutationResult<Types.WarehouseDto, unknown, WarehousesPATCH__MutationParameters, TContext> {
  const key = warehousesPATCHMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: WarehousesPATCH__MutationParameters) => Client.warehousesPATCH(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function warehousesPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Warehouses/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function warehousesPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'warehousesPUT',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useWarehousesPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.WarehouseDto, unknown, Types.WarehouseDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.WarehouseDto, unknown, Types.WarehouseDto, TContext> {
  const key = warehousesPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.WarehouseDto) => Client.warehousesPUT(id, body),
    mutationKey: key,
  });
}
  
type WarehousesPUT__MutationParameters = WarehousesPUTQueryParameters & {
  body: Types.WarehouseDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useWarehousesPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.WarehouseDto, unknown, WarehousesPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: WarehousesPUTQueryParameters}): UseMutationResult<Types.WarehouseDto, unknown, WarehousesPUT__MutationParameters, TContext> {
  const key = warehousesPUTMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: WarehousesPUT__MutationParameters) => Client.warehousesPUT(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function warehousesDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Warehouses/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function warehousesDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'warehousesDELETE',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useWarehousesDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<boolean, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<boolean, unknown, void, TContext> {
  const key = warehousesDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.warehousesDELETE(id),
    mutationKey: key,
  });
}
  
type WarehousesDELETE__MutationParameters = WarehousesDELETEQueryParameters

/**
 * @return OK
 */
export function useWarehousesDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<boolean, unknown, WarehousesDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: WarehousesDELETEQueryParameters}): UseMutationResult<boolean, unknown, WarehousesDELETE__MutationParameters, TContext> {
  const key = warehousesDELETEMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: WarehousesDELETE__MutationParameters) => Client.warehousesDELETE(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}
  
export function widgetsAllUrl(): string {
  let url_ = getBaseUrl() + "/api/layout/Widgets";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let widgetsAllDefaultOptions: Omit<UseQueryOptions<Types.WidgetDto[], unknown, Types.WidgetDto[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.WidgetDto[], unknown, Types.WidgetDto[]>, 'queryFn'>> = {
};
export function getWidgetsAllDefaultOptions() {
  return widgetsAllDefaultOptions;
};
export function setWidgetsAllDefaultOptions(options: typeof widgetsAllDefaultOptions) {
  widgetsAllDefaultOptions = options;
}

export function widgetsAllQueryKey(): QueryKey;
export function widgetsAllQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'widgetsAll',
    ]);
}
export function __widgetsAll(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.widgetsAll(
axiosConfig    );
}

/**
 * @return OK
 */
export function useWidgetsAllQuery<TSelectData = Types.WidgetDto[], TError = unknown>(options?: Omit<UseQueryOptions<Types.WidgetDto[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useWidgetsAllQuery<TSelectData = Types.WidgetDto[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.WidgetDto[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.WidgetDto[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __widgetsAll(context, axiosConfig) : __widgetsAll,
    queryKey: widgetsAllQueryKey(),
    ...widgetsAllDefaultOptions as unknown as Omit<UseQueryOptions<Types.WidgetDto[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setWidgetsAllData(queryClient: QueryClient, updater: (data: Types.WidgetDto[] | undefined) => Types.WidgetDto[], ) {
  queryClient.setQueryData(widgetsAllQueryKey(),
    updater
  );
}

/**
 * @return OK
 */
export function setWidgetsAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.WidgetDto[] | undefined) => Types.WidgetDto[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function widgetsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/layout/Widgets";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function widgetsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'widgetsPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useWidgetsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.WidgetDto, unknown, Types.WidgetDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.WidgetDto, unknown, Types.WidgetDto, TContext> {
  const key = widgetsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.WidgetDto) => Client.widgetsPOST(body),
    mutationKey: key,
  });
}
  
export function widgetsGETUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/Widgets/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let widgetsGETDefaultOptions: Omit<UseQueryOptions<Types.WidgetDto, unknown, Types.WidgetDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.WidgetDto, unknown, Types.WidgetDto>, 'queryFn'>> = {
};
export function getWidgetsGETDefaultOptions() {
  return widgetsGETDefaultOptions;
};
export function setWidgetsGETDefaultOptions(options: typeof widgetsGETDefaultOptions) {
  widgetsGETDefaultOptions = options;
}

export function widgetsGETQueryKey(id: string): QueryKey;
export function widgetsGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as WidgetsGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'widgetsGET',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'widgetsGET',
        ...params
      ]);
  }
}
export function __widgetsGET(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.widgetsGET(
      context.queryKey[2] as string,axiosConfig    );
}

export function useWidgetsGETQuery<TSelectData = Types.WidgetDto, TError = unknown>(dto: WidgetsGETQueryParameters, options?: Omit<UseQueryOptions<Types.WidgetDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return OK
 */
export function useWidgetsGETQuery<TSelectData = Types.WidgetDto, TError = unknown>(id: string, options?: Omit<UseQueryOptions<Types.WidgetDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useWidgetsGETQuery<TSelectData = Types.WidgetDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.WidgetDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as WidgetsGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.WidgetDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __widgetsGET(context, axiosConfig) : __widgetsGET,
    queryKey: widgetsGETQueryKey(id),
    ...widgetsGETDefaultOptions as unknown as Omit<UseQueryOptions<Types.WidgetDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * @return OK
 */
export function setWidgetsGETData(queryClient: QueryClient, updater: (data: Types.WidgetDto | undefined) => Types.WidgetDto, id: string) {
  queryClient.setQueryData(widgetsGETQueryKey(id),
    updater
  );
}

/**
 * @return OK
 */
export function setWidgetsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.WidgetDto | undefined) => Types.WidgetDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function widgetsPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/Widgets/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function widgetsPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'widgetsPUT',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useWidgetsPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<Types.WidgetDto, unknown, Types.WidgetDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.WidgetDto, unknown, Types.WidgetDto, TContext> {
  const key = widgetsPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.WidgetDto) => Client.widgetsPUT(id, body),
    mutationKey: key,
  });
}
  
type WidgetsPUT__MutationParameters = WidgetsPUTQueryParameters & {
  body: Types.WidgetDto;
}

/**
 * @param body (optional) 
 * @return OK
 */
export function useWidgetsPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.WidgetDto, unknown, WidgetsPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: WidgetsPUTQueryParameters}): UseMutationResult<Types.WidgetDto, unknown, WidgetsPUT__MutationParameters, TContext> {
  const key = widgetsPUTMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: WidgetsPUT__MutationParameters) => Client.widgetsPUT(data.id ?? options?.parameters?.id!, data.body),
  mutationKey: key,
});
}
  
export function widgetsDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/layout/Widgets/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function widgetsDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'widgetsDELETE',
      id as any,
    ]);
}

/**
 * @return OK
 */
export function useWidgetsDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<boolean, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<boolean, unknown, void, TContext> {
  const key = widgetsDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.widgetsDELETE(id),
    mutationKey: key,
  });
}
  
type WidgetsDELETE__MutationParameters = WidgetsDELETEQueryParameters

/**
 * @return OK
 */
export function useWidgetsDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<boolean, unknown, WidgetsDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: WidgetsDELETEQueryParameters}): UseMutationResult<boolean, unknown, WidgetsDELETE__MutationParameters, TContext> {
  const key = widgetsDELETEMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: WidgetsDELETE__MutationParameters) => Client.widgetsDELETE(data.id ?? options?.parameters?.id!),
  mutationKey: key,
});
}